(function webpackUniversalModuleDefinition(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory();else if(typeof define==="function"&&define.amd)define([],factory);else if(typeof exports==="object")exports["Viewing.Extension.Markup2D"]=factory();else root["Viewing.Extension.Markup2D"]=factory()})(this,function(){return function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={exports:{},id:moduleId,loaded:false};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.loaded=true;return module.exports}__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.p="";return __webpack_require__(0)}({0:function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ViewingExtensionMarkup2D = __webpack_require__(146);\n\nvar _ViewingExtensionMarkup2D2 = _interopRequireDefault(_ViewingExtensionMarkup2D);\n\nvar _Viewer = __webpack_require__(11);\n\nvar _Viewer2 = _interopRequireDefault(_Viewer);\n\nvar _Viewer3 = __webpack_require__(8);\n\nvar _Viewer4 = _interopRequireDefault(_Viewer3);\n\n__webpack_require__(292);\n\n__webpack_require__(145);\n\n__webpack_require__(293);\n\n__webpack_require__(147);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /////////////////////////////////////////////////////////////////////\n// Autodesk.ADN.Viewing.Extension.Markup\n// by Philippe Leefsma, Feb 2016\n//\n/////////////////////////////////////////////////////////////////////\n\n\nvar Markup2DExtension = function (_ExtensionBase) {\n  _inherits(Markup2DExtension, _ExtensionBase);\n\n  /////////////////////////////////////////////////////////////////\n  // Class constructor\n  //\n  /////////////////////////////////////////////////////////////////\n  function Markup2DExtension(viewer, options) {\n    _classCallCheck(this, Markup2DExtension);\n\n    return _possibleConstructorReturn(this, (Markup2DExtension.__proto__ || Object.getPrototypeOf(Markup2DExtension)).call(this, viewer, options));\n  }\n\n  /////////////////////////////////////////////////////////////////\n  // Extension Id\n  //\n  /////////////////////////////////////////////////////////////////\n\n\n  _createClass(Markup2DExtension, [{\n    key: 'load',\n\n\n    /////////////////////////////////////////////////////////////////\n    // Load callback\n    //\n    /////////////////////////////////////////////////////////////////\n    value: function load() {\n      var _this2 = this;\n\n      this._control = _Viewer4.default.createButton('toolbar-markup2D', 'glyphicon glyphicon-edit', 'Markup 2D Panel', function () {\n\n        _this2._panel.toggleVisibility();\n      });\n\n      this._panel = new _ViewingExtensionMarkup2D2.default(this._viewer, 'markup2d', this._control.container);\n\n      this.parentControl = this._options.parentControl;\n\n      if (!this.parentControl) {\n\n        var viewerToolbar = this._viewer.getToolbar(true);\n\n        this.parentControl = new Autodesk.Viewing.UI.ControlGroup('markup');\n\n        viewerToolbar.addControl(this.parentControl);\n      }\n\n      this.parentControl.addControl(this._control);\n\n      this._panel.setVisible(this._options.showPanel);\n\n      console.log('Viewing.Extension.Markup2D loaded');\n\n      return true;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Unload callback\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'unload',\n    value: function unload() {\n\n      this.parentControl.removeControl(this._control);\n\n      console.log('Viewing.Extension.Markup2D unloaded');\n    }\n  }], [{\n    key: 'ExtensionId',\n    get: function get() {\n\n      return 'Viewing.Extension.Markup2D';\n    }\n  }]);\n\n  return Markup2DExtension;\n}(_Viewer2.default);\n\nAutodesk.Viewing.theExtensionManager.registerExtension(Markup2DExtension.ExtensionId, Markup2DExtension);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuanM/NTFlZCJdLCJuYW1lcyI6WyJNYXJrdXAyREV4dGVuc2lvbiIsInZpZXdlciIsIm9wdGlvbnMiLCJfY29udHJvbCIsImNyZWF0ZUJ1dHRvbiIsIl9wYW5lbCIsInRvZ2dsZVZpc2liaWxpdHkiLCJfdmlld2VyIiwiY29udGFpbmVyIiwicGFyZW50Q29udHJvbCIsIl9vcHRpb25zIiwidmlld2VyVG9vbGJhciIsImdldFRvb2xiYXIiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJVSSIsIkNvbnRyb2xHcm91cCIsImFkZENvbnRyb2wiLCJzZXRWaXNpYmxlIiwic2hvd1BhbmVsIiwiY29uc29sZSIsImxvZyIsInJlbW92ZUNvbnRyb2wiLCJ0aGVFeHRlbnNpb25NYW5hZ2VyIiwicmVnaXN0ZXJFeHRlbnNpb24iLCJFeHRlbnNpb25JZCJdLCJtYXBwaW5ncyI6Ijs7OztBQUtBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OzsrZUFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7SUFTTUEsaUI7OztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQWFDLE1BQWIsRUFBcUJDLE9BQXJCLEVBQThCO0FBQUE7O0FBQUEsaUlBRXRCRCxNQUZzQixFQUVkQyxPQUZjO0FBRzdCOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7MkJBQ1E7QUFBQTs7QUFFTixXQUFLQyxRQUFMLEdBQWdCLGlCQUFjQyxZQUFkLENBQ2Qsa0JBRGMsRUFFZCwwQkFGYyxFQUdkLGlCQUhjLEVBR0ssWUFBTTs7QUFFdkIsZUFBS0MsTUFBTCxDQUFZQyxnQkFBWjtBQUNELE9BTmEsQ0FBaEI7O0FBUUEsV0FBS0QsTUFBTCxHQUFjLHVDQUNaLEtBQUtFLE9BRE8sRUFFWixVQUZZLEVBR1osS0FBS0osUUFBTCxDQUFjSyxTQUhGLENBQWQ7O0FBS0EsV0FBS0MsYUFBTCxHQUFxQixLQUFLQyxRQUFMLENBQWNELGFBQW5DOztBQUVBLFVBQUksQ0FBQyxLQUFLQSxhQUFWLEVBQXlCOztBQUV2QixZQUFJRSxnQkFBZ0IsS0FBS0osT0FBTCxDQUFhSyxVQUFiLENBQXdCLElBQXhCLENBQXBCOztBQUVBLGFBQUtILGFBQUwsR0FBcUIsSUFBSUksU0FBU0MsT0FBVCxDQUFpQkMsRUFBakIsQ0FBb0JDLFlBQXhCLENBQ25CLFFBRG1CLENBQXJCOztBQUdBTCxzQkFBY00sVUFBZCxDQUF5QixLQUFLUixhQUE5QjtBQUNEOztBQUVELFdBQUtBLGFBQUwsQ0FBbUJRLFVBQW5CLENBQ0UsS0FBS2QsUUFEUDs7QUFHQSxXQUFLRSxNQUFMLENBQVlhLFVBQVosQ0FDRSxLQUFLUixRQUFMLENBQWNTLFNBRGhCOztBQUdBQyxjQUFRQyxHQUFSLENBQVksbUNBQVo7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7NkJBQ1U7O0FBRVIsV0FBS1osYUFBTCxDQUFtQmEsYUFBbkIsQ0FDRSxLQUFLbkIsUUFEUDs7QUFHQWlCLGNBQVFDLEdBQVIsQ0FBWSxxQ0FBWjtBQUNEOzs7d0JBekR5Qjs7QUFFeEIsYUFBTyw0QkFBUDtBQUNEOzs7Ozs7QUF5REhSLFNBQVNDLE9BQVQsQ0FBaUJTLG1CQUFqQixDQUFxQ0MsaUJBQXJDLENBQ0V4QixrQkFBa0J5QixXQURwQixFQUVFekIsaUJBRkYiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQXV0b2Rlc2suQUROLlZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cFxuLy8gYnkgUGhpbGlwcGUgTGVlZnNtYSwgRmViIDIwMTZcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmltcG9ydCBNYXJrdXAyRFBhbmVsIGZyb20gJy4vVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuUGFuZWwnXG5pbXBvcnQgRXh0ZW5zaW9uQmFzZSBmcm9tICdWaWV3ZXIuRXh0ZW5zaW9uQmFzZSdcbmltcG9ydCBWaWV3ZXJUb29sa2l0IGZyb20gJ1ZpZXdlci5Ub29sa2l0J1xuaW1wb3J0ICcuL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJELmNzcydcbmltcG9ydCAnLi9NYXJrdXBzQ29yZS5qcydcbmltcG9ydCAnLi9zcGVjdHJ1bS5jc3MnXG5pbXBvcnQgJy4vc3BlY3RydW0nXG5cbmNsYXNzIE1hcmt1cDJERXh0ZW5zaW9uIGV4dGVuZHMgRXh0ZW5zaW9uQmFzZSB7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gQ2xhc3MgY29uc3RydWN0b3JcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgY29uc3RydWN0b3IgKHZpZXdlciwgb3B0aW9ucykge1xuXG4gICAgc3VwZXIodmlld2VyLCBvcHRpb25zKVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gRXh0ZW5zaW9uIElkXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBnZXQgRXh0ZW5zaW9uSWQgKCkge1xuXG4gICAgcmV0dXJuICdWaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRCdcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIExvYWQgY2FsbGJhY2tcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgbG9hZCAoKSB7XG5cbiAgICB0aGlzLl9jb250cm9sID0gVmlld2VyVG9vbGtpdC5jcmVhdGVCdXR0b24oXG4gICAgICAndG9vbGJhci1tYXJrdXAyRCcsXG4gICAgICAnZ2x5cGhpY29uIGdseXBoaWNvbi1lZGl0JyxcbiAgICAgICdNYXJrdXAgMkQgUGFuZWwnLCAoKSA9PiB7XG5cbiAgICAgICAgdGhpcy5fcGFuZWwudG9nZ2xlVmlzaWJpbGl0eSgpXG4gICAgICB9KVxuXG4gICAgdGhpcy5fcGFuZWwgPSBuZXcgTWFya3VwMkRQYW5lbChcbiAgICAgIHRoaXMuX3ZpZXdlcixcbiAgICAgICdtYXJrdXAyZCcsXG4gICAgICB0aGlzLl9jb250cm9sLmNvbnRhaW5lcilcblxuICAgIHRoaXMucGFyZW50Q29udHJvbCA9IHRoaXMuX29wdGlvbnMucGFyZW50Q29udHJvbFxuXG4gICAgaWYgKCF0aGlzLnBhcmVudENvbnRyb2wpIHtcblxuICAgICAgdmFyIHZpZXdlclRvb2xiYXIgPSB0aGlzLl92aWV3ZXIuZ2V0VG9vbGJhcih0cnVlKVxuXG4gICAgICB0aGlzLnBhcmVudENvbnRyb2wgPSBuZXcgQXV0b2Rlc2suVmlld2luZy5VSS5Db250cm9sR3JvdXAoXG4gICAgICAgICdtYXJrdXAnKVxuXG4gICAgICB2aWV3ZXJUb29sYmFyLmFkZENvbnRyb2wodGhpcy5wYXJlbnRDb250cm9sKVxuICAgIH1cblxuICAgIHRoaXMucGFyZW50Q29udHJvbC5hZGRDb250cm9sKFxuICAgICAgdGhpcy5fY29udHJvbClcblxuICAgIHRoaXMuX3BhbmVsLnNldFZpc2libGUoXG4gICAgICB0aGlzLl9vcHRpb25zLnNob3dQYW5lbClcblxuICAgIGNvbnNvbGUubG9nKCdWaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRCBsb2FkZWQnKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFVubG9hZCBjYWxsYmFja1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICB1bmxvYWQgKCkge1xuXG4gICAgdGhpcy5wYXJlbnRDb250cm9sLnJlbW92ZUNvbnRyb2woXG4gICAgICB0aGlzLl9jb250cm9sKVxuXG4gICAgY29uc29sZS5sb2coJ1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJEIHVubG9hZGVkJylcbiAgfVxufVxuXG5BdXRvZGVzay5WaWV3aW5nLnRoZUV4dGVuc2lvbk1hbmFnZXIucmVnaXN0ZXJFeHRlbnNpb24oXG4gIE1hcmt1cDJERXh0ZW5zaW9uLkV4dGVuc2lvbklkLFxuICBNYXJrdXAyREV4dGVuc2lvbilcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuanMiXSwic291cmNlUm9vdCI6IiJ9")},1:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.2.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-05-20T17:23Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === "object" && typeof module.exports === "object" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require("jquery")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( "jQuery requires a window with a document" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can\'t be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through "use strict" call chains. (#13335)\n//"use strict";\nvar arr = [];\n\nvar document = window.document;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\tversion = "2.2.4",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor \'enhanced\'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: "",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array\'s method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === "boolean" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== "object" && !jQuery.isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we\'re merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = jQuery.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don\'t bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: "jQuery" + ( version + Math.random() ).replace( /\\D/g, "" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type( obj ) === "function";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|"")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals ("0x...")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\tvar realStringObj = obj && obj.toString();\n\t\treturn !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar key;\n\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not "[object Object]"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Not own constructor property must be Object\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj, "constructor" ) &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + "";\n\t\t}\n\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === "object" || typeof obj === "function" ?\n\t\t\tclass2type[ toString.call( obj ) ] || "object" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf( "use strict" ) === 1 ) {\n\t\t\t\tscript = document.createElement( "script" );\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t\t// and removal by using an indirect global eval\n\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t"" :\n\t\t\t( text + "" ).replace( rtrim, "" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === "string" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === "string" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\n// JSHint would error on this code due to the Symbol not being defined in ES5.\n// Defining this global in .jshintrc would create a danger of using the global\n// unguarded in another place, it seems safer to just disable JSHint for these\n// three lines.\n/* jshint ignore: start */\nif ( typeof Symbol === "function" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n/* jshint ignore: end */\n\n// Populate the class2type map\njQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),\nfunction( i, name ) {\n\tclass2type[ "[object " + name + "]" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn\'t used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && "length" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === "function" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === "array" || length === 0 ||\n\t\ttypeof length === "number" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = "sizzle" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it\'s faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = "[\\\\x20\\\\t\\\\r\\\\n\\\\f]",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = "(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = "\\\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +\n\t\t// Operator (capture 2)\n\t\t"*([*^$|!~]?=)" + whitespace +\n\t\t// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"\n\t\t"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|(" + identifier + "))|)" + whitespace +\n\t\t"*\\\\]",\n\n\tpseudos = ":(" + identifier + ")(?:\\\\((" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t"(\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|" +\n\t\t// 2. simple (capture 6)\n\t\t"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|" + attributes + ")*)|" +\n\t\t// 3. anything else (capture 2)\n\t\t".*" +\n\t\t")\\\\)|)",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + "+", "g" ),\n\trtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)" + whitespace + "+$", "g" ),\n\n\trcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),\n\trcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),\n\n\trattributeQuotes = new RegExp( "=" + whitespace + "*([^\\\\]\'\\"]*?)" + whitespace + "*\\\\]", "g" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( "^" + identifier + "$" ),\n\n\tmatchExpr = {\n\t\t"ID": new RegExp( "^#(" + identifier + ")" ),\n\t\t"CLASS": new RegExp( "^\\\\.(" + identifier + ")" ),\n\t\t"TAG": new RegExp( "^(" + identifier + "|[*])" ),\n\t\t"ATTR": new RegExp( "^" + attributes ),\n\t\t"PSEUDO": new RegExp( "^" + pseudos ),\n\t\t"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(" + whitespace +\n\t\t\t"*(even|odd|(([+-]|)(\\\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +\n\t\t\t"*(\\\\d+)|))" + whitespace + "*\\\\)|)", "i" ),\n\t\t"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(" +\n\t\t\twhitespace + "*((?:-\\\\d)?\\\\d*)" + whitespace + "*\\\\)|)(?=[^-]|$)", "i" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /\'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( "\\\\\\\\([\\\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = "0x" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +"0x"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a "Permission Denied"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can\'t trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, nidselect, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== "string" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a "get*By*" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don\'t exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + " " ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== "object" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( "id" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rescape, "\\\\$&" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( "id", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\tnidselect = ridentifier.test( nid ) ? "#" + nid : "[id=\'" + nid + "\']";\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nidselect + " " + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( "," );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( "id" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, "$1" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + " " ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + " " ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement("div");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split("|"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === "input" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === "input" || name === "button") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== "undefined" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn\'t yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== "HTML" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)\n\tif ( (parent = document.defaultView) && parent.top !== parent ) {\n\t\t// Support: IE 11\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( "unload", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( "onunload", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = "i";\n\t\treturn !div.getAttribute("className");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName("*") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( document.createComment("") );\n\t\treturn !div.getElementsByTagName("*").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don\'t pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find["ID"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== "undefined" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\treturn m ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter["ID"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute("id") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find["ID"];\n\n\t\tExpr.filter["ID"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== "undefined" &&\n\t\t\t\t\telem.getAttributeNode("id");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find["TAG"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== "undefined" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don\'t have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === "*" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE\'s treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = "<a id=\'" + expando + "\'></a>" +\n\t\t\t\t"<select id=\'" + expando + "-\\r\\\\\' msallowcapture=\'\'>" +\n\t\t\t\t"<option selected=\'\'></option></select>";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but "safe" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll("[msallowcapture^=\'\']").length ) {\n\t\t\t\trbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\'\'|\\"\\")" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and "value" are not treated correctly\n\t\t\tif ( !div.querySelectorAll("[selected]").length ) {\n\t\t\t\trbuggyQSA.push( "\\\\[" + whitespace + "*(?:value|" + booleans + ")" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {\n\t\t\t\trbuggyQSA.push("~=");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(":checked").length ) {\n\t\t\t\trbuggyQSA.push(":checked");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {\n\t\t\t\trbuggyQSA.push(".#.+[+~]");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement("input");\n\t\t\tinput.setAttribute( "type", "hidden" );\n\t\t\tdiv.appendChild( input ).setAttribute( "name", "D" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll("[name=d]").length ) {\n\t\t\t\trbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(":enabled").length ) {\n\t\t\t\trbuggyQSA.push( ":enabled", ":disabled" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll("*,:x");\n\t\t\trbuggyQSA.push(",.*:");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it\'s possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, "div" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, "[s!=\'\']:x" );\n\t\t\trbuggyMatches.push( "!=", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, "=\'$1\']" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + " " ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9\'s matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don\'t get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( "Syntax error, unrecognized expression: " + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = "",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === "string" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t">": { dir: "parentNode", first: true },\n\t\t" ": { dir: "parentNode" },\n\t\t"+": { dir: "previousSibling", first: true },\n\t\t"~": { dir: "previousSibling" }\n\t},\n\n\tpreFilter: {\n\t\t"ATTR": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === "~=" ) {\n\t\t\t\tmatch[3] = " " + match[3] + " ";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t"CHILD": function( match ) {\n\t\t\t/* matches from matchExpr["CHILD"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === "nth" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t"PSEUDO": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr["CHILD"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || "";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t"TAG": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === "*" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t"CLASS": function( className ) {\n\t\t\tvar pattern = classCache[ className + " " ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );\n\t\t\t\t});\n\t\t},\n\n\t\t"ATTR": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === "!=";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += "";\n\n\t\t\t\treturn operator === "=" ? result === check :\n\t\t\t\t\toperator === "!=" ? result !== check :\n\t\t\t\t\toperator === "^=" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === "*=" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === "$=" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t"CHILD": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== "nth",\n\t\t\t\tforward = type.slice( -4 ) !== "last",\n\t\t\t\tofType = what === "of-type";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? "nextSibling" : "previousSibling",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven\'t yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === "only" && !start && "nextSibling";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t"PSEUDO": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( "unsupported pseudo: " + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, "", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t"not": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, "$1" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don\'t keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t"has": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t"contains": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// "Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element\'s language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by "-".\n\t\t// The matching of C against the element\'s language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name."\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t"lang": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || "") ) {\n\t\t\t\tSizzle.error( "unsupported lang: " + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t"target": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t"root": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t"focus": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t"enabled": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t"disabled": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t"checked": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);\n\t\t},\n\n\t\t"selected": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t"empty": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t"parent": function( elem ) {\n\t\t\treturn !Expr.pseudos["empty"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t"header": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t"input": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t"button": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === "input" && elem.type === "button" || name === "button";\n\t\t},\n\n\t\t"text": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === "input" &&\n\t\t\t\telem.type === "text" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"\n\t\t\t\t( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t"first": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t"last": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t"even": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"odd": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos["nth"] = Expr.pseudos["eq"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + " " ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don\'t consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, " " )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we\'re just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = "";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === "parentNode",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can\'t set arbitrary data on XML nodes, so they don\'t benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( (oldCache = uniqueCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we\'re done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[" "],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })\n\t\t\t\t\t).replace( rtrim, "$1" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = "0",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find["TAG"]( "*", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn\'t visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a "00" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + " " ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle\'s compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === "function" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split("").sort( sortOrder ).join("") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren\'t passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement("div") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property "interpolation"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = "<a href=\'#\'></a>";\n\treturn div.firstChild.getAttribute("href") === "#" ;\n}) ) {\n\taddHandle( "type|href|height|width", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute("value")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = "<input/>";\n\tdiv.firstChild.setAttribute( "value", "" );\n\treturn div.firstChild.getAttribute( "value" ) === "";\n}) ) {\n\taddHandle( "value", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === "input" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute("disabled") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[ ":" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = ( /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/ );\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\n\t}\n\n\tif ( typeof qualifier === "string" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t} );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = ":not(" + expr + ")";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== "string" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + " " + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $("p:first").is("p:last") won\'t return true for a doc with two "p".\n\t\t\ttypeof selector === "string" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(""), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === "string" ) {\n\t\t\tif ( selector[ 0 ] === "<" &&\n\t\t\t\tselector[ selector.length - 1 ] === ">" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && ( pos ?\n\t\t\t\t\tpos.index( cur ) > -1 :\n\n\t\t\t\t\t// Don\'t pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === "string" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, "parentNode" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "parentNode", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, "nextSibling" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, "previousSibling" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, "nextSibling" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, "previousSibling" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "nextSibling", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, "previousSibling", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== "Until" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === "string" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnotwhite = ( /\\S+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * "fired" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest "memorized"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === "string" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn\'t re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we\'re done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we\'re done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = "";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = "";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tlist = memory = "";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],\n\t\t\t\t[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],\n\t\t\t\t[ "notify", "progress", jQuery.Callbacks( "memory" ) ]\n\t\t\t],\n\t\t\tstate = "pending",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + "With" ](\n\t\t\t\t\t\t\t\t\t\tthis === promise ? newDefer.promise() : this,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add( function() {\n\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[ 0 ] + "With" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 ||\n\t\t\t\t( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) )\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we\'re not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n} );\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we\'re already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( "ready" );\n\t\t\tjQuery( document ).off( "ready" );\n\t\t}\n\t}\n} );\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( "DOMContentLoaded", completed );\n\twindow.removeEventListener( "load", completed );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called\n\t\t// after the browser event has already occurred.\n\t\t// Support: IE9-10 only\n\t\t// Older IE sometimes signals "interactive" too soon\n\t\tif ( document.readyState === "complete" ||\n\t\t\t( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {\n\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\twindow.setTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( "DOMContentLoaded", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( "load", completed );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it\'s a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === "object" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[ 0 ], key ) : emptyGet;\n};\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tregister: function( owner, initial ) {\n\t\tvar value = initial || {};\n\n\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t// use plain assignment\n\t\tif ( owner.nodeType ) {\n\t\t\towner[ this.expando ] = value;\n\n\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t// configurability must be true to allow the property to be\n\t\t// deleted with the delete operator\n\t\t} else {\n\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn owner[ this.expando ];\n\t},\n\tcache: function( owner ) {\n\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return an empty object.\n\t\tif ( !acceptData( owner ) ) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === "string" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\t\t\towner[ this.expando ] && owner[ this.expando ][ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the "read" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === "string" ) && value === undefined ) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase( key ) );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the "set" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.register( owner );\n\n\t\t} else {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If "name" is an array of keys...\n\t\t\t\t// When data is initially created, via ("key", "val") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there\'s no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <= 35-45+\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module\'s maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support "private" and "user" data.\n//\t4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === "string" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === "true" ? true :\n\t\t\t\t\tdata === "false" ? false :\n\t\t\t\t\tdata === "null" ? null :\n\n\t\t\t\t\t// Only convert to a number if it doesn\'t change the string\n\t\t\t\t\t+data + "" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn\'t changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( "data-" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, "hasDataAttrs", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === "object" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data, camelKey;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = dataUser.get( elem, key ) ||\n\n\t\t\t\t\t// Try to find dashed key if it exists (gh-2779)\n\t\t\t\t\t// This is for 2.2.x only\n\t\t\t\t\tdataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );\n\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = dataUser.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to "discover" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn\'t exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tcamelKey = jQuery.camelCase( key );\n\t\t\tthis.each( function() {\n\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might\'ve been store with a camelCased key.\n\t\t\t\tvar data = dataUser.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdataUser.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf( "-" ) > -1 && data !== undefined ) {\n\t\t\t\t\tdataUser.set( this, key, value );\n\t\t\t\t}\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || "fx" ) + "queue";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || "fx";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === "inprogress" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === "fx" ) {\n\t\t\t\tqueue.unshift( "inprogress" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + "queueHooks";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( "once memory" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + "queue", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tdata = type;\n\t\t\ttype = "fx";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === "fx" && queue[ 0 ] !== "inprogress" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || "fx", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || "fx";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + "queueHooks" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );\n\n\nvar cssExpand = [ "Top", "Right", "Bottom", "Left" ];\n\nvar isHidden = function( elem, el ) {\n\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, "display" ) === "none" ||\n\t\t\t!jQuery.contains( elem.ownerDocument, elem );\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted,\n\t\tscale = 1,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() { return tween.cur(); } :\n\t\t\tfunction() { return jQuery.css( elem, prop, "" ); },\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\tdo {\n\n\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t// Use string for doubling so we don\'t accidentally see scale as unchanged below\n\t\t\tscale = scale || ".5";\n\n\t\t\t// Adjust and apply\n\t\t\tinitialInUnit = initialInUnit / scale;\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t// Break the loop if scale is unchanged or perfect, or if we\'ve just had enough.\n\t\t} while (\n\t\t\tscale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations\n\t\t);\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([\\w:-]+)/ );\n\nvar rscriptType = ( /^$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE9\n\toption: [ 1, "<select multiple=\'multiple\'>", "</select>" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, "<table>", "</table>" ],\n\tcol: [ 2, "<table><colgroup>", "</colgroup></table>" ],\n\ttr: [ 2, "<table><tbody>", "</tbody></table>" ],\n\ttd: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],\n\n\t_default: [ 0, "", "" ]\n};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE9-11+\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret = typeof context.getElementsByTagName !== "undefined" ?\n\t\t\tcontext.getElementsByTagName( tag || "*" ) :\n\t\t\ttypeof context.querySelectorAll !== "undefined" ?\n\t\t\t\tcontext.querySelectorAll( tag || "*" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t"globalEval",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], "globalEval" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( jQuery.type( elem ) === "object" ) {\n\n\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( "div" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = "";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = "";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), "script" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || "" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( "div" ) ),\n\t\tinput = document.createElement( "input" );\n\n\t// Support: Android 4.0-4.3, Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( "type", "radio" );\n\tinput.setAttribute( "checked", "checked" );\n\tinput.setAttribute( "name", "t" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn\'t clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = "<textarea>x</textarea>";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE9\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === "object" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== "string" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === "string" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards\' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don\'t attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element\'s event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || "" ).match( rnotwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( "." )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we\'re the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element\'s handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || "" ).match( rnotwhite ) || [ "" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === "**" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it\'s no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, "handle events" );\n\t\t}\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Support (at least): Chrome, IE9\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t//\n\t\t// Support: Firefox<=42+\n\t\t// Avoid non-left-click in FF but don\'t block IE radio events (#3861, gh-2343)\n\t\tif ( delegateCount && cur.nodeType &&\n\t\t\t( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don\'t check non-elements (#13208)\n\t\t\t\t// Don\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don\'t conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + " ";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matches } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +\n\t\t"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: "char charCode key keyCode".split( " " ),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +\n\t\t\t"screenX screenY toElement" ).split( " " ),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX +\n\t\t\t\t\t( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -\n\t\t\t\t\t( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY +\n\t\t\t\t\t( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -\n\t\t\t\t\t( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don\'t use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn\'t\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusin"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: "focusout"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don\'t fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, "a" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn\'t alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This "if" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the \'new\' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn\'t have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://code.google.com/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: "mouseover",\n\tmouseleave: "mouseout",\n\tpointerenter: "pointerover",\n\tpointerleave: "pointerout"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + "." + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === "object" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === "function" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n\n\t// Support: IE 10-11, Edge 10240+\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked="checked" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, "table" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?\n\n\t\telem.getElementsByTagName( "tbody" )[ 0 ] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute( "type" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === "input" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === "input" || nodeName === "textarea" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tisFunction = jQuery.isFunction( value );\n\n\t// We can\'t cloneNode fragments that contain checked, in WebKit\n\tif ( isFunction ||\n\t\t\t( l > 1 && typeof value === "string" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( isFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, "script" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android<4.1, PhantomJS<2\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, "script" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || "" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, "globalEval" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won\'t run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, "script" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, "<$1></$2>" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, "script" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, "script" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove\'s overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\n\t// Keep domManip exposed until 3.0 (gh-2225)\n\tdomManip: domManip,\n\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = "";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === "string" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: "append",\n\tprependTo: "prepend",\n\tinsertBefore: "before",\n\tinsertAfter: "after",\n\treplaceAll: "replaceWith"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\n\n\nvar iframe,\n\telemdisplay = {\n\n\t\t// Support: Firefox\n\t\t// We have to pre-define these values for FF (#10227)\n\t\tHTML: "block",\n\t\tBODY: "block"\n\t};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\tdisplay = jQuery.css( elem[ 0 ], "display" );\n\n\t// We don\'t have any data stored on the element,\n\t// so use "detach" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === "none" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe || jQuery( "<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>" ) )\n\t\t\t\t.appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don\'t choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = ( /^margin/ );\n\nvar rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar documentElement = document.documentElement;\n\n\n\n( function() {\n\tvar pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( "div" ),\n\t\tdiv = document.createElement( "div" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = "content-box";\n\tdiv.cloneNode( true ).style.backgroundClip = "";\n\tsupport.clearCloneStyle = div.style.backgroundClip === "content-box";\n\n\tcontainer.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +\n\t\t"padding:0;margin-top:1px;position:absolute";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they\'re executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\t\tdiv.style.cssText =\n\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +\n\t\t\t"position:relative;display:block;" +\n\t\t\t"margin:auto;border:1px;padding:1px;" +\n\t\t\t"top:1%;width:50%";\n\t\tdiv.innerHTML = "";\n\t\tdocumentElement.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== "1%";\n\t\treliableMarginLeftVal = divStyle.marginLeft === "2px";\n\t\tboxSizingReliableVal = divStyle.width === "4px";\n\n\t\t// Support: Android 4.0 - 4.3 only\n\t\t// Some styles come back with percentage values, even though they shouldn\'t\n\t\tdiv.style.marginRight = "50%";\n\t\tpixelMarginRightVal = divStyle.marginRight === "4px";\n\n\t\tdocumentElement.removeChild( container );\n\t}\n\n\tjQuery.extend( support, {\n\t\tpixelPosition: function() {\n\n\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t// No need to check if the test was already performed, though.\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\tboxSizingReliable: function() {\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelMarginRight: function() {\n\n\t\t\t// Support: Android 4.0-4.3\n\t\t\t// We\'re checking for boxSizingReliableVal here instead of pixelMarginRightVal\n\t\t\t// since that compresses better and they\'re computed together anyway.\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelMarginRightVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\n\t\t\t// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\treliableMarginRight: function() {\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\tvar ret,\n\t\t\t\tmarginDiv = div.appendChild( document.createElement( "div" ) );\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t"-webkit-box-sizing:content-box;box-sizing:content-box;" +\n\t\t\t\t"display:block;margin:0;border:0;padding:0";\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = "0";\n\t\t\tdiv.style.width = "1px";\n\t\t\tdocumentElement.appendChild( container );\n\n\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );\n\n\t\t\tdocumentElement.removeChild( container );\n\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\treturn ret;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t// Support: Opera 12.1x only\n\t// Fall back to style even without computed\n\t// computed is undefined for elems on document fragments\n\tif ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\tret = jQuery.style( elem, name );\n\t}\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css(\'filter\') (#12537)\n\tif ( computed ) {\n\n\t\t// A tribute to the "awesome hack by Dean Edwards"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE9-11+\n\t\t// IE returns zIndex value as an integer.\n\t\tret + "" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we\'ll check on the first run if it\'s really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it\'s not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except "table", "table-cell", or "table-caption"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\n\tcssShow = { position: "absolute", visibility: "hidden", display: "block" },\n\tcssNormalTransform = {\n\t\tletterSpacing: "0",\n\t\tfontWeight: "400"\n\t},\n\n\tcssPrefixes = [ "Webkit", "O", "Moz", "ms" ],\n\temptyStyle = document.createElement( "div" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined "subtract", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? "border" : "content" ) ?\n\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === "width" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === "margin" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === "content" ) {\n\t\t\t\tval -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn\'t border nor margin, so remove border\n\t\t\tif ( extra !== "margin" ) {\n\t\t\t\tval -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t} else {\n\n\t\t\t// At this point, extra isn\'t content, so add padding\n\t\t\tval += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn\'t content nor padding, so add border\n\t\t\tif ( extra !== "padding" ) {\n\t\t\t\tval += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === "width" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test( val ) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize "", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? "border" : "content" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + "px";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = dataPriv.get( elem, "olddisplay" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === "none" ) {\n\t\t\t\telem.style.display = "";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === "" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = dataPriv.access(\n\t\t\t\t\telem,\n\t\t\t\t\t"olddisplay",\n\t\t\t\t\tdefaultDisplay( elem.nodeName )\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== "none" || !hidden ) {\n\t\t\t\tdataPriv.set(\n\t\t\t\t\telem,\n\t\t\t\t\t"olddisplay",\n\t\t\t\t\thidden ? display : jQuery.css( elem, "display" )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === "none" || elem.style.display === "" ) {\n\t\t\telem.style.display = show ? values[ index ] || "" : "none";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, "opacity" );\n\t\t\t\t\treturn ret === "" ? "1" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don\'t automatically add "px" to these possibly-unitless properties\n\tcssNumber: {\n\t\t"animationIterationCount": true,\n\t\t"columnCount": true,\n\t\t"fillOpacity": true,\n\t\t"flexGrow": true,\n\t\t"flexShrink": true,\n\t\t"fontWeight": true,\n\t\t"lineHeight": true,\n\t\t"opacity": true,\n\t\t"order": true,\n\t\t"orphans": true,\n\t\t"widows": true,\n\t\t"zIndex": true,\n\t\t"zoom": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t"float": "cssFloat"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don\'t set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we\'re working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we\'re setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert "+=" or "-=" to relative numbers (#7345)\n\t\t\tif ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = "number";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren\'t set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === "number" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone\'s values\n\t\t\tif ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {\n\t\t\t\tstyle[ name ] = "inherit";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( "set" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && "get" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we\'re working with the right name\n\t\tname = jQuery.cssProps[ origName ] ||\n\t\t\t( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && "get" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert "normal" to computed value\n\t\tif ( val === "normal" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === "" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ "height", "width" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, "display" ) ) &&\n\t\t\t\t\telem.offsetWidth === 0 ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = extra && getStyles( elem ),\n\t\t\t\tsubtract = extra && augmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, "boxSizing", false, styles ) === "border-box",\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || "px" ) !== "px" ) {\n\n\t\t\t\telem.style[ name ] = value;\n\t\t\t\tvalue = jQuery.css( elem, name );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, "marginLeft" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + "px";\n\t\t}\n\t}\n);\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn swap( elem, { "display": "inline-block" },\n\t\t\t\tcurCSS, [ elem, "marginRight" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: "",\n\tpadding: "",\n\tborder: "Width"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === "string" ? value.split( " " ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === "boolean" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as "10px" are parsed to Float;\n\t\t\t// complex values such as "rotate(1rad)" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, "" );\n\n\t\t\t// Empty strings, null, undefined and "auto" are converted to 0.\n\t\t\treturn !result || result === "auto" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: "swing"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ "margin" + which ] = attrs[ "padding" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We\'re done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = dataPriv.get( elem, "fxshow" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, "fx" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, "fx" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {\n\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, "display" );\n\n\t\t// Test default display if display is currently "none"\n\t\tcheckDisplay = display === "none" ?\n\t\t\tdataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {\n\t\t\tstyle.display = "inline-block";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = "hidden";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === "toggle";\n\t\t\tif ( value === ( hidden ? "hide" : "show" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show\n\t\t\t\t// and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( "hidden" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = dataPriv.access( elem, "fxshow", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to "reverse"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done( function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t} );\n\t\t}\n\t\tanim.done( function() {\n\t\t\tvar prop;\n\n\t\t\tdataPriv.remove( elem, "fxshow" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t} );\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === "width" || prop === "height" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && "expand" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won\'t overwrite existing keys.\n\t\t\t// Reusing \'index\' because we have the correct "name"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don\'t match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( jQuery.isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tjQuery.proxy( result.stop, result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\ttweeners: {\n\t\t"*": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ "*" ];\n\t\t} else {\n\t\t\tprops = props.match( rnotwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?\n\t\topt.duration : opt.duration in jQuery.fx.speeds ?\n\t\t\tjQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> "fx"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = "fx";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( "opacity", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won\'t be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, "finish" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== "string" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || "fx", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + "queueHooks",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn\'t forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || "fx";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + "queue" ],\n\t\t\t\thooks = data[ type + "queueHooks" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === "boolean" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( "show" ),\n\tslideUp: genFx( "hide" ),\n\tslideToggle: genFx( "toggle" ),\n\tfadeIn: { opacity: "show" },\n\tfadeOut: { opacity: "hide" },\n\tfadeToggle: { opacity: "toggle" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\twindow.clearInterval( timerId );\n\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || "fx";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( "input" ),\n\t\tselect = document.createElement( "select" ),\n\t\topt = select.appendChild( document.createElement( "option" ) );\n\n\tinput.type = "checkbox";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be "on"\n\tsupport.checkOn = input.value !== "";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( "input" );\n\tinput.value = "t";\n\tinput.type = "radio";\n\tsupport.radioValue = input.value === "t";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === "undefined" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + "" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === "radio" &&\n\t\t\t\t\tjQuery.nodeName( elem, "input" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( "type", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don\'t get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && "set" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// elem.tabIndex doesn\'t always return the\n\t\t\t\t// correct value when it hasn\'t been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, "tabindex" );\n\n\t\t\t\treturn tabindex ?\n\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\t\trclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t\t0 :\n\t\t\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t"for": "htmlFor",\n\t\t"class": "className"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t"tabIndex",\n\t"readOnly",\n\t"maxLength",\n\t"cellSpacing",\n\t"cellPadding",\n\t"rowSpan",\n\t"colSpan",\n\t"useMap",\n\t"frameBorder",\n\t"contentEditable"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( "class" ) || "";\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( " " + curValue + " " ).replace( rclass, " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( " " + clazz + " " ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + " ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( "class", "" );\n\t\t}\n\n\t\tif ( typeof value === "string" && value ) {\n\t\t\tclasses = value.match( rnotwhite ) || [];\n\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 &&\n\t\t\t\t\t( " " + curValue + " " ).replace( rclass, " " );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( " " + clazz + " " ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( " " + clazz + " ", " " );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( "class", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === "boolean" && type === "string" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( type === "string" ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === "boolean" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, "__className__", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we\'re passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( "class",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t"" :\n\t\t\t\t\t\tdataPriv.get( this, "__className__" ) || ""\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = " " + selector + " ";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( " " + getClass( elem ) + " " ).replace( rclass, " " )\n\t\t\t\t\t.indexOf( className ) > -1\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g,\n\trspaces = /[\\x20\\t\\r\\n\\f]+/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t"get" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, "value" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === "string" ?\n\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace( rreturn, "" ) :\n\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? "" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as ""; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = "";\n\n\t\t\t} else if ( typeof val === "number" ) {\n\t\t\t\tval += "";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? "" : value + "";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, "value" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === "select-one" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE8-9 doesn\'t update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don\'t return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ?\n\t\t\t\t\t\t\t\t!option.disabled : option.getAttribute( "disabled" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don\'t need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ "radio", "checkbox" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( "value" ) === null ? "on" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, "type" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don\'t do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we\'re not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( "." ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( "." );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( ":" ) < 0 && "on" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === "object" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( "." );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( "(^|\\\\.)" + namespaces.join( "\\\\.(?:.*\\\\.|)" ) + "(\\\\.|$)" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, "handle" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don\'t do default actions on window, that\'s where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don\'t re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\njQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +\n\t"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +\n\t"change select submit keydown keypress keyup error contextmenu" ).split( " " ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\nsupport.focusin = "onfocusin" in window;\n\n\n// Support: Firefox\n// Firefox doesn\'t have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome, Safari\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = jQuery.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + "" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {\n\t\tjQuery.error( "Invalid XML: " + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol "*" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to "*" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol "*" can be used\n\t * 3) selection will start with transport dataType and THEN go to "*" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = "*/".concat( "*" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( "a" );\n\toriginAnchor.href = location.href;\n\n// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to "*"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== "string" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = "*";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === "+" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || "*";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === "string" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );\n}\n\n// A special extend for ajax options\n// that takes "flat" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === "*" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );\n\t\t}\n\t}\n\n\t// Check if we\'re dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There\'s only work to do if current dataType is non-auto\n\t\t\tif ( current === "*" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== "*" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + " " + current ] || converters[ "* " + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( " " );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + " " + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ "* " + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: "parsererror",\n\t\t\t\t\t\t\t\terror: conv ? e : "No conversion from " + prev + " to " + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: "success", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: "GET",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: "application/x-www-form-urlencoded; charset=UTF-8",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t"*": allTypes,\n\t\t\ttext: "text/plain",\n\t\t\thtml: "text/html",\n\t\t\txml: "application/xml, text/xml",\n\t\t\tjson: "application/json, text/javascript"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: "responseXML",\n\t\t\ttext: "responseText",\n\t\t\tjson: "responseJSON"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall "*") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t"* text": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t"text html": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t"text json": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t"text xml": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn\'t be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn\'t be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === "object" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( "once memory" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = "canceled",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )\n\t\t\t.replace( rprotocol, location.protocol + "//" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];\n\n\t\t// A cross-domain request is in order when the origin doesn\'t match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( "a" );\n\n\t\t\t// Support: IE8-11+\n\t\t\t// IE throws exception if url is malformed, e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE8-11+\n\t\t\t\t// Anchor\'s host property isn\'t correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + "//" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== "string" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( "ajaxStart" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we\'re toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );\n\n\t\t\t\t// #9682: remove data so that it\'s not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a \'_\' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, "$1_=" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( "Content-Type", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t"Accept",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :\n\t\t\t\ts.accepts[ "*" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = "abort";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, "No Transport" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( "timeout" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is "done" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || "";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "Last-Modified" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( "etag" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === "HEAD" ) {\n\t\t\t\t\tstatusText = "nocontent";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = "notmodified";\n\n\t\t\t\t// If we have data, let\'s convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = "error";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + "";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( "ajaxStop" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, "json" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, "script" );\n\t}\n} );\n\njQuery.each( [ "get", "post" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: "GET",\n\t\tdataType: "script",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t"throws": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each( function() {\n\t\t\tif ( !jQuery.nodeName( this, "body" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t} ).end();\n\t}\n} );\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\treturn !jQuery.expr.filters.visible( elem );\n};\njQuery.expr.filters.visible = function( elem ) {\n\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t// Use OR instead of AND as the element is not visible if either is true\n\t// See tickets #10406 and #13132\n\treturn elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && jQuery.type( obj ) === "object" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the "old" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( "&" ).replace( r20, "+" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for "elements" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, "elements" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( ":disabled" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( ":disabled" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t\t\t\t} ) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, "\\r\\n" ) };\n\t\t} ).get();\n\t}\n} );\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won\'t change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {\n\t\t\t\t\theaders[ "X-Requested-With" ] = "XMLHttpRequest";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === "abort" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === "error" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== "number" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, "error" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || "text" ) !== "text"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== "string" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = callback( "error" );\n\n\t\t\t\t// Support: IE9\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( "abort" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn\'t been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: "text/javascript, application/javascript, " +\n\t\t\t"application/ecmascript, application/x-ecmascript"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t"text script": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache\'s special case and crossDomain\njQuery.ajaxPrefilter( "script", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = "GET";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( "script", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( "<script>" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t"load error",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === "error" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: "callback",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t"url" :\n\t\t\ttypeof s.data === "string" &&\n\t\t\t\t( s.contentType || "" )\n\t\t\t\t\t.indexOf( "application/x-www-form-urlencoded" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && "data"\n\t\t);\n\n\t// Handle iff the expected data type is "jsonp" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ "script json" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + " was not called" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = "json";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn\'t exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn\'t screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn "script";\n\t}\n} );\n\n\n\n\n// Argument "data" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== "string" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === "boolean" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== "string" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( " " );\n\n\tif ( off > -1 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it\'s a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it\'s the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === "object" ) {\n\t\ttype = "POST";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If "type" variable is undefined, then "GET" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || "GET",\n\t\t\tdataType: "html",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE \'Permission Denied\' errors\n\t\t\t\tjQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets "data", "status", "jqXHR"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets "jqXHR", "status", "error"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t"ajaxStart",\n\t"ajaxStop",\n\t"ajaxComplete",\n\t"ajaxError",\n\t"ajaxSuccess",\n\t"ajaxSend"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, "position" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === "static" ) {\n\t\t\telem.style.position = "relative";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, "top" );\n\t\tcurCSSLeft = jQuery.css( elem, "left" );\n\t\tcalculatePosition = ( position === "absolute" || position === "fixed" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( "using" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it\'s not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\tbox = elem.getBoundingClientRect();\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n\t\t// because it is its only offset parent\n\t\tif ( jQuery.css( elem, "position" ) === "fixed" ) {\n\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {\n\tvar top = "pageYOffset" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari<7-8+, Chrome<37-44+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ "top", "left" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + "px" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: "height", Width: "width" }, function( name, type ) {\n\tjQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn\'t a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ "client" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ "scroll" + name ], doc[ "scroll" + name ],\n\t\t\t\t\t\telem.body[ "offset" + name ], doc[ "offset" + name ],\n\t\t\t\t\t\tdoc[ "client" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t} );\n} );\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, "**" ) :\n\t\t\tthis.off( types, selector || "**", fn );\n\t},\n\tsize: function() {\n\t\treturn this.length;\n\t}\n} );\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\nreturn jQuery;\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz8yN2Q5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxvRkFBb0Y7O0FBRXBGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQix5QkFBeUIsd0JBQXdCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQixFQUFFO0FBQ3JDLGVBQWUscUNBQXFDLEVBQUU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQXdEO0FBQy9FOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9DQUFvQztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTixNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkIsNERBQTRELGVBQWU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7O0FBSUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4yLjRcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0wNS0yMFQxNzoyM1pcbiAqL1xuXG4oZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDE4K1xuLy8gQ2FuJ3QgYmUgaW4gc3RyaWN0IG1vZGUsIHNldmVyYWwgbGlicyBpbmNsdWRpbmcgQVNQLk5FVCB0cmFjZVxuLy8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXG4vL1widXNlIHN0cmljdFwiO1xudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjIuMi40XCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcblxuXHQvLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcblx0cm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcblxuXHQvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxuXHRzZWxlY3RvcjogXCJcIixcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0cmV0dXJuIG51bSAhPSBudWxsID9cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0KCBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdICkgOlxuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXHRcdHJldC5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSApIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc0Z1bmN0aW9uOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBqUXVlcnkudHlwZSggb2JqICkgPT09IFwiZnVuY3Rpb25cIjtcblx0fSxcblxuXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH0sXG5cblx0aXNOdW1lcmljOiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcblx0XHR2YXIgcmVhbFN0cmluZ09iaiA9IG9iaiAmJiBvYmoudG9TdHJpbmcoKTtcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0FycmF5KCBvYmogKSAmJiAoIHJlYWxTdHJpbmdPYmogLSBwYXJzZUZsb2F0KCByZWFsU3RyaW5nT2JqICkgKyAxICkgPj0gMDtcblx0fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBOb3QgcGxhaW4gb2JqZWN0czpcblx0XHQvLyAtIEFueSBvYmplY3Qgb3IgdmFsdWUgd2hvc2UgaW50ZXJuYWwgW1tDbGFzc11dIHByb3BlcnR5IGlzIG5vdCBcIltvYmplY3QgT2JqZWN0XVwiXG5cdFx0Ly8gLSBET00gbm9kZXNcblx0XHQvLyAtIHdpbmRvd1xuXHRcdGlmICggalF1ZXJ5LnR5cGUoIG9iaiApICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0XHRpZiAoIG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHQhaGFzT3duLmNhbGwoIG9iaiwgXCJjb25zdHJ1Y3RvclwiICkgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlIHx8IHt9LCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHRcdC8vIGlmIGxhc3Qgb25lIGlzIG93biwgdGhlbiBhbGwgcHJvcGVydGllcyBhcmUgb3duXG5cdFx0Zm9yICgga2V5IGluIG9iaiApIHt9XG5cblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwoIG9iaiwga2V5ICk7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHZhciBzY3JpcHQsXG5cdFx0XHRpbmRpcmVjdCA9IGV2YWw7XG5cblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcblxuXHRcdGlmICggY29kZSApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIGNvZGUgaW5jbHVkZXMgYSB2YWxpZCwgcHJvbG9ndWUgcG9zaXRpb25cblx0XHRcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXG5cdFx0XHQvLyBzY3JpcHQgdGFnIGludG8gdGhlIGRvY3VtZW50LlxuXHRcdFx0aWYgKCBjb2RlLmluZGV4T2YoIFwidXNlIHN0cmljdFwiICkgPT09IDEgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblx0XHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxuXHRcdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxuXG5cdFx0XHRcdGluZGlyZWN0KCBjb2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcblx0fSxcblxuXHRub2RlTmFtZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHRcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0XHRjb250ZXh0ID0gZm47XG5cdFx0XHRmbiA9IHRtcDtcblx0XHR9XG5cblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHRcdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH0sXG5cblx0bm93OiBEYXRlLm5vdyxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG4vLyBKU0hpbnQgd291bGQgZXJyb3Igb24gdGhpcyBjb2RlIGR1ZSB0byB0aGUgU3ltYm9sIG5vdCBiZWluZyBkZWZpbmVkIGluIEVTNS5cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5qc2hpbnRyYyB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGp1c3QgZGlzYWJsZSBKU0hpbnQgZm9yIHRoZXNlXG4vLyB0aHJlZSBsaW5lcy5cbi8qIGpzaGludCBpZ25vcmU6IHN0YXJ0ICovXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG4vKiBqc2hpbnQgaWdub3JlOiBlbmQgKi9cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cblx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4xXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE1LTEwLTE3XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXG5cdE1BWF9ORUdBVElWRSA9IDEgPDwgMzEsXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXG5cdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblx0cmVzY2FwZSA9IC8nfFxcXFwvZyxcblxuXHQvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH07XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbmlkc2VsZWN0LCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHRuaWRzZWxlY3QgPSByaWRlbnRpZmllci50ZXN0KCBuaWQgKSA/IFwiI1wiICsgbmlkIDogXCJbaWQ9J1wiICsgbmlkICsgXCInXVwiO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gbmlkc2VsZWN0ICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBkaXYgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xuXHRcdFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGRpdiApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGRpdiA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHQoIH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApIC1cblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHBhcmVudCxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggKHBhcmVudCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBwYXJlbnQudG9wICE9PSBwYXJlbnQgKSB7XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTFcblx0XHRpZiAoIHBhcmVudC5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHBhcmVudC5hdHRhY2hFdmVudCApIHtcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIG0gPyBbIG0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdC8vIFN1cHBvcnQ6IElFNi83XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdGRlbGV0ZSBFeHByLmZpbmRbXCJJRFwiXTtcblxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBkaXYgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBkaXYsIFwiZGl2XCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBkaXYsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGVsZW0uaW5uZXJUZXh0IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcblx0XHR9LFxuXG5cdFx0XCJkaXNhYmxlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBkaXIgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdHN1cHBvcnQuZ2V0QnlJZCAmJiBjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZGl2MSApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbXFx3LV0rKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyApO1xuXG5cblxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblxuXHR9XG5cblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xuXHRcdGlmICggcmlzU2ltcGxlLnRlc3QoIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xuXHRcdH1cblxuXHRcdHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMgKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdH0gKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdIDpcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlKCByZXQgKSA6IHJldCApO1xuXHRcdHJldC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBzZWxlY3RvciA6IHNlbGVjdG9yO1xuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEJsYWNrYmVycnkgNC42XG5cdFx0XHRcdFx0Ly8gZ0VCSUQgcmV0dXJucyBub2RlcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICgjNjk2Mylcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSB0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3Iuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3Rvcjtcblx0XHRcdHRoaXMuY29udGV4dCA9IHNlbGVjdG9yLmNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRwb3MgPSBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApIHx8IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggcG9zID9cblx0XHRcdFx0XHRwb3MuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90d2hpdGUgPSAoIC9cXFMrL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgalF1ZXJ5LnR5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZWplY3RlZFwiIF0sXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICkgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0cHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG5cdFx0XHQvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxuXHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cblx0XHRcdFx0Ly8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xuXHRcdFx0XHR9LCB0dXBsZXNbIGkgXiAxIF1bIDIgXS5kaXNhYmxlLCB0dXBsZXNbIDIgXVsgMiBdLmxvY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmZXJyZWRbIHJlc29sdmUgfCByZWplY3QgfCBub3RpZnkgXVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cblx0XHRcdC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fFxuXHRcdFx0XHQoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuXG5cdFx0XHQvLyBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cblx0XHRcdGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpLCBjb250ZXh0cywgdmFsdWVzICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG5cdFx0Ly8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuXHRcdGlmICggbGVuZ3RoID4gMSApIHtcblx0XHRcdHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5mYWlsKCBkZWZlcnJlZC5yZWplY3QgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdDtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdC8vIEFkZCB0aGUgY2FsbGJhY2tcblx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKCBmbiApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxuXHRob2xkUmVhZHk6IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblxuXHRcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xuXHRcdGlmICggalF1ZXJ5LmZuLnRyaWdnZXJIYW5kbGVyICkge1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS5vZmYoIFwicmVhZHlcIiApO1xuXHRcdH1cblx0fVxufSApO1xuXG4vKipcbiAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxualF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiggb2JqICkge1xuXHRpZiAoICFyZWFkeUxpc3QgKSB7XG5cblx0XHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRcdC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG5cdFx0Ly8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdFx0Ly8gU3VwcG9ydDogSUU5LTEwIG9ubHlcblx0XHQvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cblx0XHRpZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHRcdFx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0XHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdFx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlYWR5TGlzdC5wcm9taXNlKCBvYmogKTtcbn07XG5cbi8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxualF1ZXJ5LnJlYWR5LnByb21pc2UoKTtcblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCBqUXVlcnkudHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNoYWluYWJsZSA/XG5cdFx0ZWxlbXMgOlxuXG5cdFx0Ly8gR2V0c1xuXHRcdGJ1bGsgP1xuXHRcdFx0Zm4uY2FsbCggZWxlbXMgKSA6XG5cdFx0XHRsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0LyoganNoaW50IC1XMDE4ICovXG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRyZWdpc3RlcjogZnVuY3Rpb24oIG93bmVyLCBpbml0aWFsICkge1xuXHRcdHZhciB2YWx1ZSA9IGluaXRpYWwgfHwge307XG5cblx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxuXHRcdC8vIGNvbmZpZ3VyYWJpbGl0eSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0Ly8gZGVsZXRlZCB3aXRoIHRoZSBkZWxldGUgb3BlcmF0b3Jcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHR9LFxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRpZiAoICFhY2NlcHREYXRhKCBvd25lciApICkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGRhdGEgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgcHJvcCBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsga2V5IF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBzdG9yZWQ7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cblx0XHRcdHJldHVybiBzdG9yZWQgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMucmVnaXN0ZXIoIG93bmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgXCJuYW1lXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxuXHRcdFx0XHQvLyBrZXlzIHdpbGwgYmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZS5cblx0XHRcdFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgb25seSBwZW5hbGl6ZSB0aGUgYXJyYXkgYXJndW1lbnQgcGF0aC5cblx0XHRcdFx0bmFtZSA9IGtleS5jb25jYXQoIGtleS5tYXAoIGpRdWVyeS5jYW1lbENhc2UgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FtZWwgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxuXHRcdFx0XHRpZiAoIGtleSBpbiBjYWNoZSApIHtcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRuYW1lID0gY2FtZWw7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFx0WyBuYW1lIF0gOiAoIG5hbWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aSA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBuYW1lWyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwN1xuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XG5cblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRcdFx0XHRcdCtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDpcblx0XHRcdFx0XHRyYnJhY2UudGVzdCggZGF0YSApID8galF1ZXJ5LnBhcnNlSlNPTiggZGF0YSApIDpcblx0XHRcdFx0XHRkYXRhO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YSwgY2FtZWxLZXk7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBhcy1pc1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKSB8fFxuXG5cdFx0XHRcdFx0Ly8gVHJ5IHRvIGZpbmQgZGFzaGVkIGtleSBpZiBpdCBleGlzdHMgKGdoLTI3NzkpXG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBmb3IgMi4yLnggb25seVxuXHRcdFx0XHRcdGRhdGFVc2VyLmdldCggZWxlbSwga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpICk7XG5cblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGNhbWVsaXplZFxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gRmlyc3QsIGF0dGVtcHQgdG8gc3RvcmUgYSBjb3B5IG9yIHJlZmVyZW5jZSBvZiBhbnlcblx0XHRcdFx0Ly8gZGF0YSB0aGF0IG1pZ2h0J3ZlIGJlZW4gc3RvcmUgd2l0aCBhIGNhbWVsQ2FzZWQga2V5LlxuXHRcdFx0XHR2YXIgZGF0YSA9IGRhdGFVc2VyLmdldCggdGhpcywgY2FtZWxLZXkgKTtcblxuXHRcdFx0XHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXG5cdFx0XHRcdC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xuXG5cdFx0XHRcdC8vICouLi4gSW4gdGhlIGNhc2Ugb2YgcHJvcGVydGllcyB0aGF0IG1pZ2h0IF9hY3R1YWxseV9cblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxuXHRcdFx0XHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXG5cdFx0XHRcdGlmICgga2V5LmluZGV4T2YoIFwiLVwiICkgPiAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBqUXVlcnkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW4gPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0IWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsXG5cdFx0c2NhbGUgPSAxLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHR3ZWVuLmN1cigpOyB9IDpcblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApOyB9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHRkbyB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxuXHRcdFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcblx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xuXG5cdFx0XHQvLyBBZGp1c3QgYW5kIGFwcGx5XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKClcblx0XHQvLyBCcmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoLlxuXHRcdH0gd2hpbGUgKFxuXHRcdFx0c2NhbGUgIT09ICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgKSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbXFx3Oi1dKykvICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQgPSB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHR0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XG5cdFx0XHRbXTtcblxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xuXHRcdGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApIDpcblx0XHRyZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIGpRdWVyeS50eXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAtNC4zLCBTYWZhcmk8PTUuMVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjEsIEFuZHJvaWQ8NC4yXG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2Uocylcblx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIFN1cHBvcnQgKGF0IGxlYXN0KTogQ2hyb21lLCBJRTlcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKCMxMzE4MClcblx0XHQvL1xuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8PTQyK1xuXHRcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGluIEZGIGJ1dCBkb24ndCBibG9jayBJRSByYWRpbyBldmVudHMgKCMzODYxLCBnaC0yMzQzKVxuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiZcblx0XHRcdCggZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiIHx8IGlzTmFOKCBldmVudC5idXR0b24gKSB8fCBldmVudC5idXR0b24gPCAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogdGhpcywgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0Ly8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcblx0cHJvcHM6ICggXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBcIiArXG5cdFx0XCJtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIgKS5zcGxpdCggXCIgXCIgKSxcblxuXHRmaXhIb29rczoge30sXG5cblx0a2V5SG9va3M6IHtcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdG1vdXNlSG9va3M6IHtcblx0XHRwcm9wczogKCBcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgXCIgK1xuXHRcdFx0XCJzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cdFx0XHR2YXIgZXZlbnREb2MsIGRvYywgYm9keSxcblx0XHRcdFx0YnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xuXG5cdFx0XHQvLyBDYWxjdWxhdGUgcGFnZVgvWSBpZiBtaXNzaW5nIGFuZCBjbGllbnRYL1kgYXZhaWxhYmxlXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsICkge1xuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuXHRcdFx0XHRkb2MgPSBldmVudERvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHRcdGJvZHkgPSBldmVudERvYy5ib2R5O1xuXG5cdFx0XHRcdGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwICk7XG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLnNjcm9sbFRvcCAgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCAgfHwgMCApIC1cblx0XHRcdFx0XHQoIGRvYyAmJiBkb2MuY2xpZW50VG9wICB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wICB8fCAwICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZXZlbnQud2hpY2ggPSAoIGJ1dHRvbiAmIDEgPyAxIDogKCBidXR0b24gJiAyID8gMyA6ICggYnV0dG9uICYgNCA/IDIgOiAwICkgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGEgd3JpdGFibGUgY29weSBvZiB0aGUgZXZlbnQgb2JqZWN0IGFuZCBub3JtYWxpemUgc29tZSBwcm9wZXJ0aWVzXG5cdFx0dmFyIGksIHByb3AsIGNvcHksXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcblx0XHRcdG9yaWdpbmFsRXZlbnQgPSBldmVudCxcblx0XHRcdGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzWyB0eXBlIF07XG5cblx0XHRpZiAoICFmaXhIb29rICkge1xuXHRcdFx0dGhpcy5maXhIb29rc1sgdHlwZSBdID0gZml4SG9vayA9XG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XG5cdFx0XHRcdHJrZXlFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLmtleUhvb2tzIDpcblx0XHRcdFx0e307XG5cdFx0fVxuXHRcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoIGZpeEhvb2sucHJvcHMgKSA6IHRoaXMucHJvcHM7XG5cblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblxuXHRcdGkgPSBjb3B5Lmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHByb3AgPSBjb3B5WyBpIF07XG5cdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ2luYWxFdmVudFsgcHJvcCBdO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IENvcmRvdmEgMi41IChXZWJLaXQpICgjMTMyNTUpXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCssIENocm9tZTwyOFxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0aWYgKCBldmVudC50YXJnZXQubm9kZVR5cGUgPT09IDMgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6LV0rKVtePl0qKVxcLz4vZ2ksXG5cblx0Ly8gU3VwcG9ydDogSUUgMTAtMTEsIEVkZ2UgMTAyNDArXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0alF1ZXJ5Lm5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApID9cblxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidGJvZHlcIiApWyAwIF0gfHxcblx0XHRcdGVsZW0uYXBwZW5kQ2hpbGQoIGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRib2R5XCIgKSApIDpcblx0XHRlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcblxuXHRpZiAoIG1hdGNoICkge1xuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggaXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIEtlZXAgZG9tTWFuaXAgZXhwb3NlZCB1bnRpbCAzLjAgKGdoLTIyMjUpXG5cdGRvbU1hbmlwOiBkb21NYW5pcCxcblxuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG5cblxudmFyIGlmcmFtZSxcblx0ZWxlbWRpc3BsYXkgPSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94XG5cdFx0Ly8gV2UgaGF2ZSB0byBwcmUtZGVmaW5lIHRoZXNlIHZhbHVlcyBmb3IgRkYgKCMxMDIyNylcblx0XHRIVE1MOiBcImJsb2NrXCIsXG5cdFx0Qk9EWTogXCJibG9ja1wiXG5cdH07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XG4gKi9cblxuLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcbmZ1bmN0aW9uIGFjdHVhbERpc3BsYXkoIG5hbWUsIGRvYyApIHtcblx0dmFyIGVsZW0gPSBqUXVlcnkoIGRvYy5jcmVhdGVFbGVtZW50KCBuYW1lICkgKS5hcHBlbmRUbyggZG9jLmJvZHkgKSxcblxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XG5cblx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XG5cdGVsZW0uZGV0YWNoKCk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBkaXNwbGF5IHZhbHVlIG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICovXG5mdW5jdGlvbiBkZWZhdWx0RGlzcGxheSggbm9kZU5hbWUgKSB7XG5cdHZhciBkb2MgPSBkb2N1bWVudCxcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XG5cblx0aWYgKCAhZGlzcGxheSApIHtcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXG5cdFx0Ly8gSWYgdGhlIHNpbXBsZSB3YXkgZmFpbHMsIHJlYWQgZnJvbSBpbnNpZGUgYW4gaWZyYW1lXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcblxuXHRcdFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXG5cdFx0XHRpZnJhbWUgPSAoIGlmcmFtZSB8fCBqUXVlcnkoIFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiICkgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFXG5cdFx0XHRkb2Mud3JpdGUoKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xuXHRcdFx0aWZyYW1lLmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBjb3JyZWN0IGRlZmF1bHQgZGlzcGxheVxuXHRcdGVsZW1kaXNwbGF5WyBub2RlTmFtZSBdID0gZGlzcGxheTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5O1xufVxudmFyIHJtYXJnaW4gPSAoIC9ebWFyZ2luLyApO1xuXG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHBpeGVsTWFyZ2luUmlnaHRWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O1wiICtcblx0XHRcInBhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiO1xuXHRjb250YWluZXIuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O1wiICtcblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ0b3A6MSU7d2lkdGg6NTAlXCI7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gZGl2U3R5bGUubWFyZ2luTGVmdCA9PT0gXCIycHhcIjtcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcIjRweFwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IFwiNTAlXCI7XG5cdFx0cGl4ZWxNYXJnaW5SaWdodFZhbCA9IGRpdlN0eWxlLm1hcmdpblJpZ2h0ID09PSBcIjRweFwiO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXG5cdFx0XHQvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxuXHRcdFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjNcblx0XHRcdC8vIFdlJ3JlIGNoZWNraW5nIGZvciBib3hTaXppbmdSZWxpYWJsZVZhbCBoZXJlIGluc3RlYWQgb2YgcGl4ZWxNYXJnaW5SaWdodFZhbFxuXHRcdFx0Ly8gc2luY2UgdGhhdCBjb21wcmVzc2VzIGJldHRlciBhbmQgdGhleSdyZSBjb21wdXRlZCB0b2dldGhlciBhbnl3YXkuXG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGl4ZWxNYXJnaW5SaWdodFZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCBvbmx5LCBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDM3XG5cdFx0XHRpZiAoIGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XG5cdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuICgjMzMzMylcblx0XHRcdC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxuXHRcdFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0bWFyZ2luRGl2ID0gZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xuXHRcdFx0bWFyZ2luRGl2LnN0eWxlLmNzc1RleHQgPSBkaXYuc3R5bGUuY3NzVGV4dCA9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXG5cdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7XCIgK1xuXHRcdFx0XHRcImRpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcblx0XHRcdGRpdi5zdHlsZS53aWR0aCA9IFwiMXB4XCI7XG5cdFx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiApLm1hcmdpblJpZ2h0ICk7XG5cblx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cdFx0XHRkaXYucmVtb3ZlQ2hpbGQoIG1hcmdpbkRpdiApO1xuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblx0cmV0ID0gY29tcHV0ZWQgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXSA6IHVuZGVmaW5lZDtcblxuXHQvLyBTdXBwb3J0OiBPcGVyYSAxMi4xeCBvbmx5XG5cdC8vIEZhbGwgYmFjayB0byBzdHlsZSBldmVuIHdpdGhvdXQgY29tcHV0ZWRcblx0Ly8gY29tcHV0ZWQgaXMgdW5kZWZpbmVkIGZvciBlbGVtcyBvbiBkb2N1bWVudCBmcmFnbWVudHNcblx0aWYgKCAoIHJldCA9PT0gXCJcIiB8fCByZXQgPT09IHVuZGVmaW5lZCApICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpICgjMTI1MzcpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxuXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcblx0Ly8gTWF0aE1MIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDkxNjY4XG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3Nhcnlcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdGlmICggdmFsIDwgMCB8fCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgbmFtZSBdICk7XG5cblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblx0fVxuXG5cdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXG5cdHJldHVybiAoIHZhbCArXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0bmFtZSxcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXNcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sIGhpZGRlbixcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3Rcblx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcblx0XHRcdC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmFjY2Vzcyhcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGlkZGVuID0gaXNIaWRkZW4oIGVsZW0gKTtcblxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1sgaW5kZXggXSB8fCBcIlwiIDogXCJub25lXCI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge1xuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXG5cdH0sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblx0XHRcdFx0XHRlbGVtLm9mZnNldFdpZHRoID09PSAwID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZXh0cmEgJiYgZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYXVnbWVudFdpZHRoT3JIZWlnaHQoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdCk7XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxuXHRcdFx0XHRjdXJDU1MsIFsgZWxlbSwgXCJtYXJnaW5SaWdodFwiIF0gKTtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggIXJtYXJnaW4udGVzdCggcHJlZml4ICkgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFOVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIHRpbWVySWQsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IGpRdWVyeS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0IDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbiggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gSGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBIZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xuXHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcyApICkge1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XG5cdFx0Ly8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXG5cdFx0Ly8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcblx0XHRjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XG5cdFx0XHRkYXRhUHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICkgfHwgZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXk7XG5cblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIHNob3cvaGlkZSBwYXNzXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMuZXhlYyggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvd1xuXHRcdFx0XHQvLyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpc3BsYXkgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7fSApO1xuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHN0YXRlIGlmIGl0cyB0b2dnbGUgLSBlbmFibGVzIC5zdG9wKCkudG9nZ2xlKCkgdG8gXCJyZXZlcnNlXCJcblx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0fVxuXHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0alF1ZXJ5KCBlbGVtICkuc2hvdygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5oaWRlKCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcDtcblxuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdHR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcblx0fSBlbHNlIGlmICggKCBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5ICkgPT09IFwiaW5saW5lXCIgKSB7XG5cdFx0c3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdGpRdWVyeS5wcm94eSggcmVzdWx0LnN0b3AsIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3R3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZngub2ZmID8gMCA6IHR5cGVvZiBvcHQuZHVyYXRpb24gPT09IFwibnVtYmVyXCIgP1xuXHRcdG9wdC5kdXJhdGlvbiA6IG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID9cblx0XHRcdGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbiApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IGpRdWVyeS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGlmICggdGltZXIoKSApIHtcblx0XHRqUXVlcnkuZnguc3RhcnQoKTtcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkudGltZXJzLnBvcCgpO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoICF0aW1lcklkICkge1xuXHRcdHRpbWVySWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoIGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0d2luZG93LmNsZWFySW50ZXJ2YWwoIHRpbWVySWQgKTtcblxuXHR0aW1lcklkID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogaU9TPD01LjEsIEFuZHJvaWQ8PTQuMitcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcblx0Ly8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXG5cdHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2Vcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0alF1ZXJ5Lm5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLCBwcm9wTmFtZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50ICgjMTA4NzApXG5cdFx0XHRcdGlmICggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdFx0XHQvLyBTZXQgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB0byBmYWxzZVxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlO1xuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBuYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0cmV0dXJuIHRhYmluZGV4ID9cblx0XHRcdFx0XHRwYXJzZUludCggdGFiaW5kZXgsIDEwICkgOlxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJiBlbGVtLmhyZWYgP1xuXHRcdFx0XHRcdFx0XHQwIDpcblx0XHRcdFx0XHRcdFx0LTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxudmFyIHJjbGFzcyA9IC9bXFx0XFxyXFxuXFxmXS9nO1xuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSApIHtcblx0XHRcdGNsYXNzZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIFwiIFwiICsgY3VyVmFsdWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgZ2V0Q2xhc3MoIGVsZW0gKSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTFcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2csXG5cdHJzcGFjZXMgPSAvW1xceDIwXFx0XFxyXFxuXFxmXSsvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgaXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdFx0cmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKSA6XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICkucmVwbGFjZSggcnNwYWNlcywgXCIgXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IGluZGV4IDwgMCA/XG5cdFx0XHRcdFx0XHRtYXggOlxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQoIHN1cHBvcnQub3B0RGlzYWJsZWQgP1xuXHRcdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PT0gbnVsbCApICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IWpRdWVyeS5ub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3LTgrLCBDaHJvbWU8MzctNDQrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjkyODBcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxucmV0dXJuIGpRdWVyeTtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDE2IDE3Il0sInNvdXJjZVJvb3QiOiIifQ==');
},2:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _EventsEmitter = __webpack_require__(6);\n\nvar _EventsEmitter2 = _interopRequireDefault(_EventsEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_EventsEmitter2.default.Composer = _EventsEmitter.EventsEmitterComposer;\n\nexports.default = _EventsEmitter2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9FdmVudHNFbWl0dGVyL2luZGV4LmpzPzQ1ZTEiXSwibmFtZXMiOlsiQ29tcG9zZXIiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFHQSx3QkFBY0EsUUFBZCIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFdmVudHNFbWl0dGVyQ29tcG9zZXJ9IGZyb20gJy4vRXZlbnRzRW1pdHRlcidcbmltcG9ydCBFdmVudHNFbWl0dGVyIGZyb20gJy4vRXZlbnRzRW1pdHRlcidcblxuRXZlbnRzRW1pdHRlci5Db21wb3NlciA9IEV2ZW50c0VtaXR0ZXJDb21wb3NlclxuXG5leHBvcnQgZGVmYXVsdCBFdmVudHNFbWl0dGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9FdmVudHNFbWl0dGVyL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},3:function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTMiXSwic291cmNlUm9vdCI6IiJ9')},4:function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName("head")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(false) {\n\t\tif(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === "undefined") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === "undefined") options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === "top") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === "bottom") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error("Invalid value for parameter \'insertAt\'. Must be \'top\' or \'bottom\'.");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement("style");\n\tstyleElement.type = "text/css";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement("link");\n\tlinkElement.rel = "stylesheet";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute("media", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/Yjk4MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblx0fSksXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuXHR9KSxcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0XHR9XG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHRpZihzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xuXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYylcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMgNCA1IDYgNyA4IDkgMTAgMTEgMTMiXSwic291cmNlUm9vdCI6IiJ9')},6:function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsEmitter = function () {\n\n  ///////////////////////////////////////////////////////////////////\n  //\n  //\n  ///////////////////////////////////////////////////////////////////\n  function EventsEmitter() {\n    _classCallCheck(this, EventsEmitter);\n\n    this._events = {};\n  }\n\n  ///////////////////////////////////////////////////////////////////\n  // Supports multiple events space-separated\n  //\n  ///////////////////////////////////////////////////////////////////\n\n\n  _createClass(EventsEmitter, [{\n    key: 'on',\n    value: function on(events, fct) {\n      var _this = this;\n\n      events.split(' ').forEach(function (event) {\n\n        _this._events[event] = _this._events[event] || [];\n        _this._events[event].push(fct);\n      });\n\n      return this;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    // Supports multiple events space-separated\n    //\n    ///////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'off',\n    value: function off(events, fct) {\n      var _this2 = this;\n\n      if (events == undefined) {\n        this._events = {};\n        return;\n      }\n\n      events.split(' ').forEach(function (event) {\n\n        if (event in _this2._events === false) return;\n\n        if (fct) {\n\n          _this2._events[event].splice(_this2._events[event].indexOf(fct), 1);\n        } else {\n\n          _this2._events[event] = [];\n        }\n      });\n\n      return this;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'emit',\n    value: function emit(event /* , args... */) {\n\n      if (this._events[event] === undefined) return;\n\n      var tmpArray = this._events[event].slice();\n\n      for (var i = 0; i < tmpArray.length; ++i) {\n\n        var result = tmpArray[i].apply(this, Array.prototype.slice.call(arguments, 1));\n\n        if (result !== undefined) return result;\n      }\n\n      return undefined;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'guid',\n    value: function guid() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxxxxxx';\n\n\n      var d = new Date().getTime();\n\n      var guid = format.replace(/[xy]/g, function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n      });\n\n      return guid;\n    }\n  }]);\n\n  return EventsEmitter;\n}();\n\n///////////////////////////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////////////////////////\n\n\nexports.default = EventsEmitter;\nvar EventsEmitterComposer = exports.EventsEmitterComposer = function EventsEmitterComposer(BaseClass) {\n  return function (_BaseClass) {\n    _inherits(_class, _BaseClass);\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n    function _class(arg1, arg2, arg3, arg4, arg5) {\n      _classCallCheck(this, _class);\n\n      var _this3 = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, arg1, arg2, arg3, arg4, arg5));\n\n      _this3._events = {};\n      return _this3;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    // Supports multiple events space-separated\n    //\n    ///////////////////////////////////////////////////////////////////\n\n\n    _createClass(_class, [{\n      key: 'on',\n      value: function on(events, fct) {\n        var _this4 = this;\n\n        events.split(' ').forEach(function (event) {\n\n          _this4._events[event] = _this4._events[event] || [];\n          _this4._events[event].push(fct);\n        });\n\n        return this;\n      }\n\n      ///////////////////////////////////////////////////////////////////\n      // Supports multiple events space-separated\n      //\n      ///////////////////////////////////////////////////////////////////\n\n    }, {\n      key: 'off',\n      value: function off(events, fct) {\n        var _this5 = this;\n\n        if (events == undefined) {\n          this._events = {};\n          return;\n        }\n\n        events.split(' ').forEach(function (event) {\n\n          if (event in _this5._events === false) return;\n\n          if (fct) {\n\n            _this5._events[event].splice(_this5._events[event].indexOf(fct), 1);\n          } else {\n\n            _this5._events[event] = [];\n          }\n        });\n\n        return this;\n      }\n\n      ///////////////////////////////////////////////////////////////////\n      //\n      //\n      ///////////////////////////////////////////////////////////////////\n\n    }, {\n      key: 'emit',\n      value: function emit(event /* , args... */) {\n\n        if (this._events[event] === undefined) return;\n\n        var tmpArray = this._events[event].slice();\n\n        for (var i = 0; i < tmpArray.length; ++i) {\n\n          var result = tmpArray[i].apply(this, Array.prototype.slice.call(arguments, 1));\n\n          if (result !== undefined) return result;\n        }\n\n        return undefined;\n      }\n\n      ///////////////////////////////////////////////////////////////////\n      //\n      //\n      ///////////////////////////////////////////////////////////////////\n\n    }, {\n      key: 'guid',\n      value: function guid() {\n        var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxxxxxx';\n\n\n        var d = new Date().getTime();\n\n        var guid = format.replace(/[xy]/g, function (c) {\n          var r = (d + Math.random() * 16) % 16 | 0;\n          d = Math.floor(d / 16);\n          return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n        });\n\n        return guid;\n      }\n    }]);\n\n    return _class;\n  }(BaseClass);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9FdmVudHNFbWl0dGVyL0V2ZW50c0VtaXR0ZXIuanM/YmMxZiJdLCJuYW1lcyI6WyJFdmVudHNFbWl0dGVyIiwiX2V2ZW50cyIsImV2ZW50cyIsImZjdCIsInNwbGl0IiwiZm9yRWFjaCIsImV2ZW50IiwicHVzaCIsInVuZGVmaW5lZCIsInNwbGljZSIsImluZGV4T2YiLCJ0bXBBcnJheSIsInNsaWNlIiwiaSIsImxlbmd0aCIsInJlc3VsdCIsImFwcGx5IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiZm9ybWF0IiwiZCIsIkRhdGUiLCJnZXRUaW1lIiwiZ3VpZCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJmbG9vciIsInRvU3RyaW5nIiwiRXZlbnRzRW1pdHRlckNvbXBvc2VyIiwiQmFzZUNsYXNzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsImFyZzUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0lBQ3FCQSxhOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUFlO0FBQUE7O0FBRWIsU0FBS0MsT0FBTCxHQUFlLEVBQWY7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7dUJBQ0lDLE0sRUFBUUMsRyxFQUFLO0FBQUE7O0FBRWZELGFBQU9FLEtBQVAsQ0FBYSxHQUFiLEVBQWtCQyxPQUFsQixDQUEwQixVQUFDQyxLQUFELEVBQVc7O0FBRW5DLGNBQUtMLE9BQUwsQ0FBYUssS0FBYixJQUFzQixNQUFLTCxPQUFMLENBQWFLLEtBQWIsS0FBdUIsRUFBN0M7QUFDQSxjQUFLTCxPQUFMLENBQWFLLEtBQWIsRUFBb0JDLElBQXBCLENBQXlCSixHQUF6QjtBQUNELE9BSkQ7O0FBTUEsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7d0JBQ0tELE0sRUFBUUMsRyxFQUFLO0FBQUE7O0FBRWhCLFVBQUdELFVBQVVNLFNB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QUFHTCxXQUFXUCxTQUFkLEVBQ0UsT0FBT08sTUFBUDtBQUNIOztBQUVELGVBQU9QLFNBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFwRkE7QUFBQTtBQUFBLDZCQXFGNEI7QUFBQSxZQUF2QmEsTUFBdUIsdUVBQWhCLGNBQWdCOzs7QUFFMUIsWUFBSUMsSUFBSSxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBUjs7QUFFQSxZQUFJQyxPQUFPSixPQUFPSyxPQUFQLENBQ1QsT0FEUyxFQUVULFVBQVVDLENBQVYsRUFBYTtBQUNYLGNBQUlDLElBQUksQ0FBQ04sSUFBSU8sS0FBS0MsTUFBTCxLQUFnQixFQUFyQixJQUEyQixFQUEzQixHQUFnQyxDQUF4QztBQUNBUixjQUFJTyxLQUFLRSxLQUFMLENBQVdULElBQUksRUFBZixDQUFKO0FBQ0EsaUJBQU8sQ0FBQ0ssS0FBSyxHQUFMLEdBQVdDLENBQVgsR0FBZ0JBLElBQUksR0FBSixHQUFVLEdBQTNCLEVBQWlDSSxRQUFqQyxDQUEwQyxFQUExQyxDQUFQO0FBQ0QsU0FOUSxDQUFYOztBQVFBLGVBQU9QLElBQVA7QUFDRDtBQWxHRDs7QUFBQTtBQUFBLElBQTZCUyxTQUE3QjtBQUFBLENBREsiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRzRW1pdHRlciB7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGNvbnN0cnVjdG9yICgpIHtcblxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFN1cHBvcnRzIG11bHRpcGxlIGV2ZW50cyBzcGFjZS1zZXBhcmF0ZWRcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBvbiAoZXZlbnRzLCBmY3QpIHtcblxuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goKGV2ZW50KSA9PiB7XG5cbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdXHR8fCBbXTtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBTdXBwb3J0cyBtdWx0aXBsZSBldmVudHMgc3BhY2Utc2VwYXJhdGVkXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgb2ZmIChldmVudHMsIGZjdCkge1xuXG4gICAgaWYoZXZlbnRzID09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKChldmVudCkgPT4ge1xuXG4gICAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAoZmN0KSB7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5zcGxpY2UoXG4gICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGZjdCksIDEpXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZW1pdCAoZXZlbnQgLyogLCBhcmdzLi4uICovKSB7XG5cbiAgICBpZih0aGlzLl9ldmVudHNbZXZlbnRdID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgdG1wQXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wQXJyYXkubGVuZ3RoOyArK2kpIHtcblxuICAgICAgdmFyIHJlc3VsdFx0PSB0bXBBcnJheVtpXS5hcHBseSh0aGlzLFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblxuICAgICAgaWYocmVzdWx0ICE9PSB1bmRlZmluZWQgKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZ3VpZChmb3JtYXQ9J3h4eHh4eHh4eHh4eCcpIHtcblxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICB2YXIgZ3VpZCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgL1t4eV0vZyxcbiAgICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHg3IHwgMHg4KSkudG9TdHJpbmcoMTYpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gZ3VpZDtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0IEV2ZW50c0VtaXR0ZXJDb21wb3NlciA9XG4gIChCYXNlQ2xhc3MpID0+IGNsYXNzIGV4dGVuZHMgQmFzZUNsYXNzIHtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgY29uc3RydWN0b3IgKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcblxuICAgIHN1cGVyIChhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KVxuXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFN1cHBvcnRzIG11bHRpcGxlIGV2ZW50cyBzcGFjZS1zZXBhcmF0ZWRcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBvbiAoZXZlbnRzLCBmY3QpIHtcblxuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goKGV2ZW50KSA9PiB7XG5cbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdXHR8fCBbXTtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBTdXBwb3J0cyBtdWx0aXBsZSBldmVudHMgc3BhY2Utc2VwYXJhdGVkXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgb2ZmIChldmVudHMsIGZjdCkge1xuXG4gICAgaWYoZXZlbnRzID09IHVuZGVmaW5lZCl7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKChldmVudCkgPT4ge1xuXG4gICAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBpZiAoZmN0KSB7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5zcGxpY2UoXG4gICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5pbmRleE9mKGZjdCksIDEpXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50XSA9IFtdXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZW1pdCAoZXZlbnQgLyogLCBhcmdzLi4uICovKSB7XG5cbiAgICBpZih0aGlzLl9ldmVudHNbZXZlbnRdID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgdG1wQXJyYXkgPSB0aGlzLl9ldmVudHNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wQXJyYXkubGVuZ3RoOyArK2kpIHtcblxuICAgICAgdmFyIHJlc3VsdFx0PSB0bXBBcnJheVtpXS5hcHBseSh0aGlzLFxuICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblxuICAgICAgaWYocmVzdWx0ICE9PSB1bmRlZmluZWQgKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZ3VpZChmb3JtYXQ9J3h4eHh4eHh4eHh4eCcpIHtcblxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICB2YXIgZ3VpZCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgL1t4eV0vZyxcbiAgICAgIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHg3IHwgMHg4KSkudG9TdHJpbmcoMTYpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gZ3VpZFxuICB9XG59XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvRXZlbnRzRW1pdHRlci9FdmVudHNFbWl0dGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},8:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Viewer = __webpack_require__(12);\n\nvar _Viewer2 = _interopRequireDefault(_Viewer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Viewer2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuVG9vbGtpdC9pbmRleC5qcz81ZjFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVmlld2VyVG9vbGtpdCBmcm9tICcuL1ZpZXdlci5Ub29sa2l0J1xuXG5leHBvcnQgZGVmYXVsdCBWaWV3ZXJUb29sa2l0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuVG9vbGtpdC9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},10:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EventsEmitter = __webpack_require__(2);\n\nvar _EventsEmitter2 = _interopRequireDefault(_EventsEmitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } ///////////////////////////////////////////////////////////////////////////////\n//\n//\n//\n///////////////////////////////////////////////////////////////////////////////\n\n\nvar ExtensionBase = function (_EventsEmitter$Compos) {\n  _inherits(ExtensionBase, _EventsEmitter$Compos);\n\n  /////////////////////////////////////////////////////////////////\n  // Class constructor\n  //\n  /////////////////////////////////////////////////////////////////\n  function ExtensionBase(viewer) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ExtensionBase);\n\n    var _this = _possibleConstructorReturn(this, (ExtensionBase.__proto__ || Object.getPrototypeOf(ExtensionBase)).call(this, viewer, options));\n\n    _this._viewer = viewer;\n\n    _this._options = options;\n\n    _this._events = {};\n    return _this;\n  }\n\n  /////////////////////////////////////////////////////////////////\n  // Extension Id\n  //\n  /////////////////////////////////////////////////////////////////\n\n\n  _createClass(ExtensionBase, [{\n    key: 'load',\n\n\n    /////////////////////////////////////////////////////////////////\n    // Load callback\n    //\n    /////////////////////////////////////////////////////////////////\n    value: function load() {\n\n      return true;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Unload callback\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'unload',\n    value: function unload() {\n\n      return true;\n    }\n  }], [{\n    key: 'guid',\n\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n    value: function guid() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxxxx';\n\n\n      var d = new Date().getTime();\n\n      var guid = format.replace(/[xy]/g, function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n      });\n\n      return guid;\n    }\n  }, {\n    key: 'ExtensionId',\n    get: function get() {\n\n      return 'Viewing.Extension.Base';\n    }\n  }]);\n\n  return ExtensionBase;\n}(_EventsEmitter2.default.Composer(Autodesk.Viewing.Extension));\n\nexports.default = ExtensionBase;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuRXh0ZW5zaW9uQmFzZS9WaWV3ZXIuRXh0ZW5zaW9uQmFzZS5qcz82OGRjIl0sIm5hbWVzIjpbIkV4dGVuc2lvbkJhc2UiLCJ2aWV3ZXIiLCJvcHRpb25zIiwiX3ZpZXdlciIsIl9vcHRpb25zIiwiX2V2ZW50cyIsImZvcm1hdCIsImQiLCJEYXRlIiwiZ2V0VGltZSIsImd1aWQiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJ0b1N0cmluZyIsIkNvbXBvc2VyIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiRXh0ZW5zaW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUtBOzs7Ozs7Ozs7OytlQUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztJQUdxQkEsYTs7O0FBR25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQWFDLE1BQWIsRUFBbUM7QUFBQSxRQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQUEsOEhBRTNCRCxNQUYyQixFQUVuQkMsT0FGbUI7O0FBSWpDLFVBQUtDLE9BQUwsR0FBZUYsTUFBZjs7QUFFQSxVQUFLRyxRQUFMLEdBQWdCRixPQUFoQjs7QUFFQSxVQUFLRyxPQUFMLEdBQWUsRUFBZjtBQVJpQztBQVNsQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQXlCQTtBQUNBO0FBQ0E7QUFDQTsyQkFDTzs7QUFFTCxhQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7Ozs2QkFDUzs7QUFFUCxhQUFPLElBQVA7QUFDRDs7Ozs7QUFuQ0Q7QUFDQTtBQUNBO0FBQ0E7MkJBQ21DO0FBQUEsVUFBdkJDLE1BQXVCLHVFQUFkLFlBQWM7OztBQUVqQyxVQUFJQyxJQUFJLElBQUlDLElBQUosR0FBV0MsT0FBWCxFQUFSOztBQUVBLFVBQUlDLE9BQU9KLE9BQU9LLE9BQVAsQ0FDVCxPQURTLEVBRVQsVUFBVUMsQ0FBVixFQUFhO0FBQ1gsWUFBSUMsSUFBSSxDQUFDTixJQUFJTyxLQUFLQyxNQUFMLEtBQWdCLEVBQXJCLElBQTJCLEVBQTNCLEdBQWdDLENBQXhDO0FBQ0FSLFlBQUlPLEtBQUtFLEtBQUwsQ0FBV1QsSUFBSSxFQUFmLENBQUo7QUFDQSxlQUFPLENBQUNLLEtBQUssR0FBTCxHQUFXQyxDQUFYLEdBQWdCQSxJQUFJLEdBQUosR0FBVSxHQUEzQixFQUFpQ0ksUUFBakMsQ0FBMEMsRUFBMUMsQ0FBUDtBQUNELE9BTlEsQ0FBWDs7QUFRQSxhQUFPUCxJQUFQO0FBQ0Q7Ozt3QkF0QndCOztBQUV2QixhQUFPLHdCQUFQO0FBQ0Q7Ozs7RUF4QkQsd0JBQWNRLFFBQWQsQ0FBd0JDLFNBQVNDLE9BQVQsQ0FBaUJDLFNBQXpDLEM7O2tCQURtQnJCLGEiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vL1xuLy9cbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5pbXBvcnQgRXZlbnRzRW1pdHRlciBmcm9tICdFdmVudHNFbWl0dGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRlbnNpb25CYXNlIGV4dGVuZHNcbiAgRXZlbnRzRW1pdHRlci5Db21wb3NlciAoQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb24pIHtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBDbGFzcyBjb25zdHJ1Y3RvclxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBjb25zdHJ1Y3RvciAodmlld2VyLCBvcHRpb25zID0ge30pIHtcblxuICAgIHN1cGVyKHZpZXdlciwgb3B0aW9ucylcblxuICAgIHRoaXMuX3ZpZXdlciA9IHZpZXdlclxuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcblxuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBFeHRlbnNpb24gSWRcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGdldCBFeHRlbnNpb25JZCgpIHtcblxuICAgIHJldHVybiAnVmlld2luZy5FeHRlbnNpb24uQmFzZSdcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ3VpZChmb3JtYXQgPSAneHh4eHh4eHh4eCcpIHtcblxuICAgIHZhciBkID0gbmV3IERhdGUoKS5nZXRUaW1lKClcblxuICAgIHZhciBndWlkID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAvW3h5XS9nLFxuICAgICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDBcbiAgICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KVxuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHg3IHwgMHg4KSkudG9TdHJpbmcoMTYpXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIGd1aWRcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIExvYWQgY2FsbGJhY2tcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgbG9hZCgpIHtcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBVbmxvYWQgY2FsbGJhY2tcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgdW5sb2FkKCkge1xuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuRXh0ZW5zaW9uQmFzZS9WaWV3ZXIuRXh0ZW5zaW9uQmFzZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},11:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _Viewer = __webpack_require__(10);\n\nvar _Viewer2 = _interopRequireDefault(_Viewer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _Viewer2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuRXh0ZW5zaW9uQmFzZS9pbmRleC5qcz8zZmIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZpZXdlckV4dGVuc2lvbkJhc2UgZnJvbSAnLi9WaWV3ZXIuRXh0ZW5zaW9uQmFzZSdcblxuZXhwb3J0IGRlZmF1bHQgVmlld2VyRXh0ZW5zaW9uQmFzZVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvVmlld2VyLkV4dGVuc2lvbkJhc2UvaW5kZXguanMiXSwic291cmNlUm9vdCI6IiJ9")},12:function(module,exports){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ViewerToolkit = function () {\n  function ViewerToolkit() {\n    _classCallCheck(this, ViewerToolkit);\n  }\n\n  _createClass(ViewerToolkit, null, [{\n    key: 'guid',\n\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n    value: function guid() {\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxxxxxx';\n\n\n      var d = new Date().getTime();\n\n      var guid = format.replace(/[xy]/g, function (c) {\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n      });\n\n      return guid;\n    }\n\n    /////////////////////////////////////////////\n    //mobile detection\n    //\n    /////////////////////////////////////////////\n\n  }, {\n    key: 'getDefaultViewablePath',\n\n\n    //////////////////////////////////////////////////////////////////////////\n    // Return default viewable path: first 3d or 2d item\n    //\n    //////////////////////////////////////////////////////////////////////////\n    value: function getDefaultViewablePath(doc) {\n      var roles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['3d', '2d'];\n\n\n      var rootItem = doc.getRootItem();\n\n      var roleArray = [].concat(_toConsumableArray(roles));\n\n      var items = [];\n\n      roleArray.forEach(function (role) {\n\n        items = [].concat(_toConsumableArray(items), _toConsumableArray(Autodesk.Viewing.Document.getSubItemsWithProperties(rootItem, { type: 'geometry', role: role }, true)));\n      });\n\n      return items.length ? doc.getViewablePath(items[0]) : null;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Toolbar button\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'createButton',\n    value: function createButton(id, className, tooltip, handler) {\n\n      var button = new Autodesk.Viewing.UI.Button(id);\n\n      button.icon.style.fontSize = '24px';\n\n      button.icon.className = className;\n\n      button.setToolTip(tooltip);\n\n      button.onClick = handler;\n\n      return button;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Control group\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'createControlGroup',\n    value: function createControlGroup(viewer, ctrlGroupName) {\n\n      var viewerToolbar = viewer.getToolbar(true);\n\n      if (viewerToolbar) {\n\n        var ctrlGroup = new Autodesk.Viewing.UI.ControlGroup(ctrlGroupName);\n\n        viewerToolbar.addControl(ctrlGroup);\n\n        return ctrlGroup;\n      }\n    }\n\n    /////////////////////////////////////////////////////////////////\n    //\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getLeafNodes',\n    value: function getLeafNodes(model, dbIds) {\n\n      return new Promise(function (resolve, reject) {\n\n        try {\n\n          var _instanceTree = model.getData().instanceTree;\n\n          dbIds = dbIds || _instanceTree.getRootId();\n\n          var dbIdArray = Array.isArray(dbIds) ? dbIds : [dbIds];\n\n          var leafIds = [];\n\n          var getLeafNodesRec = function getLeafNodesRec(id) {\n\n            var childCount = 0;\n\n            _instanceTree.enumNodeChildren(id, function (childId) {\n\n              getLeafNodesRec(childId);\n\n              ++childCount;\n            });\n\n            if (childCount == 0) {\n\n              leafIds.push(id);\n            }\n          };\n\n          for (var i = 0; i < dbIdArray.length; ++i) {\n\n            getLeafNodesRec(dbIdArray[i]);\n          }\n\n          return resolve(leafIds);\n        } catch (ex) {\n\n          return reject(ex);\n        }\n      });\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // get node fragIds\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getFragIds',\n    value: function getFragIds(model, dbIds) {\n      var _this = this;\n\n      return new Promise(function () {\n        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2(resolve, reject) {\n          var i, _ret;\n\n          return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  return _context2.delegateYield(regeneratorRuntime.mark(function _callee() {\n                    var dbIdArray, instanceTree, leafIds, fragIds;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            dbIdArray = Array.isArray(dbIds) ? dbIds : [dbIds];\n                            instanceTree = model.getData().instanceTree;\n                            _context.next = 4;\n                            return ViewerToolkit.getLeafNodes(model, dbIdArray);\n\n                          case 4:\n                            leafIds = _context.sent;\n                            fragIds = [];\n\n\n                            for (i = 0; i < leafIds.length; ++i) {\n\n                              instanceTree.enumNodeFragments(leafIds[i], function (fragId) {\n                                fragIds.push(fragId);\n                              });\n                            }\n\n                            return _context.abrupt('return', {\n                              v: resolve(fragIds)\n                            });\n\n                          case 8:\n                          case 'end':\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, _this);\n                  })(), 't0', 2);\n\n                case 2:\n                  _ret = _context2.t0;\n\n                  if (!((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\")) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  return _context2.abrupt('return', _ret.v);\n\n                case 5:\n                  _context2.next = 10;\n                  break;\n\n                case 7:\n                  _context2.prev = 7;\n                  _context2.t1 = _context2['catch'](0);\n                  return _context2.abrupt('return', reject(_context2.t1));\n\n                case 10:\n                case 'end':\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, _this, [[0, 7]]);\n        }));\n\n        return function (_x3, _x4) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Node bounding box\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getWorldBoundingBox',\n    value: function getWorldBoundingBox(model, dbId) {\n      var _this2 = this;\n\n      return new Promise(function () {\n        var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(resolve, reject) {\n          var fragIds, fragList, fragbBox, nodebBox;\n          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  _context3.next = 3;\n                  return ViewerToolkit.getFragIds(model, dbId);\n\n                case 3:\n                  fragIds = _context3.sent;\n\n                  if (fragIds.length) {\n                    _context3.next = 6;\n                    break;\n                  }\n\n                  return _context3.abrupt('return', reject('No geometry, invalid dbId?'));\n\n                case 6:\n                  fragList = model.getFragmentList();\n                  fragbBox = new THREE.Box3();\n                  nodebBox = new THREE.Box3();\n\n\n                  fragIds.forEach(function (fragId) {\n\n                    fragList.getWorldBounds(fragId, fragbBox);\n                    nodebBox.union(fragbBox);\n                  });\n\n                  return _context3.abrupt('return', resolve(nodebBox));\n\n                case 13:\n                  _context3.prev = 13;\n                  _context3.t0 = _context3['catch'](0);\n                  return _context3.abrupt('return', reject(_context3.t0));\n\n                case 16:\n                case 'end':\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, _this2, [[0, 13]]);\n        }));\n\n        return function (_x5, _x6) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Gets properties from component\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getProperties',\n    value: function getProperties(model, dbId) {\n      var requestedProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\n      return new Promise(function (resolve, reject) {\n\n        try {\n\n          if (requestedProps) {\n\n            var propTasks = requestedProps.map(function (displayName) {\n\n              return ViewerToolkit.getProperty(model, dbId, displayName, 'Not Available');\n            });\n\n            Promise.all(propTasks).then(function (properties) {\n\n              resolve(properties);\n            });\n          } else {\n\n            model.getProperties(dbId, function (result) {\n\n              if (result.properties) {\n\n                return resolve(result.properties);\n              }\n\n              return reject('No Properties');\n            });\n          }\n        } catch (ex) {\n\n          console.log(ex);\n          return reject(ex);\n        }\n      });\n    }\n\n    /////////////////////////////////////////////////////////////////\n    //\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getProperty',\n    value: function getProperty(model, dbId, displayName, defaultValue) {\n\n      return new Promise(function (resolve, reject) {\n\n        try {\n\n          model.getProperties(dbId, function (result) {\n\n            if (result.properties) {\n\n              result.properties.forEach(function (prop) {\n\n                if (typeof displayName === 'function') {\n\n                  if (displayName(prop.displayName)) {\n\n                    resolve(prop);\n                  }\n                } else if (displayName === prop.displayName) {\n\n                  resolve(prop);\n                }\n              });\n\n              if (defaultValue) {\n\n                return resolve({\n                  displayValue: defaultValue,\n                  displayName: displayName\n                });\n              }\n\n              reject(new Error('Not Found'));\n            } else {\n\n              reject(new Error('Error getting properties'));\n            }\n          });\n        } catch (ex) {\n\n          return reject(ex);\n        }\n      });\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Gets all existing properties from component  dbIds\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getPropertyList',\n    value: function getPropertyList(model, dbIds) {\n      var _this3 = this;\n\n      return new Promise(function () {\n        var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(resolve, reject) {\n          var propertyTasks, propertyResults, properties;\n          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.prev = 0;\n                  propertyTasks = dbIds.map(function (dbId) {\n\n                    return ViewerToolkit.getProperties(model, dbId);\n                  });\n                  _context4.next = 4;\n                  return Promise.all(propertyTasks);\n\n                case 4:\n                  propertyResults = _context4.sent;\n                  properties = [];\n\n\n                  propertyResults.forEach(function (propertyResult) {\n\n                    propertyResult.forEach(function (prop) {\n\n                      if (properties.indexOf(prop.displayName) < 0) {\n\n                        properties.push(prop.displayName);\n                      }\n                    });\n                  });\n\n                  return _context4.abrupt('return', resolve(properties.sort()));\n\n                case 10:\n                  _context4.prev = 10;\n                  _context4.t0 = _context4['catch'](0);\n                  return _context4.abrupt('return', reject(_context4.t0));\n\n                case 13:\n                case 'end':\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, _this3, [[0, 10]]);\n        }));\n\n        return function (_x8, _x9) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n    }\n\n    /////////////////////////////////////////////////////////////////\n    //\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'getBulkPropertiesAsync',\n    value: function getBulkPropertiesAsync(model, dbIds, propFilter) {\n\n      return new Promise(function (resolve, reject) {\n\n        model.getBulkProperties(dbIds, propFilter, function (result) {\n\n          resolve(result);\n        }, function (error) {\n\n          reject(error);\n        });\n      });\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Maps components by property\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'mapComponentsByProp',\n    value: function mapComponentsByProp(model, propName, components, defaultProp) {\n      var _this4 = this;\n\n      return new Promise(function () {\n        var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(resolve, reject) {\n          var results, propertyResults, componentsMap;\n          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.prev = 0;\n                  _context5.next = 3;\n                  return ViewerToolkit.getBulkPropertiesAsync(model, components, [propName]);\n\n                case 3:\n                  results = _context5.sent;\n                  propertyResults = results.map(function (result) {\n\n                    return Object.assign({}, result.properties[0], {\n                      dbId: result.dbId\n                    });\n                  });\n                  componentsMap = {};\n\n\n                  propertyResults.forEach(function (result) {\n\n                    var value = result.displayValue;\n\n                    if (typeof value == 'string') {\n\n                      value = value.split(':')[0];\n                    }\n\n                    if (!componentsMap[value]) {\n\n                      componentsMap[value] = [];\n                    }\n\n                    componentsMap[value].push(result.dbId);\n                  });\n\n                  return _context5.abrupt('return', resolve(componentsMap));\n\n                case 10:\n                  _context5.prev = 10;\n                  _context5.t0 = _context5['catch'](0);\n                  return _context5.abrupt('return', reject(_context5.t0));\n\n                case 13:\n                case 'end':\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, _this4, [[0, 10]]);\n        }));\n\n        return function (_x10, _x11) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n    }\n\n    /////////////////////////////////////////////////////////////\n    // Runs recursively the argument task on each node\n    // of the data tree\n    //\n    /////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'runTaskOnDataTree',\n    value: function runTaskOnDataTree(root, taskFunc) {\n\n      var tasks = [];\n\n      var runTaskOnDataTreeRec = function runTaskOnDataTreeRec(node) {\n        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\n        if (node.children) {\n\n          node.children.forEach(function (childNode) {\n\n            runTaskOnDataTreeRec(childNode, node);\n          });\n        }\n\n        var task = taskFunc(node, parent);\n\n        tasks.push(task);\n      };\n\n      runTaskOnDataTreeRec(root);\n\n      return Promise.all(tasks);\n    }\n\n    /////////////////////////////////////////////////////////////////\n    //\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'drawBox',\n    value: function drawBox(viewer, min, max) {\n      var material = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n\n      var _material = material;\n\n      if (!_material) {\n\n        _material = new THREE.LineBasicMaterial({\n          color: 0xffff00,\n          linewidth: 2\n        });\n\n        viewer.impl.matman().addMaterial('ADN-Material-Line', _material, true);\n      }\n\n      function drawLines(coordsArray, mat) {\n\n        var lines = [];\n\n        for (var i = 0; i < coordsArray.length; i += 2) {\n\n          var start = coordsArray[i];\n          var end = coordsArray[i + 1];\n\n          var geometry = new THREE.Geometry();\n\n          geometry.vertices.push(new THREE.Vector3(start.x, start.y, start.z));\n\n          geometry.vertices.push(new THREE.Vector3(end.x, end.y, end.z));\n\n          geometry.computeLineDistances();\n\n          var line = new THREE.Line(geometry, mat);\n\n          viewer.impl.scene.add(line);\n\n          lines.push(line);\n        }\n\n        return lines;\n      }\n\n      var lines = drawLines([{ x: min.x, y: min.y, z: min.z }, { x: max.x, y: min.y, z: min.z }, { x: max.x, y: min.y, z: min.z }, { x: max.x, y: min.y, z: max.z }, { x: max.x, y: min.y, z: max.z }, { x: min.x, y: min.y, z: max.z }, { x: min.x, y: min.y, z: max.z }, { x: min.x, y: min.y, z: min.z }, { x: min.x, y: max.y, z: max.z }, { x: max.x, y: max.y, z: max.z }, { x: max.x, y: max.y, z: max.z }, { x: max.x, y: max.y, z: min.z }, { x: max.x, y: max.y, z: min.z }, { x: min.x, y: max.y, z: min.z }, { x: min.x, y: max.y, z: min.z }, { x: min.x, y: max.y, z: max.z }, { x: min.x, y: min.y, z: min.z }, { x: min.x, y: max.y, z: min.z }, { x: max.x, y: min.y, z: min.z }, { x: max.x, y: max.y, z: min.z }, { x: max.x, y: min.y, z: max.z }, { x: max.x, y: max.y, z: max.z }, { x: min.x, y: min.y, z: max.z }, { x: min.x, y: max.y, z: max.z }], _material);\n\n      viewer.impl.sceneUpdated(true);\n\n      return lines;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Set component material\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'setMaterial',\n    value: function () {\n      var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(model, dbId, material) {\n        var fragIds, fragList;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return ViewerToolkit.getFragIds(model, dbId);\n\n              case 2:\n                fragIds = _context6.sent;\n                fragList = model.getFragmentList();\n\n\n                fragIds.forEach(function (fragId) {\n\n                  fragList.setMaterial(fragId, material);\n                });\n\n              case 5:\n              case 'end':\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function setMaterial(_x14, _x15, _x16) {\n        return _ref5.apply(this, arguments);\n      }\n\n      return setMaterial;\n    }()\n\n    /////////////////////////////////////////////////////////////////\n    // Recursively builds the model tree\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'buildModelTree',\n    value: function buildModelTree(model) {\n      var createNodeFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\n      //builds model tree recursively\n      function _buildModelTreeRec(node) {\n\n        instanceTree.enumNodeChildren(node.dbId, function (childId) {\n\n          var childNode = null;\n\n          if (createNodeFunc) {\n\n            childNode = createNodeFunc(childId);\n          } else {\n\n            node.children = node.children || [];\n\n            childNode = {\n              dbId: childId,\n              name: instanceTree.getNodeName(childId)\n            };\n\n            node.children.push(childNode);\n          }\n\n          _buildModelTreeRec(childNode);\n        });\n      }\n\n      //get model instance tree and root component\n      var instanceTree = model.getData().instanceTree;\n\n      var rootId = instanceTree.getRootId();\n\n      var rootNode = {\n        dbId: rootId,\n        name: instanceTree.getNodeName(rootId)\n      };\n\n      _buildModelTreeRec(rootNode);\n\n      return rootNode;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Recursively execute task on model tree\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'executeTaskOnModelTree',\n    value: function executeTaskOnModelTree(model, task) {\n\n      var taskResults = [];\n\n      function _executeTaskOnModelTreeRec(dbId) {\n\n        instanceTree.enumNodeChildren(dbId, function (childId) {\n\n          taskResults.push(task(model, childId));\n\n          _executeTaskOnModelTreeRec(childId);\n        });\n      }\n\n      //get model instance tree and root component\n      var instanceTree = model.getData().instanceTree;\n\n      var rootId = instanceTree.getRootId();\n\n      _executeTaskOnModelTreeRec(rootId);\n\n      return taskResults;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    //\n    //\n    /////////////////////////////////////////////////////////////////\n\n  }, {\n    key: 'isolateFull',\n    value: function isolateFull(viewer) {\n      var _this5 = this;\n\n      var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var dbIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n\n      return new Promise(function () {\n        var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(resolve, reject) {\n          var targetIds, targetLeafIds, leafIds, leafTasks;\n          return regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.prev = 0;\n\n\n                  model = model || viewer.model;\n\n                  viewer.isolate(dbIds);\n\n                  targetIds = Array.isArray(dbIds) ? dbIds : [dbIds];\n                  _context7.next = 6;\n                  return ViewerToolkit.getLeafNodes(model, targetIds);\n\n                case 6:\n                  targetLeafIds = _context7.sent;\n                  _context7.next = 9;\n                  return ViewerToolkit.getLeafNodes(model);\n\n                case 9:\n                  leafIds = _context7.sent;\n                  leafTasks = leafIds.map(function (dbId) {\n\n                    return new Promise(function (resolveLeaf) {\n\n                      var show = !targetLeafIds.length || targetLeafIds.indexOf(dbId) > -1;\n\n                      viewer.impl.visibilityManager.setNodeOff(dbId, !show);\n\n                      resolveLeaf();\n                    });\n                  });\n                  return _context7.abrupt('return', Promise.all(leafTasks));\n\n                case 14:\n                  _context7.prev = 14;\n                  _context7.t0 = _context7['catch'](0);\n                  return _context7.abrupt('return', reject(_context7.t0));\n\n                case 17:\n                case 'end':\n                  return _context7.stop();\n              }\n            }\n          }, _callee7, _this5, [[0, 14]]);\n        }));\n\n        return function (_x20, _x21) {\n          return _ref6.apply(this, arguments);\n        };\n      }());\n    }\n  }, {\n    key: 'mobile',\n    get: function get() {\n\n      return {\n\n        getUserAgent: function getUserAgent() {\n          return navigator.userAgent;\n        },\n        isAndroid: function isAndroid() {\n          return this.getUserAgent().match(/Android/i);\n        },\n        isBlackBerry: function isBlackBerry() {\n          return this.getUserAgent().match(/BlackBerry/i);\n        },\n        isIOS: function isIOS() {\n          return this.getUserAgent().match(/iPhone|iPad|iPod/i);\n        },\n        isOpera: function isOpera() {\n          return this.getUserAgent().match(/Opera Mini/i);\n        },\n        isWindows: function isWindows() {\n          return this.isWindowsDesktop() || this.isWindowsMobile();\n        },\n        isWindowsMobile: function isWindowsMobile() {\n          return this.getUserAgent().match(/IEMobile/i);\n        },\n        isWindowsDesktop: function isWindowsDesktop() {\n          return this.getUserAgent().match(/WPDesktop/i);\n        },\n        isAny: function isAny() {\n\n          return this.isAndroid() || this.isBlackBerry() || this.isIOS() || this.isWindowsMobile();\n        }\n      };\n    }\n  }]);\n\n  return ViewerToolkit;\n}();\n\nexports.default = ViewerToolkit;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9WaWV3ZXIuVG9vbGtpdC9WaWV3ZXIuVG9vbGtpdC5qcz82MGJlIl0sIm5hbWVzIjpbIlZpZXdlclRvb2xraXQiLCJmb3JtYXQiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJndWlkIiwicmVwbGFjZSIsImMiLCJyIiwiTWF0aCIsInJhbmRvbSIsImZsb29yIiwidG9TdHJpbmciLCJkb2MiLCJyb2xlcyIsInJvb3RJdGVtIiwiZ2V0Um9vdEl0ZW0iLCJyb2xlQXJyYXkiLCJpdGVtcyIsImZvckVhY2giLCJyb2xlIiwiQXV0b2Rlc2siLCJWaWV3aW5nIiwiRG9jdW1lbnQiLCJnZXRTdWJJdGVtc1dpdGhQcm9wZXJ0aWVzIiwidHlwZSIsImxlbmd0aCIsImdldFZpZXdhYmxlUGF0aCIsImlkIiwiY2xhc3NOYW1lIiwidG9vbHRpcCIsImhhbmRsZXIiLCJidXR0b24iLCJVSSIsIkJ1dHRvbiIsImljb24iLCJzdHlsZSIsImZvbnRTaXplIiwic2V0VG9vbFRpcCIsIm9uQ2xpY2siLCJ2aWV3ZXIiLCJjdHJsR3JvdXBOYW1lIiwidmlld2VyVG9vbGJhciIsImdldFRvb2xiYXIiLCJjdHJsR3JvdXAiLCJDb250cm9sR3JvdXAiLCJhZGRDb250cm9sIiwibW9kZWwiLCJkYklkcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW5zdGFuY2VUcmVlIiwiZ2V0RGF0YSIsImdldFJvb3RJZCIsImRiSWRBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImxlYWZJZHMiLCJnZXRMZWFmTm9kZXNSZWMiLCJjaGlsZENvdW50IiwiZW51bU5vZGVDaGlsZHJlbiIsImNoaWxkSWQiLCJwdXNoIiwiaSIsImV4IiwiZ2V0TGVhZk5vZGVzIiwiZnJhZ0lkcyIsImVudW1Ob2RlRnJhZ21lbnRzIiwiZnJhZ0lkIiwiZGJJZCIsImdldEZyYWdJZHMiLCJmcmFnTGlzdCIsImdldEZyYWdtZW50TGlzdCIsImZyYWdiQm94IiwiVEhSRUUiLCJCb3gzIiwibm9kZWJCb3giLCJnZXRXb3JsZEJvdW5kcyIsInVuaW9uIiwicmVxdWVzdGVkUHJvcHMiLCJwcm9wVGFza3MiLCJtYXAiLCJkaXNwbGF5TmFtZSIsImdldFByb3BlcnR5IiwiYWxsIiwidGhlbiIsInByb3BlcnRpZXMiLCJnZXRQcm9wZXJ0aWVzIiwicmVzdWx0IiwiY29uc29sZSIsImxvZyIsImRlZmF1bHRWYWx1ZSIsInByb3AiLCJkaXNwbGF5VmFsdWUiLCJFcnJvciIsInByb3BlcnR5VGFza3MiLCJwcm9wZXJ0eVJlc3VsdHMiLCJwcm9wZXJ0eVJlc3VsdCIsImluZGV4T2YiLCJzb3J0IiwicHJvcEZpbHRlciIsImdldEJ1bGtQcm9wZXJ0aWVzIiwiZXJyb3IiLCJwcm9wTmFtZSIsImNvbXBvbmVudHMiLCJkZWZhdWx0UHJvcCIsImdldEJ1bGtQcm9wZXJ0aWVzQXN5bmMiLCJyZXN1bHRzIiwiT2JqZWN0IiwiYXNzaWduIiwiY29tcG9uZW50c01hcCIsInZhbHVlIiwic3BsaXQiLCJyb290IiwidGFza0Z1bmMiLCJ0YXNrcyIsInJ1blRhc2tPbkRhdGFUcmVlUmVjIiwibm9kZSIsInBhcmVudCIsImNoaWxkcmVuIiwiY2hpbGROb2RlIiwidGFzayIsIm1pbiIsIm1heCIsIm1hdGVyaWFsIiwiX21hdGVyaWFsIiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJjb2xvciIsImxpbmV3aWR0aCIsImltcGwiLCJtYXRtYW4iLCJhZGRNYXRlcmlhbCIsImRyYXdMaW5lcyIsImNvb3Jkc0FycmF5IiwibWF0IiwibGluZXMiLCJzdGFydCIsImVuZCIsImdlb21ldHJ5IiwiR2VvbWV0cnkiLCJ2ZXJ0aWNlcyIsIlZlY3RvcjMiLCJ4IiwieSIsInoiLCJjb21wdXRlTGluZURpc3RhbmNlcyIsImxpbmUiLCJMaW5lIiwic2NlbmUiLCJhZGQiLCJzY2VuZVVwZGF0ZWQiLCJzZXRNYXRlcmlhbCIsImNyZWF0ZU5vZGVGdW5jIiwiX2J1aWxkTW9kZWxUcmVlUmVjIiwibmFtZSIsImdldE5vZGVOYW1lIiwicm9vdElkIiwicm9vdE5vZGUiLCJ0YXNrUmVzdWx0cyIsIl9leGVjdXRlVGFza09uTW9kZWxUcmVlUmVjIiwiaXNvbGF0ZSIsInRhcmdldElkcyIsInRhcmdldExlYWZJZHMiLCJsZWFmVGFza3MiLCJyZXNvbHZlTGVhZiIsInNob3ciLCJ2aXNpYmlsaXR5TWFuYWdlciIsInNldE5vZGVPZmYiLCJnZXRVc2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0FuZHJvaWQiLCJtYXRjaCIsImlzQmxhY2tCZXJyeSIsImlzSU9TIiwiaXNPcGVyYSIsImlzV2luZG93cyIsImlzV2luZG93c0Rlc2t0b3AiLCJpc1dpbmRvd3NNb2JpbGUiLCJpc0FueSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztJQUVxQkEsYTs7Ozs7Ozs7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOzJCQUNxQztBQUFBLFVBQXpCQyxNQUF5Qix1RUFBaEIsY0FBZ0I7OztBQUVuQyxVQUFJQyxJQUFJLElBQUlDLElBQUosR0FBV0MsT0FBWCxFQUFSOztBQUVBLFVBQUlDLE9BQU9KLE9BQU9LLE9BQVAsQ0FDVCxPQURTLEVBRVQsVUFBVUMsQ0FBVixFQUFhO0FBQ1gsWUFBSUMsSUFBSSxDQUFDTixJQUFJTyxLQUFLQyxNQUFMLEtBQWdCLEVBQXJCLElBQTJCLEVBQTNCLEdBQWdDLENBQXhDO0FBQ0FSLFlBQUlPLEtBQUtFLEtBQUwsQ0FBV1QsSUFBSSxFQUFmLENBQUo7QUFDQSxlQUFPLENBQUNLLEtBQUssR0FBTCxHQUFXQyxDQUFYLEdBQWdCQSxJQUFJLEdBQUosR0FBVSxHQUEzQixFQUFpQ0ksUUFBakMsQ0FBMEMsRUFBMUMsQ0FBUDtBQUNELE9BTlEsQ0FBWDs7QUFRQSxhQUFPUCxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQXVDQTtBQUNBO0FBQ0E7QUFDQTsyQ0FDK0JRLEcsRUFBMkI7QUFBQSxVQUF0QkMsS0FBc0IsdUVBQWQsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFjOzs7QUFFeEQsVUFB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ZUFBTCxFQUhGO0FBSUQ7QUFoQ0ksT0FBUDtBQWtDRDs7Ozs7O2tCQTdEa0JuTCxhIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdlclRvb2xraXQge1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ3VpZChmb3JtYXQgPSAneHh4eHh4eHh4eHh4Jykge1xuXG4gICAgdmFyIGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIHZhciBndWlkID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAvW3h5XS9nLFxuICAgICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDcgfCAweDgpKS50b1N0cmluZygxNik7XG4gICAgICB9KTtcblxuICAgIHJldHVybiBndWlkO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vbW9iaWxlIGRldGVjdGlvblxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGdldCBtb2JpbGUoKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICBnZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICB9LFxuICAgICAgaXNBbmRyb2lkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXJBZ2VudCgpLm1hdGNoKC9BbmRyb2lkL2kpO1xuICAgICAgfSxcbiAgICAgIGlzQmxhY2tCZXJyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyQWdlbnQoKS5tYXRjaCgvQmxhY2tCZXJyeS9pKTtcbiAgICAgIH0sXG4gICAgICBpc0lPUzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRVc2VyQWdlbnQoKS5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKTtcbiAgICAgIH0sXG4gICAgICBpc09wZXJhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXJBZ2VudCgpLm1hdGNoKC9PcGVyYSBNaW5pL2kpO1xuICAgICAgfSxcbiAgICAgIGlzV2luZG93czogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1dpbmRvd3NEZXNrdG9wKCkgfHwgdGhpcy5pc1dpbmRvd3NNb2JpbGUoKTtcbiAgICAgIH0sXG4gICAgICBpc1dpbmRvd3NNb2JpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXNlckFnZW50KCkubWF0Y2goL0lFTW9iaWxlL2kpO1xuICAgICAgfSxcbiAgICAgIGlzV2luZG93c0Rlc2t0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VXNlckFnZW50KCkubWF0Y2goL1dQRGVza3RvcC9pKTtcbiAgICAgIH0sXG4gICAgICBpc0FueTogZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmlzQW5kcm9pZCgpIHx8XG4gICAgICAgICAgdGhpcy5pc0JsYWNrQmVycnkoKSB8fFxuICAgICAgICAgIHRoaXMuaXNJT1MoKSB8fFxuICAgICAgICAgIHRoaXMuaXNXaW5kb3dzTW9iaWxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gUmV0dXJuIGRlZmF1bHQgdmlld2FibGUgcGF0aDogZmlyc3QgM2Qgb3IgMmQgaXRlbVxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ2V0RGVmYXVsdFZpZXdhYmxlUGF0aCAoZG9jLCByb2xlcyA9IFsnM2QnLCAnMmQnXSkge1xuXG4gICAgdmFyIHJvb3RJdGVtID0gZG9jLmdldFJvb3RJdGVtKClcblxuICAgIGxldCByb2xlQXJyYXkgPSBbLi4ucm9sZXNdXG5cbiAgICBsZXQgaXRlbXMgPSBbXVxuXG4gICAgcm9sZUFycmF5LmZvckVhY2goKHJvbGUpID0+IHtcblxuICAgICAgaXRlbXMgPSBbIC4uLml0ZW1zLFxuICAgICAgICAuLi5BdXRvZGVzay5WaWV3aW5nLkRvY3VtZW50LmdldFN1Ykl0ZW1zV2l0aFByb3BlcnRpZXMoXG4gICAgICAgICAgcm9vdEl0ZW0sIHsgdHlwZTogJ2dlb21ldHJ5Jywgcm9sZSB9LCB0cnVlKSBdXG4gICAgfSlcblxuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPyBkb2MuZ2V0Vmlld2FibGVQYXRoKGl0ZW1zWzBdKSA6IG51bGxcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFRvb2xiYXIgYnV0dG9uXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBjcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgdG9vbHRpcCwgaGFuZGxlcikge1xuXG4gICAgdmFyIGJ1dHRvbiA9IG5ldyBBdXRvZGVzay5WaWV3aW5nLlVJLkJ1dHRvbihpZCk7XG5cbiAgICBidXR0b24uaWNvbi5zdHlsZS5mb250U2l6ZSA9ICcyNHB4JztcblxuICAgIGJ1dHRvbi5pY29uLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcblxuICAgIGJ1dHRvbi5zZXRUb29sVGlwKHRvb2x0aXApO1xuXG4gICAgYnV0dG9uLm9uQ2xpY2sgPSBoYW5kbGVyO1xuXG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIENvbnRyb2wgZ3JvdXBcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGNyZWF0ZUNvbnRyb2xHcm91cCh2aWV3ZXIsIGN0cmxHcm91cE5hbWUpIHtcblxuICAgIHZhciB2aWV3ZXJUb29sYmFyID0gdmlld2VyLmdldFRvb2xiYXIodHJ1ZSk7XG5cbiAgICBpZih2aWV3ZXJUb29sYmFyKXtcblxuICAgICAgdmFyIGN0cmxHcm91cCA9ICBuZXcgQXV0b2Rlc2suVmlld2luZy5VSS5Db250cm9sR3JvdXAoXG4gICAgICAgIGN0cmxHcm91cE5hbWUpO1xuXG4gICAgICB2aWV3ZXJUb29sYmFyLmFkZENvbnRyb2woY3RybEdyb3VwKTtcblxuICAgICAgcmV0dXJuIGN0cmxHcm91cDtcbiAgICB9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ2V0TGVhZk5vZGVzIChtb2RlbCwgZGJJZHMpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuXG4gICAgICB0cnkge1xuXG4gICAgICAgIGNvbnN0IGluc3RhbmNlVHJlZSA9IG1vZGVsLmdldERhdGEoKS5pbnN0YW5jZVRyZWVcblxuICAgICAgICBkYklkcyA9IGRiSWRzIHx8IGluc3RhbmNlVHJlZS5nZXRSb290SWQoKVxuXG4gICAgICAgIGNvbnN0IGRiSWRBcnJheSA9IEFycmF5LmlzQXJyYXkoZGJJZHMpID8gZGJJZHMgOiBbZGJJZHNdXG5cbiAgICAgICAgbGV0IGxlYWZJZHMgPSBbXVxuXG4gICAgICAgIGNvbnN0IGdldExlYWZOb2Rlc1JlYyA9IChpZCkgPT4ge1xuXG4gICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSAwO1xuXG4gICAgICAgICAgaW5zdGFuY2VUcmVlLmVudW1Ob2RlQ2hpbGRyZW4oaWQsIChjaGlsZElkKSA9PiB7XG5cbiAgICAgICAgICAgICAgZ2V0TGVhZk5vZGVzUmVjKGNoaWxkSWQpXG5cbiAgICAgICAgICAgICAgKytjaGlsZENvdW50XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYgKGNoaWxkQ291bnQgPT0gMCkge1xuXG4gICAgICAgICAgICBsZWFmSWRzLnB1c2goaWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYklkQXJyYXkubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgIGdldExlYWZOb2Rlc1JlYyhkYklkQXJyYXlbaV0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZShsZWFmSWRzKVxuXG4gICAgICB9IGNhdGNoKGV4KXtcblxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBnZXQgbm9kZSBmcmFnSWRzXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBnZXRGcmFnSWRzIChtb2RlbCwgZGJJZHMpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyhyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdHJ5e1xuXG4gICAgICAgIGNvbnN0IGRiSWRBcnJheSA9IEFycmF5LmlzQXJyYXkoZGJJZHMpID8gZGJJZHMgOiBbZGJJZHNdXG5cbiAgICAgICAgY29uc3QgaW5zdGFuY2VUcmVlID0gbW9kZWwuZ2V0RGF0YSgpLmluc3RhbmNlVHJlZVxuXG4gICAgICAgIGNvbnN0IGxlYWZJZHMgPSBhd2FpdCBWaWV3ZXJUb29sa2l0LmdldExlYWZOb2RlcyhcbiAgICAgICAgICBtb2RlbCwgZGJJZEFycmF5KVxuXG4gICAgICAgIGxldCBmcmFnSWRzID0gW11cblxuICAgICAgICBmb3IodmFyIGk9MDsgaTwgbGVhZklkcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgaW5zdGFuY2VUcmVlLmVudW1Ob2RlRnJhZ21lbnRzKFxuICAgICAgICAgICAgbGVhZklkc1tpXSwgKGZyYWdJZCkgPT4ge1xuICAgICAgICAgICAgICBmcmFnSWRzLnB1c2goZnJhZ0lkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKGZyYWdJZHMpXG5cbiAgICAgIH0gY2F0Y2goZXgpe1xuXG4gICAgICAgIHJldHVybiByZWplY3QoZXgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIE5vZGUgYm91bmRpbmcgYm94XG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBnZXRXb3JsZEJvdW5kaW5nQm94KG1vZGVsLCBkYklkKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMocmVzb2x2ZSwgcmVqZWN0KT0+e1xuXG4gICAgICB0cnl7XG5cbiAgICAgICAgdmFyIGZyYWdJZHMgPSBhd2FpdCBWaWV3ZXJUb29sa2l0LmdldEZyYWdJZHMoXG4gICAgICAgICAgbW9kZWwsIGRiSWQpO1xuXG4gICAgICAgIGlmKCFmcmFnSWRzLmxlbmd0aCl7XG5cbiAgICAgICAgICByZXR1cm4gcmVqZWN0KCdObyBnZW9tZXRyeSwgaW52YWxpZCBkYklkPycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYWdMaXN0ID0gbW9kZWwuZ2V0RnJhZ21lbnRMaXN0KCk7XG5cbiAgICAgICAgdmFyIGZyYWdiQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcbiAgICAgICAgdmFyIG5vZGViQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgICAgICBmcmFnSWRzLmZvckVhY2goZnVuY3Rpb24oZnJhZ0lkKSB7XG5cbiAgICAgICAgICBmcmFnTGlzdC5nZXRXb3JsZEJvdW5kcyhmcmFnSWQsIGZyYWdiQm94KTtcbiAgICAgICAgICBub2RlYkJveC51bmlvbihmcmFnYkJveCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXNvbHZlKG5vZGViQm94KTtcbiAgICAgIH1cbiAgICAgIGNhdGNoKGV4KXtcblxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEdldHMgcHJvcGVydGllcyBmcm9tIGNvbXBvbmVudFxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ2V0UHJvcGVydGllcyhtb2RlbCwgZGJJZCwgcmVxdWVzdGVkUHJvcHMgPSBudWxsKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICB0cnkge1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRQcm9wcykge1xuXG4gICAgICAgICAgY29uc3QgcHJvcFRhc2tzID0gcmVxdWVzdGVkUHJvcHMubWFwKChkaXNwbGF5TmFtZSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gVmlld2VyVG9vbGtpdC5nZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgbW9kZWwsIGRiSWQsIGRpc3BsYXlOYW1lLCAnTm90IEF2YWlsYWJsZScpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIFByb21pc2UuYWxsKHByb3BUYXNrcykudGhlbigocHJvcGVydGllcykgPT4ge1xuXG4gICAgICAgICAgICByZXNvbHZlKHByb3BlcnRpZXMpXG4gICAgICAgICAgfSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgbW9kZWwuZ2V0UHJvcGVydGllcyhkYklkLCBmdW5jdGlvbihyZXN1bHQpIHtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5wcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgcmVzdWx0LnByb3BlcnRpZXMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWplY3QoJ05vIFByb3BlcnRpZXMnKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgfSBjYXRjaCAoZXgpIHtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGV4KVxuICAgICAgICAgIHJldHVybiByZWplY3QoZXgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBnZXRQcm9wZXJ0eShtb2RlbCwgZGJJZCwgZGlzcGxheU5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdHJ5e1xuXG4gICAgICAgIG1vZGVsLmdldFByb3BlcnRpZXMoZGJJZCwgZnVuY3Rpb24ocmVzdWx0KXtcblxuICAgICAgICAgIGlmIChyZXN1bHQucHJvcGVydGllcykge1xuXG4gICAgICAgICAgICByZXN1bHQucHJvcGVydGllcy5mb3JFYWNoKChwcm9wKSA9PiB7XG5cbiAgICAgICAgICAgICAgaWYodHlwZW9mIGRpc3BsYXlOYW1lID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgICAgICBpZihkaXNwbGF5TmFtZShwcm9wLmRpc3BsYXlOYW1lKSl7XG5cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJvcClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNwbGF5TmFtZSA9PT0gcHJvcC5kaXNwbGF5TmFtZSkge1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9wKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgRm91bmQnKSlcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Vycm9yIGdldHRpbmcgcHJvcGVydGllcycpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjYXRjaChleCl7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBHZXRzIGFsbCBleGlzdGluZyBwcm9wZXJ0aWVzIGZyb20gY29tcG9uZW50ICBkYklkc1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ2V0UHJvcGVydHlMaXN0IChtb2RlbCwgZGJJZHMpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyhyZXNvbHZlLCByZWplY3QpPT57XG5cbiAgICAgIHRyeXtcblxuICAgICAgICB2YXIgcHJvcGVydHlUYXNrcyA9IGRiSWRzLm1hcCgoZGJJZCk9PntcblxuICAgICAgICAgIHJldHVybiBWaWV3ZXJUb29sa2l0LmdldFByb3BlcnRpZXMobW9kZWwsIGRiSWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJvcGVydHlSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcHJvcGVydHlUYXNrc1xuICAgICAgICApO1xuXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG5cbiAgICAgICAgcHJvcGVydHlSZXN1bHRzLmZvckVhY2goKHByb3BlcnR5UmVzdWx0KT0+e1xuXG4gICAgICAgICAgcHJvcGVydHlSZXN1bHQuZm9yRWFjaCgocHJvcCk9PntcblxuICAgICAgICAgICAgaWYocHJvcGVydGllcy5pbmRleE9mKHByb3AuZGlzcGxheU5hbWUpIDwgMCl7XG5cbiAgICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3AuZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9wZXJ0aWVzLnNvcnQoKSk7XG4gICAgICB9XG4gICAgICBjYXRjaChleCl7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgZ2V0QnVsa1Byb3BlcnRpZXNBc3luYyAobW9kZWwsIGRiSWRzLCBwcm9wRmlsdGVyKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICBtb2RlbC5nZXRCdWxrUHJvcGVydGllcyhkYklkcywgcHJvcEZpbHRlciwgKHJlc3VsdCkgPT4ge1xuXG4gICAgICAgIHJlc29sdmUgKHJlc3VsdClcblxuICAgICAgfSwgKGVycm9yKSA9PiB7XG5cbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFwcyBjb21wb25lbnRzIGJ5IHByb3BlcnR5XG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBtYXBDb21wb25lbnRzQnlQcm9wIChtb2RlbCwgcHJvcE5hbWUsIGNvbXBvbmVudHMsIGRlZmF1bHRQcm9wKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgIHRyeSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFZpZXdlclRvb2xraXQuZ2V0QnVsa1Byb3BlcnRpZXNBc3luYyhcbiAgICAgICAgICBtb2RlbCwgY29tcG9uZW50cywgW3Byb3BOYW1lXSlcblxuICAgICAgICBjb25zdCBwcm9wZXJ0eVJlc3VsdHMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LnByb3BlcnRpZXNbMF0sIHtcbiAgICAgICAgICAgIGRiSWQ6IHJlc3VsdC5kYklkXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgY29tcG9uZW50c01hcCA9IHt9O1xuXG4gICAgICAgIHByb3BlcnR5UmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcblxuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC5kaXNwbGF5VmFsdWU7XG5cbiAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpe1xuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6JylbMF1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbXBvbmVudHNNYXBbdmFsdWVdKSB7XG5cbiAgICAgICAgICAgIGNvbXBvbmVudHNNYXBbdmFsdWVdID0gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21wb25lbnRzTWFwW3ZhbHVlXS5wdXNoKHJlc3VsdC5kYklkKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKGNvbXBvbmVudHNNYXApXG5cbiAgICAgIH0gY2F0Y2goZXgpe1xuXG4gICAgICAgIHJldHVybiByZWplY3QoZXgpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFJ1bnMgcmVjdXJzaXZlbHkgdGhlIGFyZ3VtZW50IHRhc2sgb24gZWFjaCBub2RlXG4gIC8vIG9mIHRoZSBkYXRhIHRyZWVcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBzdGF0aWMgcnVuVGFza09uRGF0YVRyZWUocm9vdCwgdGFza0Z1bmMpIHtcblxuICAgIHZhciB0YXNrcyA9IFtdO1xuXG4gICAgdmFyIHJ1blRhc2tPbkRhdGFUcmVlUmVjID0gKG5vZGUsIHBhcmVudD1udWxsKT0+IHtcblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkTm9kZSk9PiB7XG5cbiAgICAgICAgICBydW5UYXNrT25EYXRhVHJlZVJlYyhjaGlsZE5vZGUsIG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhc2sgPSB0YXNrRnVuYyhub2RlLCBwYXJlbnQpO1xuXG4gICAgICB0YXNrcy5wdXNoKHRhc2spO1xuICAgIH1cblxuICAgIHJ1blRhc2tPbkRhdGFUcmVlUmVjKHJvb3QpO1xuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRhc2tzKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBkcmF3Qm94KHZpZXdlciwgbWluLCBtYXgsIG1hdGVyaWFsID0gbnVsbCkge1xuXG4gICAgdmFyIF9tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG4gICAgaWYoIV9tYXRlcmlhbCkge1xuXG4gICAgICBfbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogMHhmZmZmMDAsXG4gICAgICAgIGxpbmV3aWR0aDogMlxuICAgICAgfSk7XG5cbiAgICAgIHZpZXdlci5pbXBsLm1hdG1hbigpLmFkZE1hdGVyaWFsKFxuICAgICAgICAnQUROLU1hdGVyaWFsLUxpbmUnLFxuICAgICAgICBfbWF0ZXJpYWwsXG4gICAgICAgIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdMaW5lcyhjb29yZHNBcnJheSwgbWF0KSB7XG5cbiAgICAgIHZhciBsaW5lcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkc0FycmF5Lmxlbmd0aDsgaSs9Mikge1xuXG4gICAgICAgIHZhciBzdGFydCA9IGNvb3Jkc0FycmF5W2ldO1xuICAgICAgICB2YXIgZW5kID0gY29vcmRzQXJyYXlbaSsxXTtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgIHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnopKTtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAgIGVuZC54LCBlbmQueSwgZW5kLnopKTtcblxuICAgICAgICBnZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdCk7XG5cbiAgICAgICAgdmlld2VyLmltcGwuc2NlbmUuYWRkKGxpbmUpO1xuXG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSBkcmF3TGluZXMoW1xuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWluLnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtaW4ueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWluLnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtaW4ueSwgejogbWF4Lnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWluLnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtaW4ueSwgejogbWF4Lnp9LFxuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWluLnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtaW4ueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWF4LnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtYXgueSwgejogbWF4Lnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWF4LnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtYXgueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWF4LnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtYXgueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWF4LnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtYXgueSwgejogbWF4Lnp9LFxuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWluLnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtYXgueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWluLnksIHo6IG1pbi56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtYXgueSwgejogbWluLnp9LFxuXG4gICAgICAgIHt4OiBtYXgueCwgeTogbWluLnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1heC54LCB5OiBtYXgueSwgejogbWF4Lnp9LFxuXG4gICAgICAgIHt4OiBtaW4ueCwgeTogbWluLnksIHo6IG1heC56fSxcbiAgICAgICAge3g6IG1pbi54LCB5OiBtYXgueSwgejogbWF4Lnp9XSxcblxuICAgICAgX21hdGVyaWFsKTtcblxuICAgIHZpZXdlci5pbXBsLnNjZW5lVXBkYXRlZCh0cnVlKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIFNldCBjb21wb25lbnQgbWF0ZXJpYWxcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGFzeW5jIHNldE1hdGVyaWFsKG1vZGVsLCBkYklkLCBtYXRlcmlhbCkge1xuXG4gICAgY29uc3QgZnJhZ0lkcyA9IGF3YWl0IFZpZXdlclRvb2xraXQuZ2V0RnJhZ0lkcyhcbiAgICAgIG1vZGVsLCBkYklkKVxuXG4gICAgY29uc3QgZnJhZ0xpc3QgPSBtb2RlbC5nZXRGcmFnbWVudExpc3QoKVxuXG4gICAgZnJhZ0lkcy5mb3JFYWNoKChmcmFnSWQpPT4ge1xuXG4gICAgICBmcmFnTGlzdC5zZXRNYXRlcmlhbChmcmFnSWQsIG1hdGVyaWFsKVxuICAgIH0pXG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBSZWN1cnNpdmVseSBidWlsZHMgdGhlIG1vZGVsIHRyZWVcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGJ1aWxkTW9kZWxUcmVlKG1vZGVsLCBjcmVhdGVOb2RlRnVuYyA9IG51bGwpe1xuXG4gICAgLy9idWlsZHMgbW9kZWwgdHJlZSByZWN1cnNpdmVseVxuICAgIGZ1bmN0aW9uIF9idWlsZE1vZGVsVHJlZVJlYyhub2RlKXtcblxuICAgICAgaW5zdGFuY2VUcmVlLmVudW1Ob2RlQ2hpbGRyZW4obm9kZS5kYklkLFxuICAgICAgICBmdW5jdGlvbihjaGlsZElkKSB7XG5cbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbnVsbDtcblxuICAgICAgICAgIGlmKGNyZWF0ZU5vZGVGdW5jKXtcblxuICAgICAgICAgICAgY2hpbGROb2RlID0gY3JlYXRlTm9kZUZ1bmMoY2hpbGRJZCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcblxuICAgICAgICAgICAgY2hpbGROb2RlID0ge1xuICAgICAgICAgICAgICBkYklkOiBjaGlsZElkLFxuICAgICAgICAgICAgICBuYW1lOiBpbnN0YW5jZVRyZWUuZ2V0Tm9kZU5hbWUoY2hpbGRJZClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2J1aWxkTW9kZWxUcmVlUmVjKGNoaWxkTm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vZ2V0IG1vZGVsIGluc3RhbmNlIHRyZWUgYW5kIHJvb3QgY29tcG9uZW50XG4gICAgdmFyIGluc3RhbmNlVHJlZSA9IG1vZGVsLmdldERhdGEoKS5pbnN0YW5jZVRyZWU7XG5cbiAgICB2YXIgcm9vdElkID0gaW5zdGFuY2VUcmVlLmdldFJvb3RJZCgpO1xuXG4gICAgdmFyIHJvb3ROb2RlID0ge1xuICAgICAgZGJJZDogcm9vdElkLFxuICAgICAgbmFtZTogaW5zdGFuY2VUcmVlLmdldE5vZGVOYW1lKHJvb3RJZClcbiAgICB9XG5cbiAgICBfYnVpbGRNb2RlbFRyZWVSZWMocm9vdE5vZGUpO1xuXG4gICAgcmV0dXJuIHJvb3ROb2RlO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gUmVjdXJzaXZlbHkgZXhlY3V0ZSB0YXNrIG9uIG1vZGVsIHRyZWVcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGV4ZWN1dGVUYXNrT25Nb2RlbFRyZWUobW9kZWwsIHRhc2spIHtcblxuICAgIHZhciB0YXNrUmVzdWx0cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVUYXNrT25Nb2RlbFRyZWVSZWMoZGJJZCl7XG5cbiAgICAgIGluc3RhbmNlVHJlZS5lbnVtTm9kZUNoaWxkcmVuKGRiSWQsXG4gICAgICAgIGZ1bmN0aW9uKGNoaWxkSWQpIHtcblxuICAgICAgICAgIHRhc2tSZXN1bHRzLnB1c2godGFzayhtb2RlbCwgY2hpbGRJZCkpO1xuXG4gICAgICAgICAgX2V4ZWN1dGVUYXNrT25Nb2RlbFRyZWVSZWMoY2hpbGRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vZ2V0IG1vZGVsIGluc3RhbmNlIHRyZWUgYW5kIHJvb3QgY29tcG9uZW50XG4gICAgdmFyIGluc3RhbmNlVHJlZSA9IG1vZGVsLmdldERhdGEoKS5pbnN0YW5jZVRyZWU7XG5cbiAgICB2YXIgcm9vdElkID0gaW5zdGFuY2VUcmVlLmdldFJvb3RJZCgpO1xuXG4gICAgX2V4ZWN1dGVUYXNrT25Nb2RlbFRyZWVSZWMocm9vdElkKTtcblxuICAgIHJldHVybiB0YXNrUmVzdWx0cztcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHN0YXRpYyBpc29sYXRlRnVsbCAodmlld2VyLCBtb2RlbCA9IG51bGwsIGRiSWRzID0gW10pIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyhyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgdHJ5IHtcblxuICAgICAgICBtb2RlbCA9IG1vZGVsIHx8IHZpZXdlci5tb2RlbFxuXG4gICAgICAgIHZpZXdlci5pc29sYXRlKGRiSWRzKVxuXG4gICAgICAgIGNvbnN0IHRhcmdldElkcyA9IEFycmF5LmlzQXJyYXkoZGJJZHMpID8gZGJJZHMgOiBbZGJJZHNdXG5cbiAgICAgICAgY29uc3QgdGFyZ2V0TGVhZklkcyA9IGF3YWl0IFZpZXdlclRvb2xraXQuZ2V0TGVhZk5vZGVzKFxuICAgICAgICAgIG1vZGVsLCB0YXJnZXRJZHMpXG5cbiAgICAgICAgY29uc3QgbGVhZklkcyA9IGF3YWl0IFZpZXdlclRvb2xraXQuZ2V0TGVhZk5vZGVzIChtb2RlbClcblxuICAgICAgICBjb25zdCBsZWFmVGFza3MgPSBsZWFmSWRzLm1hcCgoZGJJZCkgPT4ge1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlTGVhZikgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzaG93ID0gIXRhcmdldExlYWZJZHMubGVuZ3RoICB8fFxuICAgICAgICAgICAgICB0YXJnZXRMZWFmSWRzLmluZGV4T2YoZGJJZCkgPiAtMVxuXG4gICAgICAgICAgICB2aWV3ZXIuaW1wbC52aXNpYmlsaXR5TWFuYWdlci5zZXROb2RlT2ZmKFxuICAgICAgICAgICAgICBkYklkLCAhc2hvdylcblxuICAgICAgICAgICAgcmVzb2x2ZUxlYWYoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxlYWZUYXNrcylcblxuICAgICAgfSBjYXRjaChleCl7XG5cbiAgICAgICAgcmV0dXJuIHJlamVjdChleClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL1ZpZXdlci5Ub29sa2l0L1ZpZXdlci5Ub29sa2l0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");
},29:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function($) {"use strict";\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EventsEmitter2 = __webpack_require__(2);\n\nvar _EventsEmitter3 = _interopRequireDefault(_EventsEmitter2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /////////////////////////////////////////////////////////////\n// switch button\n//\n/////////////////////////////////////////////////////////////\n\n\nvar SwitchButton = function (_EventsEmitter) {\n  _inherits(SwitchButton, _EventsEmitter);\n\n  ///////////////////////////////////////////////////////////////////\n  //\n  //\n  ///////////////////////////////////////////////////////////////////\n  function SwitchButton(container) {\n    var checked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    _classCallCheck(this, SwitchButton);\n\n    var _this2 = _possibleConstructorReturn(this, (SwitchButton.__proto__ || Object.getPrototypeOf(SwitchButton)).call(this));\n\n    var _this = _this2;\n\n    var labelId = guid();\n\n    _this2._inputId = guid();\n\n    var html = "\\n        <p class=\\"onoffswitch\\">\\n          <input id=\\"" + _this2._inputId + "\\" type=\\"checkbox\\" name=\\"onoffswitch\\"\\n            class=\\"onoffswitch-checkbox\\" " + (checked ? "checked" : "") + ">\\n          <label id=\\"" + labelId + "\\" class=\\"onoffswitch-label\\">\\n            <span class=\\"onoffswitch-inner\\"></span>\\n            <span class=\\"onoffswitch-switch\\"></span>\\n          </label>\\n        </p>\\n      ";\n\n    $(container).append(html);\n\n    $(\'#\' + labelId).click(function (e) {\n\n      var $input = $(\'#\' + _this2._inputId)[0];\n\n      $input.checked = !$input.checked;\n\n      _this.emit(\'checked\', $input.checked);\n    });\n    return _this2;\n  }\n\n  ///////////////////////////////////////////////////////////////////\n  //\n  //\n  ///////////////////////////////////////////////////////////////////\n\n\n  _createClass(SwitchButton, [{\n    key: "checked",\n    value: function checked() {\n\n      return $(\'#\' + this._inputId)[0].checked;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n    //\n    //\n    ///////////////////////////////////////////////////////////////////\n\n  }, {\n    key: "setChecked",\n    value: function setChecked(checked) {\n\n      $(\'#\' + this._inputId).prop(\'checked\', checked);\n\n      this.emit(\'checked\', checked);\n    }\n  }]);\n\n  return SwitchButton;\n}(_EventsEmitter3.default);\n\nexports.default = SwitchButton;\n\n\nfunction guid() {\n\n  var d = new Date().getTime();\n\n  var guid = \'xxxx-xxxx-xxxx-xxxx\'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == \'x\' ? r : r & 0x7 | 0x8).toString(16);\n  });\n\n  return guid;\n}\n\n//https://proto.io/freebies/onoff/\nvar css = "\\n\\n  .onoffswitch {\\n    position: relative; width: 50px;\\n    -webkit-user-select:none; -moz-user-select:none; -ms-user-select: none;\\n  }\\n  .onoffswitch-checkbox {\\n    display: none;\\n  }\\n  .onoffswitch-label {\\n    display: block; overflow: hidden; cursor: pointer;\\n    border: 2px solid #999999; border-radius: 8px;\\n  }\\n  .onoffswitch-inner {\\n    display: block; width: 200%; margin-left: -100%;\\n    transition: margin 0.3s ease-in 0s;\\n  }\\n  .onoffswitch-inner:before, .onoffswitch-inner:after {\\n    display: block;\\n    float: left;\\n    width: 50%;\\n    height: 15px;\\n    padding: 0;\\n    line-height: 15px;\\n    font-size: 10px;\\n    color: white;\\n    font-family: Trebuchet, Arial, sans-serif;\\n    font-weight: bold;\\n    box-sizing: border-box;\\n  }\\n  .onoffswitch-inner:before {\\n    content: \\"ON\\";\\n    background-color: #0E8200;\\n    color: #FFFFFF;\\n  }\\n  .onoffswitch-inner:after {\\n    content: \\"OFF\\";\\n    padding-right: 10px;\\n    background-color: #d9534f;\\n    color: #FFFFFF;\\n    text-align: right;\\n  }\\n  .onoffswitch-switch {\\n    display: block;\\n    width: 12px;\\n    margin: 2px;\\n    background: #FFFFFF;\\n    position: absolute;\\n    top: 0;\\n    bottom: 0;\\n    right: 31px;\\n    border: 2px solid #999999;\\n    border-radius: 8px;\\n    transition: all 0.3s ease-in 0s;\\n  }\\n  .onoffswitch-checkbox:checked + .onoffswitch-label .onoffswitch-inner {\\n    margin-left: 0;\\n  }\\n  .onoffswitch-checkbox:checked + .onoffswitch-label .onoffswitch-switch {\\n    right: -1px;\\n  }\\n";\n\n$(\'<style type="text/css">\' + css + \'</style>\').appendTo(\'head\');\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Td2l0Y2hCdXR0b24vU3dpdGNoQnV0dG9uLmpzP2Y0YmMiXSwibmFtZXMiOlsiU3dpdGNoQnV0dG9uIiwiY29udGFpbmVyIiwiY2hlY2tlZCIsIl90aGlzIiwibGFiZWxJZCIsImd1aWQiLCJfaW5wdXRJZCIsImh0bWwiLCIkIiwiYXBwZW5kIiwiY2xpY2siLCJlIiwiJGlucHV0IiwiZW1pdCIsInByb3AiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJ0b1N0cmluZyIsImNzcyIsImFwcGVuZFRvIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUlBOzs7Ozs7Ozs7OytlQUpBO0FBQ0E7QUFDQTtBQUNBOzs7SUFHcUJBLFk7OztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFZQyxTQUFaLEVBQXNDO0FBQUEsUUFBZkMsT0FBZSx1RUFBTCxJQUFLOztBQUFBOztBQUFBOztBQUlwQyxRQUFJQyxjQUFKOztBQUVBLFFBQUlDLFVBQVVDLE1BQWQ7O0FBRUEsV0FBS0MsUUFBTCxHQUFnQkQsTUFBaEI7O0FBRUEsUUFBSUUsdUVBRWUsT0FBS0QsUUFGcEIsK0ZBR21DSixVQUFRLFNBQVIsR0FBa0IsRUFIckQsa0NBSWVFLE9BSmYsNkxBQUo7O0FBV0FJLE1BQUVQLFNBQUYsRUFBYVEsTUFBYixDQUFvQkYsSUFBcEI7O0FBRUFDLE1BQUUsTUFBTUosT0FBUixFQUFpQk0sS0FBakIsQ0FBdUIsVUFBQ0MsQ0FBRCxFQUFLOztBQUUxQixVQUFJQyxTQUFTSixFQUFFLE1BQU0sT0FBS0YsUUFBYixFQUF1QixDQUF2QixDQUFiOztBQUVBTSxhQUFPVixPQUFQLEdBQWlCLENBQUNVLE9BQU9WLE9BQXpCOztBQUVBQyxZQUFNVSxJQUFOLENBQVcsU0FBWCxFQUFzQkQsT0FBT1YsT0FBN0I7QUFDRCxLQVBEO0FBdkJvQztBQStCckM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7Ozs7OzhCQUNVOztBQUVSLGFBQVFNLEVBQUUsTUFBTSxLQUFLRixRQUFiLEVBQXVCLENBQXZCLEVBQTBCSixPQUFsQztBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7OytCQUNXQSxPLEVBQVM7O0FBRWxCTSxRQUFFLE1BQU0sS0FBS0YsUUFBYixFQUF1QlEsSUFBdkIsQ0FDRSxTQURGLEVBQ2FaLE9BRGI7O0FBR0EsV0FBS1csSUFBTCxDQUFVLFNBQVYsRUFBcUJYLE9BQXJCO0FBQ0Q7Ozs7OztrQkExRGtCRixZOzs7QUE2RHJCLFNBQVNLLElBQVQsR0FBZ0I7O0FBRWQsTUFBSVUsSUFBSSxJQUFJQyxJQUFKLEdBQVdDLE9BQVgsRUFBUjs7QUFFQSxNQUFJWixPQUFPLHNCQUFzQmEsT0FBdEIsQ0FDVCxPQURTLEVBRVQsVUFBVUMsQ0FBVixFQUFhO0FBQ1gsUUFBSUMsSUFBSSxDQUFDTCxJQUFJTSxLQUFLQyxNQUFMLEtBQWdCLEVBQXJCLElBQTJCLEVBQTNCLEdBQWdDLENBQXhDO0FBQ0FQLFFBQUlNLEtBQUtFLEtBQUwsQ0FBV1IsSUFBSSxFQUFmLENBQUo7QUFDQSxXQUFPLENBQUNJLEtBQUssR0FBTCxHQUFXQyxDQUFYLEdBQWdCQSxJQUFJLEdBQUosR0FBVSxHQUEzQixFQUFpQ0ksUUFBakMsQ0FBMEMsRUFBMUMsQ0FBUDtBQUNELEdBTlEsQ0FBWDs7QUFRQSxTQUFPbkIsSUFBUDtBQUNEOztBQUVEO0FBQ0EsSUFBSW9CLCsvQ0FBSjs7QUErREFqQixFQUFFLDRCQUE0QmlCLEdBQTVCLEdBQWtDLFVBQXBDLEVBQWdEQyxRQUFoRCxDQUF5RCxNQUF6RCxFIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3dpdGNoIGJ1dHRvblxuLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmltcG9ydCBFdmVudHNFbWl0dGVyIGZyb20gJ0V2ZW50c0VtaXR0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hCdXR0b24gZXh0ZW5kcyBFdmVudHNFbWl0dGVyIHtcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgY29uc3RydWN0b3IoY29udGFpbmVyLCBjaGVja2VkID0gdHJ1ZSl7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBsYWJlbElkID0gZ3VpZCgpO1xuXG4gICAgdGhpcy5faW5wdXRJZCA9IGd1aWQoKTtcblxuICAgIHZhciBodG1sID0gYFxuICAgICAgICA8cCBjbGFzcz1cIm9ub2Zmc3dpdGNoXCI+XG4gICAgICAgICAgPGlucHV0IGlkPVwiJHt0aGlzLl9pbnB1dElkfVwiIHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJvbm9mZnN3aXRjaFwiXG4gICAgICAgICAgICBjbGFzcz1cIm9ub2Zmc3dpdGNoLWNoZWNrYm94XCIgJHtjaGVja2VkP1wiY2hlY2tlZFwiOlwiXCJ9PlxuICAgICAgICAgIDxsYWJlbCBpZD1cIiR7bGFiZWxJZH1cIiBjbGFzcz1cIm9ub2Zmc3dpdGNoLWxhYmVsXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm9ub2Zmc3dpdGNoLWlubmVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvbm9mZnN3aXRjaC1zd2l0Y2hcIj48L3NwYW4+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9wPlxuICAgICAgYDtcblxuICAgICQoY29udGFpbmVyKS5hcHBlbmQoaHRtbCk7XG5cbiAgICAkKCcjJyArIGxhYmVsSWQpLmNsaWNrKChlKT0+e1xuXG4gICAgICB2YXIgJGlucHV0ID0gJCgnIycgKyB0aGlzLl9pbnB1dElkKVswXTtcblxuICAgICAgJGlucHV0LmNoZWNrZWQgPSAhJGlucHV0LmNoZWNrZWQ7XG5cbiAgICAgIF90aGlzLmVtaXQoJ2NoZWNrZWQnLCAkaW5wdXQuY2hlY2tlZCk7XG4gICAgfSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgY2hlY2tlZCgpIHtcblxuICAgIHJldHVybiAgJCgnIycgKyB0aGlzLl9pbnB1dElkKVswXS5jaGVja2VkO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuXG4gICAgJCgnIycgKyB0aGlzLl9pbnB1dElkKS5wcm9wKFxuICAgICAgJ2NoZWNrZWQnLCBjaGVja2VkKTtcblxuICAgIHRoaXMuZW1pdCgnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGd1aWQoKSB7XG5cbiAgdmFyIGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICB2YXIgZ3VpZCA9ICd4eHh4LXh4eHgteHh4eC14eHh4Jy5yZXBsYWNlKFxuICAgIC9beHldL2csXG4gICAgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHZhciByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDcgfCAweDgpKS50b1N0cmluZygxNik7XG4gICAgfSk7XG5cbiAgcmV0dXJuIGd1aWQ7XG59XG5cbi8vaHR0cHM6Ly9wcm90by5pby9mcmVlYmllcy9vbm9mZi9cbnZhciBjc3MgPSBgXG5cbiAgLm9ub2Zmc3dpdGNoIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiA1MHB4O1xuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTsgLW1vei11c2VyLXNlbGVjdDpub25lOyAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIH1cbiAgLm9ub2Zmc3dpdGNoLWNoZWNrYm94IHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG4gIC5vbm9mZnN3aXRjaC1sYWJlbCB7XG4gICAgZGlzcGxheTogYmxvY2s7IG92ZXJmbG93OiBoaWRkZW47IGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjOTk5OTk5OyBib3JkZXItcmFkaXVzOiA4cHg7XG4gIH1cbiAgLm9ub2Zmc3dpdGNoLWlubmVyIHtcbiAgICBkaXNwbGF5OiBibG9jazsgd2lkdGg6IDIwMCU7IG1hcmdpbi1sZWZ0OiAtMTAwJTtcbiAgICB0cmFuc2l0aW9uOiBtYXJnaW4gMC4zcyBlYXNlLWluIDBzO1xuICB9XG4gIC5vbm9mZnN3aXRjaC1pbm5lcjpiZWZvcmUsIC5vbm9mZnN3aXRjaC1pbm5lcjphZnRlciB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgZmxvYXQ6IGxlZnQ7XG4gICAgd2lkdGg6IDUwJTtcbiAgICBoZWlnaHQ6IDE1cHg7XG4gICAgcGFkZGluZzogMDtcbiAgICBsaW5lLWhlaWdodDogMTVweDtcbiAgICBmb250LXNpemU6IDEwcHg7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtZmFtaWx5OiBUcmVidWNoZXQsIEFyaWFsLCBzYW5zLXNlcmlmO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbiAgLm9ub2Zmc3dpdGNoLWlubmVyOmJlZm9yZSB7XG4gICAgY29udGVudDogXCJPTlwiO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMwRTgyMDA7XG4gICAgY29sb3I6ICNGRkZGRkY7XG4gIH1cbiAgLm9ub2Zmc3dpdGNoLWlubmVyOmFmdGVyIHtcbiAgICBjb250ZW50OiBcIk9GRlwiO1xuICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2Q5NTM0ZjtcbiAgICBjb2xvcjogI0ZGRkZGRjtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgfVxuICAub25vZmZzd2l0Y2gtc3dpdGNoIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB3aWR0aDogMTJweDtcbiAgICBtYXJnaW46IDJweDtcbiAgICBiYWNrZ3JvdW5kOiAjRkZGRkZGO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHJpZ2h0OiAzMXB4O1xuICAgIGJvcmRlcjogMnB4IHNvbGlkICM5OTk5OTk7XG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2UtaW4gMHM7XG4gIH1cbiAgLm9ub2Zmc3dpdGNoLWNoZWNrYm94OmNoZWNrZWQgKyAub25vZmZzd2l0Y2gtbGFiZWwgLm9ub2Zmc3dpdGNoLWlubmVyIHtcbiAgICBtYXJnaW4tbGVmdDogMDtcbiAgfVxuICAub25vZmZzd2l0Y2gtY2hlY2tib3g6Y2hlY2tlZCArIC5vbm9mZnN3aXRjaC1sYWJlbCAub25vZmZzd2l0Y2gtc3dpdGNoIHtcbiAgICByaWdodDogLTFweDtcbiAgfVxuYDtcblxuJCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicgKyBjc3MgKyAnPC9zdHlsZT4nKS5hcHBlbmRUbygnaGVhZCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvU3dpdGNoQnV0dG9uL1N3aXRjaEJ1dHRvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},30:function(module,exports,__webpack_require__){eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SwitchButton = __webpack_require__(29);\n\nvar _SwitchButton2 = _interopRequireDefault(_SwitchButton);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _SwitchButton2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Td2l0Y2hCdXR0b24vaW5kZXguanM/MDg0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTd2l0Y2hCdXR0b24gZnJvbSAnLi9Td2l0Y2hCdXR0b24nXG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaEJ1dHRvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvU3dpdGNoQnV0dG9uL2luZGV4LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},145:function(module,exports){eval("'use strict';\n\n(function () {\n    'use strict';\n\n    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core.Utils');\n\n    /**\n     *\n     * @param markupType\n     * @returns {*}\n     */\n    namespace.getTypeString = function (markupType) {\n\n        var core = Autodesk.Viewing.Extensions.Markups.Core;\n        switch (markupType) {\n            case core.MARKUP_TYPE_TEXT:\n                return core.MARKUP_EXPORT_TYPE_LABEL;\n            case core.MARKUP_TYPE_ARROW:\n                return core.MARKUP_EXPORT_TYPE_ARROW;\n            case core.MARKUP_TYPE_RECTANGLE:\n                return core.MARKUP_EXPORT_TYPE_RECTANGLE;\n            case core.MARKUP_TYPE_CIRCLE:\n                return core.MARKUP_EXPORT_TYPE_CIRCLE;\n            case core.MARKUP_TYPE_CLOUD:\n                return core.MARKUP_EXPORT_TYPE_CLOUD;\n            case core.MARKUP_TYPE_FREEHAND:\n                return core.MARKUP_EXPORT_TYPE_FREEHAND;\n        }\n        return 'Unknown(' + id + ')';\n    };\n\n    /**\n     * // isTouchDevice is an LMV function. Hammer is included by LMV as well\n     * @returns {boolean}\n     */\n    namespace.isTouchDevice = function () {\n        // isTouchDevice() is an LMV function.\n        // Hammer (a touch detection lib) is packaged with LMV as well\n        if (typeof isTouchDevice === \"function\" && typeof Hammer === \"function\") {\n            return isTouchDevice();\n        }\n        return false;\n    };\n\n    //// SVG  //////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    namespace.createSvgElement = function (type) {\n\n        // See https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS\n        var namespace = 'http://www.w3.org/2000/svg';\n        var svg = document.createElementNS(namespace, type);\n        svg.setAttribute('pointer-events', 'inherit');\n\n        return svg;\n    };\n\n    /**\n     *\n     * @param {Element} svg - an SVGElement\n     * @returns {Element} svg param is returned back\n     */\n    namespace.setSvgParentAttributes = function (svg) {\n\n        // See: https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course\n        svg.setAttribute('version', '1.1'); // Notice that this is the SVG version, not the \"MARKUP DATA VERSION\"!\n        svg.setAttribute('baseProfile', 'full');\n        return svg;\n    };\n\n    /**\n     * Helper function that injects metadata for the whole Markup document.\n     * Metadata includes: version.\n     * @param {Element} svg - an SVGElement\n     * @param {Object} metadata - Dictionary with attributes\n     */\n    namespace.addSvgMetadata = function (svg, metadata) {\n\n        var metadataNode = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        var dataVersionNode = document.createElement('markup_document');\n\n        metadataNode.appendChild(dataVersionNode);\n\n        // NOTE: We could iterate over the properties, but we don't because these are the only ones supported\n        dataVersionNode.setAttribute(\"data-model-version\", metadata[\"data-model-version\"]); // Version. For example: \"1\"\n\n        svg.insertBefore(metadataNode, svg.firstChild);\n        return metadataNode;\n    };\n\n    /**\n     * Helper function that injects metadata for specific markup svg nodes.\n     * @param {Element} markupNode - an SVGElement for the markup\n     * @param {Object} metadata - Dictionary where all key/value pairs are added as metadata entries.\n     * @returns {Element}\n     */\n    namespace.addMarkupMetadata = function (markupNode, metadata) {\n\n        var metadataNode = document.createElementNS('http://www.w3.org/2000/svg', 'metadata');\n        var dataVersionNode = document.createElement('markup_element');\n\n        metadataNode.appendChild(dataVersionNode);\n        for (var key in metadata) {\n            if (metadata.hasOwnProperty(key)) {\n                dataVersionNode.setAttribute(key, metadata[key]);\n            }\n        }\n\n        markupNode.insertBefore(metadataNode, markupNode.firstChild);\n        return metadataNode;\n    };\n\n    /**\n     * Removes al metadata nodes from an Svg node structure.\n     * Method will remove all metadata nodes from children nodes as well.\n     * @param svgNode\n     */\n    namespace.removeAllMetadata = function (svgNode) {\n\n        var nodes = svgNode.getElementsByTagName(\"metadata\");\n        for (var i = 0; i < nodes.length; ++i) {\n            var metadataNode = nodes[i];\n            metadataNode.parentNode && metadataNode.parentNode.removeChild(metadataNode);\n        }\n\n        // Transverse children nodes\n        var svgChildren = svgNode.children || svgNode.childNodes;\n        for (i = 0; i < svgChildren.length; ++i) {\n            this.removeAllMetadata(svgChildren[i]);\n        }\n    };\n\n    /**\n     * Utility function that transfers children from an Html/Svg node into another one.\n     * @param nodeFrom - The node instance from where children will be taken.\n     * @param nodeInto - The node that's going to parent the transferred children.\n     */\n    namespace.transferChildNodes = function (nodeFrom, nodeInto) {\n        var svgChildren = nodeFrom.children || nodeFrom.childNodes;\n        var tmpArray = [];\n        for (var i = 0; i < svgChildren.length; ++i) {\n            tmpArray.push(svgChildren[i]); // Avoid appendChild\n        }\n        tmpArray.forEach(function (node) {\n            nodeInto.appendChild(node);\n        });\n    };\n\n    /**\n     * Serializes an SVG node into a String.\n     * @param domNode\n     * @returns {string}\n     */\n    namespace.svgNodeToString = function (domNode) {\n\n        var result;\n        try {\n            var xmlSerializer = new XMLSerializer();\n            result = xmlSerializer.serializeToString(domNode);\n        } catch (err) {\n            result = '';\n            console.warn('svgNodeToString failed to generate string representation of domNode.');\n        }\n        return result;\n    };\n\n    namespace.stringToSvgNode = function (stringNode) {\n\n        var node = null;\n        try {\n            var domParser = new DOMParser();\n            var doc = domParser.parseFromString(stringNode, \"text/xml\");\n            node = doc.firstChild; // We should only be getting 1 child anyway.\n        } catch (err) {\n            node = null;\n            console.warn('stringToSvgNode failed to generate an HTMLElement from its string representation.');\n        }\n        return node;\n    };\n\n    /**\n     * Injects functions and members to a client object which will\n     * receive the ability to dispatch events.\n     * Mechanism is the same as in Autodesk.Viewing.Viewer.\n     *\n     * Note: All of the code here comes from Autodesk.Viewing.Viewer\n     *\n     * @param {Object} client - Object that will become an event dispatcher.\n     */\n    namespace.addTraitEventDispatcher = function (client) {\n\n        // Inject member variable\n        client.listeners = {};\n\n        // Inject functions\n        client.addEventListener = function (type, listener) {\n            if (typeof this.listeners[type] == \"undefined\") {\n                this.listeners[type] = [];\n            }\n            this.listeners[type].push(listener);\n        };\n        client.hasEventListener = function (type, listener) {\n            if (this.listeners === undefined) return false;\n            var listeners = this.listeners;\n            if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {\n                return true;\n            }\n            return false;\n        };\n        client.removeEventListener = function (type, listener) {\n            if (this.listeners[type] instanceof Array) {\n                var li = this.listeners[type];\n                for (var i = 0, len = li.length; i < len; i++) {\n                    if (li[i] === listener) {\n                        li.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        };\n        client.fireEvent = function (event) {\n            if (typeof event == \"string\") {\n                event = { type: event };\n            }\n            if (!event.target) {\n                event.target = this;\n            }\n\n            if (!event.type) {\n                throw new Error(\"event type unknown.\");\n            }\n\n            if (this.listeners[event.type] instanceof Array) {\n                var typeListeners = this.listeners[event.type].slice();\n                for (var i = 0; i < typeListeners.length; i++) {\n                    typeListeners[i].call(this, event);\n                }\n            }\n        };\n    };\n\n    /**\n     * Removes the EventDispatcher trait\n     *\n     * @param {Object} client\n     */\n    namespace.removeTraitEventDispatcher = function (client) {\n\n        try {\n            delete client.listeners;\n            delete client.addEventListener;\n            delete client.hasEventListener;\n            delete client.removeEventListener;\n            delete client.fireEvent;\n        } catch (e) {\n            // nothing\n        }\n    };\n\n    //// Math  /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Calculates the pixel position in client space coordinates of a point in world space.\n     * @param {THREE.Vector3} point Point in world space coordinates.\n     * @param viewer\n     * @param snap Round values to closest pixel center.\n     * @returns {THREE.Vector3} Point transformed and projected into client space coordinates.\n     */\n    namespace.worldToClient = function (point, viewer, snap) {\n\n        var p = namespace.worldToViewport(point, viewer);\n        var result = viewer.impl.viewportToClient(p.x, p.y);\n        result.z = 0;\n\n        // snap to the center of the\n        if (snap) {\n            result.x = Math.floor(result.x) + 0.5;\n            result.y = Math.floor(result.y) + 0.5;\n        }\n\n        return result;\n    };\n\n    namespace.clientToWorld = function (clientX, clientY, depth, viewer) {\n\n        var point = viewer.impl.clientToViewport(clientX, clientY);\n        point.z = depth;\n\n        point.unproject(viewer.impl.camera);\n        return point;\n    };\n\n    /**\n     * Calculates the world position of a point in client space coordinates.\n     * @param {Object} point - { x:Number, y:Number, z:Number }\n     * @param {Object} viewer - LMV instance\n     * @returns {THREE.Vector3}\n     */\n    namespace.worldToViewport = function (point, viewer) {\n\n        var p = new THREE.Vector3();\n\n        p.x = point.x;\n        p.y = point.y;\n        p.z = point.z;\n\n        p.project(viewer.impl.camera);\n        return p;\n    };\n\n    namespace.metersToModel = function (meters, viewer) {\n\n        var modelToMeter = viewer.model.getUnitScale();\n        var meterToModel = 1 / modelToMeter;\n\n        return meterToModel * meters;\n    };\n\n    namespace.radiansToDegrees = function (radians) {\n\n        return radians * (180 / Math.PI);\n    };\n\n    namespace.degreesToRadians = function (degrees) {\n\n        return degrees * (Math.PI / 180);\n    };\n\n    /**\n     *\n     * @param value\n     * @returns {number}\n     */\n    namespace.sign = function (value) {\n\n        return value >= 0 ? 1 : -1;\n    };\n\n    //// LMV Viewer ////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Makes sure LMV's camera is set to Orthographic.\n     * Only works with 3d models; will do nothing when a 2d model is loaded.\n     * @param {Object} viewer - LMV instance\n     */\n    namespace.forceOrthographicCamera = function (viewer) {\n\n        if (!viewer || !viewer.navigation || viewer.model.is2d()) return;\n\n        var navApi = viewer.navigation;\n        var camera = navApi.getCamera();\n\n        if (camera.isPerspective) {\n            navApi.toOrthographic();\n        }\n    };\n\n    //// LMV ui ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    namespace.hideLmvUi = function (viewer) {\n\n        // Exit other tools and hide HudMessages.\n        viewer.setActiveNavigationTool();\n\n        namespace.dismissLmvHudMessage();\n        namespace.hideLmvPanels(true, viewer);\n        namespace.hideLmvToolsAndPanels(viewer);\n    };\n\n    namespace.restoreLmvUi = function (viewer) {\n\n        namespace.dismissLmvHudMessage();\n        namespace.hideLmvPanels(false, viewer);\n        namespace.showLmvToolsAndPanels(viewer);\n    };\n\n    /**\n     *\n     * @param hide\n     * @param viewer\n     */\n    namespace.hideLmvPanels = function (hide, viewer) {\n\n        var dockingPanels = viewer.dockingPanels;\n\n        // Panels may not be present when dealing with an instance of Viewer3D.js\n        // (as opposed to an instance of GuiViewer3D.js)\n        if (!dockingPanels) return;\n\n        for (var i = 0; i < dockingPanels.length; ++i) {\n\n            var panel = dockingPanels[i];\n            var panelContainer = panel.container;\n\n            if (panelContainer.classList.contains(\"dockingPanelVisible\")) {\n                panelContainer.style.display = hide ? \"none\" : \"block\";\n\n                // Call the visibility changed notification if any additional\n                // stuff needs to be done (update the date i.e. PropertyPanel, etc).\n                panel.visibilityChanged();\n            }\n        }\n    };\n\n    /**\n     * Shows panels and tools in the viewer.\n     * @param viewer\n     */\n    namespace.showLmvToolsAndPanels = function (viewer) {\n\n        // Restore view cube.\n        if (!viewer.model.is2d()) {\n            viewer.displayViewCube(true, false);\n        }\n\n        // TODO: Find or ask for a better way to restore this buttons.\n        // Hide home and info button.\n        var home = document.getElementsByClassName('homeViewWrapper');\n        var info = document.getElementsByClassName('infoButton');\n        var anim = document.getElementsByClassName('toolbar-animationSubtoolbar');\n\n        if (home.length > 0) {\n            home[0].style.display = '';\n        }\n\n        if (info.length > 0) {\n            info[0].style.display = '';\n        }\n\n        if (anim.length > 0) {\n            anim[0].style.display = '';\n        }\n\n        // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)\n        if (viewer.toolbar) {\n            var viewerContainer = viewer.toolbar.container;\n            var viewerContainerChildrenCount = viewerContainer.children.length;\n            for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n                viewerContainer.children[i].style.display = \"\";\n            }\n        }\n    };\n\n    /**\n     * Hides panels and tools in the viewer.\n     * @param viewer\n     */\n    namespace.hideLmvToolsAndPanels = function (viewer) {\n\n        // Hide Panels and tools.\n        if (viewer && viewer.model && !viewer.model.is2d()) {\n            viewer.displayViewCube(false, false);\n        }\n\n        // TODO: Find or ask for a better way to hide this buttons.\n        // Hide home and info button.\n        var home = document.getElementsByClassName('homeViewWrapper');\n        var info = document.getElementsByClassName('infoButton');\n        var anim = document.getElementsByClassName('toolbar-animationSubtoolbar');\n\n        if (home.length > 0) {\n            home[0].style.display = 'none';\n        }\n\n        if (info.length > 0) {\n            info[0].style.display = 'none';\n        }\n\n        if (anim.length > 0) {\n            anim[0].style.display = 'none';\n\n            var animator = viewer.impl.keyFrameAnimator;\n            if (animator && !animator.isPaused) {\n                animator.pauseCameraAnimations();\n                animator.pause();\n\n                var playButton = viewer.modelTools.getControl('toolbar-animationPlay');\n                if (playButton) {\n                    playButton.setIcon('toolbar-animationPauseIcon');\n                    playButton.setToolTip('Pause');\n                }\n            }\n        }\n\n        // toolbar is absent when dealing with an instance of Viewer3D (instead of GuiViewer3D)\n        if (viewer.toolbar) {\n            var viewerContainer = viewer.toolbar.container;\n            var viewerContainerChildrenCount = viewerContainer.children.length;\n            for (var i = 0; i < viewerContainerChildrenCount; ++i) {\n                viewerContainer.children[i].style.display = \"none\";\n            }\n        }\n    };\n\n    /**\n     * Dismisses all LMV HudMessages\n     */\n    namespace.dismissLmvHudMessage = function () {\n\n        // Using try/catch block since we are accessing the Private namespace of LMV.\n        try {\n            var keepDismissing = true;\n            while (keepDismissing) {\n                keepDismissing = Autodesk.Viewing.Private.HudMessage.dismiss();\n            }\n        } catch (ignore) {\n            // Failing to show the message is an okay fallback scenario\n            console.warn(\"[CO2]Failed to dismiss LMV HudMessage\");\n        }\n    };\n\n    //// Styles ////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    namespace.createStyle = function (attributes, viewer) {\n\n        var style = {};\n\n        for (var i = 0; i < attributes.length; ++i) {\n\n            style[attributes[i]] = null;\n        }\n\n        var defaults = namespace.getStyleDefaultValues(style, viewer);\n\n        for (var i = 0; i < attributes.length; ++i) {\n\n            var attribute = attributes[i];\n            style[attribute] = defaults[attribute].values[defaults[attribute].default].value;\n        }\n\n        return style;\n    };\n\n    /**\n     *\n     * @param source\n     * @param destination\n     */\n    namespace.copyStyle = function (source, destination) {\n\n        for (var attribute in destination) {\n            if (source.hasOwnProperty(attribute)) {\n                destination[attribute] = source[attribute];\n            }\n        }\n    };\n\n    /**\n     *\n     * @param source\n     * @returns {{}}\n     */\n    namespace.cloneStyle = function (source) {\n\n        var clone = {};\n\n        for (var attribute in source) {\n            clone[attribute] = source[attribute];\n        }\n\n        return clone;\n    };\n\n    /**\n     *\n     * @param style\n     * @param viewer\n     * @returns {{}}\n     */\n    namespace.getStyleDefaultValues = function (style, viewer) {\n\n        function getStrokeWidth(viewer) {\n\n            var width = 0;\n            var data = viewer.model.getData();\n\n            if (data.is2d) {\n                width = namespace.metersToModel(0.0254, viewer) * 2; // 0.0254 m == 1 inch\n            } else {\n\n                var a = viewer.impl.viewportToClient(0.00, 0.00);\n                var b = viewer.impl.viewportToClient(0.01, 0.01);\n\n                a = namespace.clientToWorld(a.x, a.y, 0, viewer);\n                b = namespace.clientToWorld(b.x, b.y, 0, viewer);\n\n                width = Math.abs(b.y - a.y);\n            }\n            return width;\n        }\n\n        function getWidths(smallWidth) {\n\n            return {\n                values: [{ name: 'Thin', value: smallWidth }, { name: 'Normal', value: smallWidth * 3 }, { name: 'Thick', value: smallWidth * 9 }],\n                default: 1\n            };\n        }\n\n        function getFontSizes(smallWidth) {\n\n            return {\n                values: [{ name: 'Thin', value: smallWidth * 5 }, { name: 'Normal', value: smallWidth * 10 }, { name: 'Thick', value: smallWidth * 20 }],\n                default: 1\n            };\n        }\n\n        function getColors() {\n\n            return {\n                values: [{ name: 'red', value: '#ff0000' }, { name: 'green', value: '#00ff00' }, { name: 'blue', value: '#0000ff' }, { name: 'white', value: '#ffffff' }, { name: 'black', value: '#000000' }],\n                default: 0\n            };\n        }\n\n        function getOpacities(defaultTransparent) {\n\n            return {\n                values: [{ name: '100%', value: 1.00 }, { name: '75%', value: 0.75 }, { name: '50%', value: 0.50 }, { name: '25%', value: 0.25 }, { name: '0%', value: 0.00 }],\n                default: defaultTransparent ? 4 : 0\n            };\n        }\n\n        function getFontFamilies() {\n\n            // TODO: Localize?\n            // TODO: Validate fonts with design\n            // Source: http://www.webdesigndev.com/web-development/16-gorgeous-web-safe-fonts-to-use-with-css\n            return {\n                values: [{ name: 'Arial', value: 'Arial' }, { name: 'Arial Black', value: 'Arial Black' }, { name: 'Arial Narrow', value: 'Arial Narrow' }, { name: 'Century Gothic', value: 'Century Gothic' }, { name: 'Courier New', value: 'Courier New' }, { name: 'Georgia', value: 'Georgia' }, { name: 'Impact', value: 'Impact' }, { name: 'Lucida Console', value: 'Lucida Console' }, { name: 'Tahoma', value: 'Tahoma' }, { name: 'Verdana', value: 'Verdana' }],\n                default: 0\n            };\n        }\n\n        function getFontStyles() {\n            return {\n                values: [{ name: 'Normal', value: false }, { name: 'Italic', value: true }],\n                default: 0\n            };\n        }\n\n        function getFontWeights() {\n            return {\n                values: [{ name: 'Normal', value: false }, { name: 'Bold', value: true }],\n                default: 0 };\n        }\n\n        var values = namespace.cloneStyle(style);\n        var smallWidth = getStrokeWidth(viewer);\n\n        for (var attribute in values) {\n\n            switch (attribute) {\n                case 'stroke-width':\n                    values[attribute] = getWidths(smallWidth);\n                    break;\n\n                case 'font-size':\n                    values[attribute] = getFontSizes(smallWidth);\n                    break;\n\n                case 'font-family':\n                    values[attribute] = getFontFamilies();\n                    break;\n\n                case 'font-style':\n                    values[attribute] = getFontStyles();\n                    break;\n\n                case 'font-weight':\n                    values[attribute] = getFontWeights();\n                    break;\n\n                case 'stroke-color':\n                case 'fill-color':\n                    values[attribute] = getColors();\n                    break;\n\n                case 'stroke-opacity':\n                    var defaultTransparent = false;\n                    values[attribute] = getOpacities(defaultTransparent);\n                    break;\n\n                case 'fill-opacity':\n                    var defaultTransparent = true;\n                    values[attribute] = getOpacities(defaultTransparent);\n                    break;\n\n                default:\n                    break;\n            }\n        }\n\n        return values;\n    };\n\n    namespace.composeRGBAString = function (hexRGBString, opacity) {\n\n        if (opacity <= 0) {\n            return 'none';\n        }\n\n        var rgba = ['rgba(' + parseInt('0x' + hexRGBString.substr(1, 2)), ',', parseInt('0x' + hexRGBString.substr(3, 2)), ',', parseInt('0x' + hexRGBString.substr(5, 2)), ',', opacity, ')'].join('');\n\n        return rgba;\n    };\n})();\n\n(function () {\n    'use strict';\n\n    AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core');\n\n    /**\n     * @class\n     * Base class for all EditActions.<br>\n     * EditActions encapsulate {@link Autodesk.Viewing.Extensions.Markups.Core.Markup  Markup}\n     * operations (such as creation, edition and deletion) that hook into the undo/redo system.\n     *\n     * The minimum set of methods to implement on an EditAction extension are:\n     * - execute()\n     * - undo()\n     * - redo()\n     *\n     * A good set of classes to check their implementation are:\n     * - [CreateCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.CreateCircle}.\n     * - [DeleteCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.DeleteCircle}.\n     * - [SetCircle]{@link Autodesk.Viewing.Extensions.Markups.Core.SetCircle}.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     *\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n     * @param {String} type - An identifier for the EditAction.\n     * @param {number} targetId - The id of the markup being affected.\n     */\n    function EditAction(editor, type, targetId) {\n\n        this.type = type;\n        this.editor = editor;\n        this.targetId = targetId;\n        this.addToHistory = true;\n        this.selectOnExecution = true;\n    }\n\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction = EditAction;\n\n    /**\n     * Performs the action.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.execute = function () {\n\n        this.editor.actionManager.execute(this);\n    };\n\n    /**\n     * @abstract\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.redo = function () {};\n\n    /**\n     * @abstract\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.undo = function () {};\n\n    /**\n     * Provides a mechanism to merge consecutive actions of the same type.\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.EditAction} action - Action to check if it can be merged with 'this'.\n     * @returns {boolean} Returns true if merge has been applied. Parameter will be discarded.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.merge = function (action) {\n\n        return false;\n    };\n\n    /**\n     * Provides a mechanism to check whether the action yields no results.\n     * @returns {boolean} Returns true if no changes happen with this action.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.EditAction.prototype.isIdentity = function () {\n\n        return false;\n    };\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param historySize\n     * @constructor\n     */\n    function EditActionManager(historySize) {\n\n        this.historySize = historySize;\n\n        this.undoStack = new Array(historySize);\n        this.redoStack = new Array(historySize);\n\n        namespaceUtils.addTraitEventDispatcher(this);\n    }\n\n    /*\n     * Event types\n     */\n    namespace.EVENT_HISTORY_CHANGED = \"EVENT_HISTORY_CHANGED\";\n\n    var proto = EditActionManager.prototype;\n\n    /**\n     *\n     * @param action\n     */\n    proto.execute = function (action) {\n\n        var redoStack = this.redoStack;\n        var undoStack = this.undoStack;\n\n        redoStack.splice(0, redoStack.length);\n\n        action.redo();\n\n        var group = this.getEditActionGroup();\n        if (group.isOpen()) {\n            group.addAction(action);\n        } else {\n            group.open();\n            group.addAction(action);\n            group.close();\n        }\n\n        if (undoStack.length > this.historySize) {\n            undoStack.splice(0, 1);\n        }\n\n        var targetId = action.selectOnExecution ? action.targetId : -1;\n        this.fireEvent({ type: namespace.EVENT_HISTORY_CHANGED, data: { action: 'execute', targetId: targetId } });\n    };\n\n    proto.beginActionGroup = function () {\n\n        var undoStack = this.undoStack;\n        var undoStackCount = undoStack.length;\n        var group = null;\n\n        if (undoStackCount === 0 || undoStack[undoStackCount - 1].isClosed()) {\n\n            group = this.getEditActionGroup();\n            group.open();\n        } else {\n            console.warn('Markups - Undo/Redo - Action edit group already open.');\n        }\n    };\n\n    proto.closeActionGroup = function () {\n\n        var undoStack = this.undoStack;\n        var undoStackCount = undoStack.length;\n\n        if (undoStackCount === 0) {\n\n            console.warn('Markups - Undo/Redo - There is no action edit group to close.');\n            return;\n        }\n\n        var group = undoStack[undoStackCount - 1];\n        if (!group.close()) {\n            console.warn('Markups - Undo/Redo - Action edit group already closed.');\n        }\n\n        if (group.isEmpty()) {\n            undoStack.pop();\n        }\n    };\n\n    proto.cancelActionGroup = function () {\n\n        var undoStack = this.undoStack;\n        var undoStackCount = undoStack.length;\n\n        if (undoStackCount === 0) {\n\n            console.warn('Markups - Undo/Redo - There is no action edit group to close.');\n            return;\n        }\n\n        var group = undoStack[undoStackCount - 1];\n        if (!group.close()) {\n            console.warn('Markups - Undo/Redo - Action edit group already closed.');\n            return;\n        }\n\n        group.undo();\n        undoStack.pop();\n\n        this.fireEvent({ type: namespace.EVENT_HISTORY_CHANGED, data: { action: 'cancel', targetId: -1 } });\n    };\n\n    proto.undo = function () {\n\n        var undoStack = this.undoStack;\n        var redoStack = this.redoStack;\n\n        if (undoStack.length === 0) {\n            return;\n        }\n\n        var group = undoStack.pop();\n        var targetId = group.undo();\n\n        redoStack.push(group);\n\n        this.fireEvent({ type: namespace.EVENT_HISTORY_CHANGED, data: { action: 'undo', targetId: targetId } });\n    };\n\n    proto.redo = function () {\n\n        var undoStack = this.undoStack;\n        var redoStack = this.redoStack;\n\n        if (redoStack.length === 0) {\n            return;\n        }\n\n        var group = redoStack.pop();\n        var targetId = group.redo();\n\n        undoStack.push(group);\n\n        this.fireEvent({ type: namespace.EVENT_HISTORY_CHANGED, data: { action: 'redo', targetId: targetId } });\n    };\n\n    proto.clear = function () {\n\n        this.undoStack.splice(0, this.undoStack.length);\n        this.redoStack.splice(0, this.redoStack.length);\n\n        this.fireEvent({ type: namespace.EVENT_HISTORY_CHANGED, data: { action: 'clear', targetId: -1 } });\n    };\n\n    proto.isUndoStackEmpty = function () {\n\n        return this.undoStack.length === 0;\n    };\n\n    proto.isRedoStackEmpty = function () {\n\n        return this.redoStack.length === 0;\n    };\n\n    /**\n     *\n     * @return action\n     * @private\n     */\n    proto.getEditActionGroup = function () {\n\n        var undoStack = this.undoStack;\n        var undoStackCount = this.undoStack.length;\n\n        var group = null;\n\n        if (undoStackCount === 0 || undoStack[undoStackCount - 1].isClosed()) {\n            group = new namespace.EditActionGroup();\n            undoStack.push(group);\n        } else {\n            group = undoStack[undoStackCount - 1];\n        }\n\n        return group;\n    };\n\n    namespace.EditActionManager = EditActionManager;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * Curring object which generate a string that can be used\n     * as a Dom element's 'style' value.\n     *\n     * @constructor\n     */\n    function DomElementStyle() {\n\n        this.reset();\n    }\n\n    /*\n     * Constants\n     */\n    var BROWSER_PREFIXES = ['-ms-', '-webkit-', '-moz-', '-o-'];\n\n    var proto = DomElementStyle.prototype;\n\n    proto.reset = function () {\n\n        this.attributes = {};\n        this.dirty = false;\n        this.styleString = '';\n\n        return this;\n    };\n\n    /**\n     *\n     * @param {String} key\n     * @param {*} value\n     * @param {Object} [options]\n     * @param {Boolean} [options.allBrowsers] - Whether to add browser prefix to key\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomeElemStyle}\n     */\n    proto.setAttribute = function (key, value, options) {\n\n        this.attributes[key] = value;\n\n        if (options && options.allBrowsers) {\n            var that = this;\n            BROWSER_PREFIXES.forEach(function (prefix) {\n                that.attributes[prefix + key] = value;\n            });\n        }\n        this.dirty = true; // Could be optimized\n        return this;\n    };\n\n    /**\n     * Removes one or more attributes\n     * @param {String|Array} key - Key or Keys to be removed\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle} this\n     */\n    proto.removeAttribute = function (key) {\n\n        if (!Array.isArray(key)) {\n            key = [key];\n        }\n\n        var self = this;\n        key.forEach(function (k) {\n            if (k in self.attributes) {\n                delete self.attributes[k];\n                self.dirty = true;\n            }\n        });\n        return this;\n    };\n\n    /**\n     * Gets the String representation of this style object\n     * @returns {string}\n     */\n    proto.getStyleString = function () {\n\n        if (this.dirty) {\n            this.styleString = generateStyle(this.attributes);\n            this.dirty = false;\n        }\n        return this.styleString;\n    };\n\n    /**\n     * Clones the current Object\n     *\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Utils.DomElemStyle}\n     */\n    proto.clone = function () {\n\n        var clone = new namespace.DomElementStyle();\n        var attributes = this.attributes;\n\n        for (var key in attributes) {\n            clone.setAttribute(key, attributes[key]);\n        }\n        return clone;\n    };\n\n    /**\n     * Generates the style value string. Non mutable function.\n     *\n     * @param {Object} attributes\n     * @private\n     */\n    function generateStyle(attributes) {\n\n        var elements = [];\n        for (var key in attributes) {\n            var val = attributes[key];\n            elements.push(key);\n            elements.push(':');\n            elements.push(val);\n            elements.push('; ');\n        }\n        return elements.join('');\n    }\n\n    namespace.DomElementStyle = DomElementStyle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * A component to handle the selection of markups.\n     *\n     *\n     *      Sample\n     *\n     *      var containingDiv = document.getElementById('containingDiv3d-app-wrapper');\n     *      var selectionComponent = new EditFrame(containingDiv);\n     *      selectionComponent.setSelection(100, 100, 300, 150, 0);\n     *\n     * @param {HTMLElement} containingDiv The container where the selection layer will live.\n     * @param {Object} editor\n     * @constructor\n     */\n    function EditFrame(containingDiv, editor) {\n\n        this.containingDiv = containingDiv;\n        this.editor = editor;\n        this.selectionLayer = createSelectionLayer();\n\n        this.selection = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            rotation: 0,\n            element: null,\n            active: false,\n            dragging: false,\n            resizing: false,\n            //a dictionary of all the drag points\n            //the key for each drag point will be its cardinal/ordinal direction\n            handle: {}\n        };\n\n        createSelectorBox.bind(this)();\n\n        if (namespaceUtils.isTouchDevice()) {\n            this.onHammerDragBinded = this.onHammerDrag.bind(this);\n            this.hammer = new Hammer.Manager(this.selectionLayer, {\n                recognizers: [[Hammer.Pan, { event: 'drag', pointers: 1 }]],\n                inputClass: Hammer.TouchInput\n            });\n        }\n        handleSelectionBoxDragging.bind(this)();\n        handleSelectionBoxResizing.bind(this)();\n        handleSelectionDoubleClick.bind(this)();\n        handleSelectionBoxRotating.bind(this)();\n\n        //add the selection into the container given to us\n        this.containingDiv.appendChild(this.selectionLayer);\n\n        namespaceUtils.addTraitEventDispatcher(this);\n    }\n\n    // Constants //\n    namespace.EVENT_EDITFRAME_EDITION_START = \"EVENT_EDITFRAME_EDITION_START\";\n    namespace.EVENT_EDITFRAME_EDITION_END = \"EVENT_EDITFRAME_EDITION_END\";\n\n    var proto = EditFrame.prototype;\n\n    /**\n     * Draws a selection box with the given attributes\n     *\n     * @param {number} x - The x coordinate to place the selection box\n     * @param {number} y - The y coordinate to place the selection box\n     * @param {number} width - The width of the selection box\n     * @param {number} height - The height of the selection box\n     * @param {number} rotation - The amount of degrees to rotate the selection box\n     */\n    proto.setSelection = function (x, y, width, height, rotation) {\n\n        updateSelectorBoxDimensions.bind(this)(width, height);\n        updateSelectorBoxPosition.bind(this)(x, y, rotation);\n        updateSelectionBoxState.bind(this)(true); //activate the selection box\n        this.selectionLayer.style.visibility = 'visible';\n    };\n\n    /**\n     * Displays the selection box based on the position, dimension, and rotation of a given markup\n     *\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup - the markup that should appear as selected\n     */\n    proto.setMarkup = function (markup) {\n\n        if (!markup) {\n            if (this.markup) {\n                this.markup = null;\n                if (this.hammer) {\n                    this.hammer.off(\"dragstart dragmove dragend\", this.onHammerDragBinded);\n                }\n                updateSelectionBoxState.bind(this)(false);\n            }\n            return;\n        }\n\n        if (!this.markup && this.hammer) {\n            this.hammer.on(\"dragstart dragmove dragend\", this.onHammerDragBinded);\n        }\n\n        var size = markup.getClientSize(),\n            position = markup.getClientPosition(),\n            width = size.x,\n            height = size.y,\n            rotation = markup.getRotation();\n\n        this.markup = markup;\n        this.setSelection(position.x - width / 2, position.y - height / 2, width, height, rotation);\n\n        this.enableResizeHandles();\n        this.enableRotationHandle();\n    };\n\n    proto.startDrag = function () {\n\n        this._onRepositionMouseDown(null, this.editor.getMousePosition());\n    };\n\n    proto.isActive = function () {\n        return this.isDragging() || this.isResizing() || this.isRotating();\n    };\n\n    proto.isDragging = function () {\n\n        return this.selection.dragging;\n    };\n\n    proto.isResizing = function () {\n\n        return this.selection.resizing;\n    };\n\n    proto.isRotating = function () {\n\n        return this.selection.rotating;\n    };\n\n    proto.onMouseMove = function (event) {\n\n        //dummy fn\n    };\n\n    proto.onMouseUp = function (event) {\n        //dummy fn\n    };\n\n    proto.onHammerDrag = function (event) {\n\n        function updateEditorInput(input, parent, event) {\n\n            //TODO: Change this when refactoring input in edit frame.\n            var rect = parent.getBoundingClientRect();\n            input.mousePosition.x = event.pageX - rect.left;\n            input.mousePosition.y = event.pageY - rect.top;\n        }\n\n        //console.log('EditFrame drag ' + event.type);\n        convertEventHammerToMouse(event);\n        switch (event.type) {\n            case 'dragstart':\n                updateEditorInput(this.editor.input, this.editor.svg, event);\n                // Check whether to translate, rotate or resize\n                if (isRotatePoint(event.target)) {\n                    // Rotate\n                    this._onRotationMouseDown(event);\n                } else if (isDragPoint(event.target)) {\n                    // Resize\n                    this._onResizeMouseDown(event);\n                } else {\n                    this.startDrag();\n                }\n                event.preventDefault();\n                break;\n            case 'dragmove':\n                updateEditorInput(this.editor.input, this.editor.svg, event);\n                this.onMouseMove(event);\n                event.preventDefault();\n                break;\n            case 'dragend':\n                updateEditorInput(this.editor.input, this.editor.svg, event);\n                this.onMouseUp(event);\n                event.preventDefault();\n                break;\n        }\n    };\n\n    proto.enableResizeHandles = function () {\n\n        var markup = this.markup;\n        var handle;\n\n        if (markup.isHeightConstrained() || markup.isWidthConstrained()) {\n            //hide all the handles\n            for (var direction in this.selection.handle) {\n                handle = this.selection.handle[direction];\n                if (handle) handle.style.display = 'none';\n            }\n\n            //show only the resize points that are allowed\n            if (markup.isHeightConstrained()) {\n                this.selection.handle['w'].style.display = 'block';\n                this.selection.handle['e'].style.display = 'block';\n            }\n            if (markup.isWidthConstrained()) {\n                this.selection.handle['n'].style.display = 'block';\n                this.selection.handle['s'].style.display = 'block';\n            }\n        } else {\n            //no constraints, show all resize handles\n            for (var direction in this.selection.handle) {\n                handle = this.selection.handle[direction];\n                if (handle) handle.style.display = 'block';\n            }\n        }\n    };\n\n    proto.enableRotationHandle = function () {\n\n        var markup = this.markup;\n        var handle = this.selection.rotationHandle;\n        var display = markup.isRotationConstrained() ? 'none' : 'block';\n        handle.style.display = display;\n    };\n\n    function convertEventHammerToMouse(event) {\n        // Convert Hammer touch-event X,Y into mouse-event X,Y.\n        event.pageX = event.pointers[0].clientX;\n        event.pageY = event.pointers[0].clientY;\n    }\n\n    /**\n     * Creates an element spanning the full height and width of its parent.\n     * It serves as our surface to draw the selection box.\n     *\n     * @return {HTMLElement}\n     */\n    function createSelectionLayer() {\n\n        var selectionLayer = document.createElement('div');\n        selectionLayer.style.position = 'absolute';\n        selectionLayer.style.top = 0;\n        selectionLayer.style.bottom = 0;\n        selectionLayer.style.left = 0;\n        selectionLayer.style.right = 0;\n        //don't let the selection box be visible outside the selection layer\n        selectionLayer.style.overflow = 'hidden';\n        selectionLayer.style.visibility = 'hidden';\n        togglePointerEvents(selectionLayer, false);\n        return selectionLayer;\n    }\n\n    /**\n     * Creates a single drag point with the corresponding styles\n     *\n     * @param {number} diameter - The size of the drag point\n     * @param {string} position - The cardinal(n, s, w, e) or ordinal(nw, nw, sw, se) direction of the point\n     * @return {HTMLElement}\n     */\n    function createDragPoint(diameter, position) {\n\n        var pointBorderWidth = 2;\n        var point = document.createElement('div');\n        point.style.position = 'absolute';\n        point.style.backgroundColor = 'rgba(151, 151, 151, 1)';\n        point.style.border = pointBorderWidth + 'px solid rgb(95, 98, 100)';\n        point.style.height = diameter + 'px';\n        point.style.width = diameter + 'px';\n        point.style.borderRadius = diameter / 2 + pointBorderWidth + 'px';\n        point.style.boxSizing = 'border-box';\n        setResizeCursor(point, position);\n        point.className = 'selector-drag-point sdp-handle-' + position;\n        point.setAttribute('data-sdp-handle', position);\n\n        var placementOffset = -1 * ((diameter + pointBorderWidth) / 2);\n        //set the position of the drag points based on the position\n        switch (position) {\n            case 'n':\n                //wrap the point inside a wrapper so we can center it\n                //using margin: 0 auto\n                var wrapper = document.createElement('div');\n                wrapper.style.position = 'absolute';\n                wrapper.style.width = '100%';\n                wrapper.style.height = diameter + 'px';\n                wrapper.style.top = placementOffset + 'px';\n                point.style.margin = '0 auto';\n                point.style.position = '';\n\n                wrapper.appendChild(point);\n                point = wrapper;\n\n                break;\n            case 's':\n                var wrapper = document.createElement('div');\n                wrapper.style.position = 'absolute';\n                wrapper.style.width = '100%';\n                wrapper.style.height = diameter + 'px';\n                wrapper.style.bottom = placementOffset + 'px';\n                point.style.margin = '0 auto';\n                point.style.position = '';\n\n                wrapper.appendChild(point);\n                point = wrapper;\n                break;\n            case 'w':\n                point.style.left = placementOffset + 'px';\n                point.style.top = '50%';\n                point.style.transform = 'translate3d(0, -50%, 0)';\n                break;\n            case 'e':\n                point.style.right = placementOffset + 'px';\n                point.style.top = '50%';\n                point.style.transform = 'translate3d(0, -50%, 0)';\n                break;\n            case 'nw':\n                point.style.top = placementOffset + 'px';\n                point.style.left = placementOffset + 'px';\n                break;\n            case 'ne':\n                point.style.top = placementOffset + 'px';\n                point.style.right = placementOffset + 'px';\n                break;\n            case 'sw':\n                point.style.bottom = placementOffset + 'px';\n                point.style.left = placementOffset + 'px';\n                break;\n            case 'se':\n                point.style.bottom = placementOffset + 'px';\n                point.style.right = placementOffset + 'px';\n                break;\n        }\n        return point;\n    }\n\n    function createRotatePoint(diameter) {\n\n        var pointBorderWidth = 2;\n        var point = document.createElement('div');\n        point.style.position = 'absolute';\n        point.style.backgroundColor = 'aqua';\n        point.style.border = pointBorderWidth + 'px solid rgb(95, 98, 100)';\n        point.style.height = diameter + 'px';\n        point.style.width = diameter + 'px';\n        point.style.borderRadius = diameter / 2 + pointBorderWidth + 'px';\n        point.style.boxSizing = 'border-box';\n        point.classList.add('selector-rotate-point');\n        point.style.left = '50%';\n        point.style.transform = 'translate3d(-50%, 0px, 0px)';\n        point.style.top = '-25px';\n        return point;\n    }\n\n    function setResizeCursor(element, direction) {\n\n        var cursor;\n        switch (direction) {\n            case 'n':\n            case 's':\n                cursor = 'ns-resize';\n                break;\n            case 'w':\n            case 'e':\n                cursor = 'ew-resize';\n                break;\n            case 'ne':\n            case 'sw':\n                cursor = 'nesw-resize';\n                break;\n            case 'nw':\n            case 'se':\n                cursor = 'nwse-resize';\n                break;\n        }\n        element.style.cursor = cursor;\n    }\n\n    /**\n     * Creates the 8 drag points of the selection box.\n     *\n     * @this EditFrame\n     */\n    function createDragPoints(selector) {\n\n        var pointDiameter = 12;\n\n        ['n', 's', 'w', 'e', 'nw', 'ne', 'sw', 'se'].forEach(function (direction) {\n            //store the drag point and put it in the DOM\n            this.selection.handle[direction] = createDragPoint(pointDiameter, direction);\n            selector.appendChild(this.selection.handle[direction]);\n        }.bind(this));\n    }\n\n    /**\n     * Determines if an element is a drag point\n     *\n     * @return {boolean}\n     */\n    function isDragPoint(element) {\n\n        return matchesSelectorAux(element, '.selector-drag-point');\n    }\n\n    /**\n     * Determines if an element is a rotate point\n     *\n     * @return {boolean}\n     */\n    function isRotatePoint(element) {\n\n        return matchesSelectorAux(element, '.selector-rotate-point');\n    }\n\n    /**\n     * Creates the element that will be used as the selection box. It also\n     * takes care of adding the drag handles\n     *\n     * @return {HTMLElement} - the selection box\n     * @this EditFrame\n     */\n    function createSelectorBox() {\n\n        var borderWidth = 1;\n        var borderColor = 'rgb(0, 0, 255)';\n        var selectorBox = document.createElement('div');\n        selectorBox.style.position = 'absolute';\n        selectorBox.style.border = borderWidth + 'px solid ' + borderColor;\n        selectorBox.style.zIndex = 1;\n        selectorBox.style.cursor = 'move';\n        selectorBox.style.boxSizing = 'border-box';\n        togglePointerEvents(selectorBox, true);\n        selectorBox.classList.add('selector-box');\n        createDragPoints.bind(this)(selectorBox);\n        this.selection.rotationHandle = createRotatePoint(12);\n        selectorBox.appendChild(this.selection.rotationHandle);\n        //store the selector box\n        this.selection.element = selectorBox;\n\n        //add the selection box to the selection layer\n        this.selectionLayer.appendChild(this.selection.element);\n\n        //we are just creating the box, start it out hidden\n        updateSelectionBoxState.bind(this)(false);\n\n        return selectorBox;\n    }\n\n    /**\n     * Utility to create the CSS translate3d value from a given 2d point\n     *\n     * @param {number} x - coordinate\n     * @param {number} y - coordinate\n     * @return {string}\n     */\n    function toTranslate3d(x, y) {\n\n        return 'translate3d(' + x + 'px,' + y + 'px,0)';\n    }\n\n    /**\n     * Updates the display state of the selection box\n     *\n     * @param {boolean} active - The new state of the the selection box\n     * @this EditFrame\n     */\n    function updateSelectionBoxState(active) {\n\n        this.selection.active = active;\n        this.selection.element.style.display = active ? 'block' : 'none';\n    }\n\n    /**\n     * Updates the position and rotation of the selection box.\n     *\n     * @param {number} x - The x coordinate to place the selection box\n     * @param {number} y - The y coordinate to place the selection box\n     * @param {number} rotation - The amount of degrees to rotate the selection box\n     * @this EditFrame\n     */\n    function updateSelectorBoxPosition(x, y, rotation) {\n\n        this.selection.x = x;\n        this.selection.y = y;\n        this.selection.rotation = rotation;\n        var size = this.markup.getClientSize();\n        //TODO: consider DomElementStyle\n\n        this.selection.element.style.msTransform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';\n        this.selection.element.style.msTransformOrigin = size.x / 2 + 'px ' + size.y / 2 + 'px';\n        this.selection.element.style.webkitTransform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';\n        this.selection.element.style.webkitTransformOrigin = size.x / 2 + 'px ' + size.y / 2 + 'px';\n        this.selection.element.style.transform = toTranslate3d(x, y) + ' rotate(' + rotation + 'rad)';\n        this.selection.element.style.transformOrigin = size.x / 2 + 'px ' + size.y / 2 + 'px';\n    }\n\n    /**\n     * Updates the dimensions of the selection box (width and height).\n     *\n     * @param {number} width - The new width of the selection box\n     * @param {number} height - The new height of the selection box\n     * @this EditFrame\n     */\n    function updateSelectorBoxDimensions(width, height) {\n\n        this.selection.width = width;\n        this.selection.height = height;\n        this.selection.element.style.width = width + 'px';\n        this.selection.element.style.height = height + 'px';\n    }\n\n    /**\n     * Attaches all the necessary listeners to handle a drag action.\n     *\n     * @this EditFrame\n     */\n    function handleSelectionBoxDragging() {\n\n        this.selection.element.addEventListener('mousedown', this._onRepositionMouseDown.bind(this));\n    }\n\n    proto._onRepositionMouseDown = function (event, cursor) {\n\n        //a synthetic start means that the event was triggered manually and not as a\n        //result of a mousedown on the edit frame\n        var syntheticStart = !(event instanceof MouseEvent);\n\n        //during a real mousedown, ignore events originating from a resizing handle\n        if (!syntheticStart && (isDragPoint(event.target) || isRotatePoint(event.target))) return;\n\n        this.editor.beginActionGroup();\n        this.selection.dragging = true;\n\n        //get the cursor position\n        cursor = syntheticStart ? cursor : this.editor.getMousePosition();\n\n        //store the initial cursor and axis constrains\n        this.initialCursor = cursor;\n        this.initialPosition = this.markup.getClientPosition();\n        this.areAxisConstrained = false;\n        this.axisConstrains = new THREE.Vector2(1, 1);\n\n        //update the function that will handle the mousemove and mouseup events\n        this.onMouseMove = this._onRepositionMouseMove.bind(this);\n        this.onMouseUp = this._onRepositionMouseUp.bind(this);\n\n        //if alt down I drop a clone.\n        if (event && event.altKey) {\n            var editor = this.editor;\n            var cloneMarkup = new namespace.CloneMarkup(editor, editor.getId(), this.markup, this.markup.position);\n            cloneMarkup.execute();\n        }\n\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Moving around\n    };\n\n    proto._onRepositionMouseMove = function (event) {\n\n        //ignore mousemove events if the dragging state hasn't been activated\n        if (!this.selection.dragging) return;\n\n        //get the position of the cursor relative to selection layer\n        var cursor = this.editor.getMousePosition();\n\n        //constrain axis if shift key is down.\n        var constrainAxis = this.editor.input.constrainAxis;\n        if (this.areAxisConstrained !== constrainAxis) {\n            this.areAxisConstrained = constrainAxis;\n            this.axisConstrains = constrainAxis ? new THREE.Vector2(0, 0) : new THREE.Vector2(1, 1);\n\n            this.initialPosition.x += cursor.x - this.initialCursor.x;\n            this.initialPosition.y += cursor.y - this.initialCursor.y;\n\n            this.initialCursor.x = cursor.x;\n            this.initialCursor.y = cursor.y;\n        }\n\n        //determine how many pixel we have to shift the\n        //selection box to keep the cursor on the drag point\n        var movement = {\n            x: cursor.x - this.initialCursor.x,\n            y: cursor.y - this.initialCursor.y\n        };\n\n        var deadZone = 15;\n        if (this.axisConstrains.x === 0 && this.axisConstrains.y === 0) {\n\n            if (Math.abs(movement.x) > deadZone) {\n                this.axisConstrains.x = 1;\n                movement.x += movement.x < 0 ? deadZone : -deadZone;\n            } else if (Math.abs(movement.y) > deadZone) {\n                this.axisConstrains.y = 1;\n                movement.y += movement.y < 0 ? deadZone : -deadZone;\n            }\n        }\n\n        var x = this.initialPosition.x + movement.x * this.axisConstrains.x;\n        var y = this.initialPosition.y + movement.y * this.axisConstrains.y;\n\n        updateSelectorBoxPosition.bind(this)(x, y, this.selection.rotation);\n\n        //tell the markup to start transforming\n        //the markup expects an (x, y) coordinate that\n        //uses an origin at the center, adjust our x, y because\n        //our origin starts at the top left\n        var position = this.editor.positionFromClientToMarkups(x, y);\n        var setPosition = new namespace.SetPosition(this.editor, this.markup, position);\n        setPosition.execute();\n    };\n\n    proto._onRepositionMouseUp = function () {\n\n        this.last = null;\n\n        //this should never be called after the mouse up because we are no longer repositioning\n        this.onMouseMove = function () {/*do nothing*/};\n        this.onMouseUp = function () {/*do nothing*/};\n\n        if (!this.selection.dragging) {\n            return;\n        }\n\n        this.editor.closeActionGroup();\n        this.selection.dragging = false;\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Moving around\n    };\n\n    proto._onResizeMouseDown = function (event) {\n        var target = event.target;\n\n        //is the target where the mousedown occurred a drag point\n        if (!isDragPoint(target)) {\n            return;\n        }\n\n        this.selection.resizing = true;\n        //keep a reference to the point where the drag started\n        this.selection.handle.resizing = target;\n        //figure out which direction this point should resize\n        var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');\n        //set the cursor position for the entire layer\n        this.containingDiv.style.cursor = direction + '-resize';\n\n        var cursor = this.editor.getMousePosition();\n\n        var position = this.markup.getClientPosition();\n        var size = this.markup.getClientSize();\n\n        //store the center\n        this.initial = {\n            x: position.x,\n            y: position.y,\n            width: size.x,\n            height: size.y,\n            mouseX: cursor.x,\n            mouseY: cursor.y\n        };\n\n        this.onMouseMove = this._onResizeMouseMove.bind(this);\n        this.onMouseUp = this._onResizeMouseUp.bind(this);\n\n        //notify the markup that dragging has started\n        this.editor.beginActionGroup();\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Resizing\n    };\n\n    proto._onResizeMouseMove = function (event) {\n\n        if (!this.selection.resizing) return;\n\n        var cursor = this.editor.getMousePosition();\n        var initial = this.initial;\n\n        var movement = {\n            x: cursor.x - initial.mouseX,\n            y: cursor.y - initial.mouseY\n        };\n\n        var vector = new THREE.Vector3(movement.x, movement.y, 0);\n        var undoRotation = new THREE.Matrix4().makeRotationZ(-this.selection.rotation);\n        movement = vector.applyMatrix4(undoRotation);\n\n        var x = initial.x,\n            y = initial.y,\n            width = initial.width,\n            height = initial.height;\n\n        var localSpaceDelta = new THREE.Vector3();\n\n        //get the direction of the arrow being dragged\n        var direction = this.selection.handle.resizing.getAttribute('data-sdp-handle');\n\n        // TODO: Make a mechanism to configure and use this feature from Markups Core.\n        // If shift is pressed, figure aspect ratio is maintained.\n        if (this.editor.input.keepAspectRatio && ['nw', 'ne', 'sw', 'se'].indexOf(direction) !== -1) {\n\n            var delta = new THREE.Vector3(movement.x, movement.y, 0);\n            switch (direction) {\n                case 'nw':\n                    movement.set(-initial.width, -initial.height, 0);break;\n                case 'ne':\n                    movement.set(initial.width, -initial.height, 0);break;\n                case 'sw':\n                    movement.set(initial.width, -initial.height, 0);break;\n                case 'se':\n                    movement.set(initial.width, initial.height, 0);break;\n            }\n            movement.normalize();\n            movement = delta.projectOnVector(movement);\n        }\n\n        var translations = {\n            n: function n() {\n                height -= movement.y;\n                localSpaceDelta.y = movement.y;\n            },\n            s: function s() {\n                height += movement.y;\n                localSpaceDelta.y = movement.y;\n            },\n            w: function w() {\n                width -= movement.x;\n                localSpaceDelta.x = movement.x;\n            },\n            e: function e() {\n                width += movement.x;\n                localSpaceDelta.x = movement.x;\n            },\n            nw: function nw() {\n                this.n();\n                this.w();\n            },\n            ne: function ne() {\n                this.n();\n                this.e();\n            },\n            sw: function sw() {\n                this.s();\n                this.w();\n            },\n            se: function se() {\n                this.s();\n                this.e();\n            }\n        };\n\n        translations[direction]();\n\n        var redoRotation = new THREE.Matrix4().makeRotationZ(this.selection.rotation);\n        var actualDelta = localSpaceDelta.applyMatrix4(redoRotation);\n\n        var newPos = this.editor.positionFromClientToMarkups(x + actualDelta.x * 0.5, y + actualDelta.y * 0.5);\n\n        var newSize = this.editor.sizeFromClientToMarkups(width, height);\n        var setSize = new namespace.SetSize(this.editor, this.markup, newPos, newSize.x, newSize.y);\n        setSize.execute();\n    };\n\n    proto._onResizeMouseUp = function (event) {\n        this.selection.resizing = false;\n        this.selection.handle.resizing = null;\n        this.containingDiv.style.cursor = '';\n\n        this.editor.closeActionGroup();\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Resizing\n\n        //this should never be called after the mouse up because we are no longer resizing\n        this.onMouseMove = function () {/*do nothing*/\n        };\n        this.onMouseUp = function () {/*do nothing*/\n        };\n    };\n\n    /**\n     * Attaches all the necessary listeners to handle a resizing action.\n     *\n     * @this EditFrame\n     */\n    function handleSelectionBoxResizing() {\n        this.selectionLayer.addEventListener('mousedown', this._onResizeMouseDown.bind(this));\n    }\n\n    function handleSelectionBoxRotating() {\n\n        this.selection.element.addEventListener('mousedown', this._onRotationMouseDown.bind(this));\n    }\n\n    var initialRotation;\n    var initialHandlePosition;\n\n    proto._onRotationMouseDown = function (event) {\n\n        //ignore anything not coming from the rotation point\n        if (!isRotatePoint(event.target)) return;\n\n        this.editor.beginActionGroup();\n        this.selection.rotating = true;\n\n        //store the initial cursor\n        initialHandlePosition = this.editor.getMousePosition();\n\n        initialRotation = this.selection.rotation || 0;\n\n        //update the function that will handle the mousemove and mouseup events\n        this.onMouseMove = this._onRotationMouseMove.bind(this);\n        this.onMouseUp = this._onRotationMouseUp.bind(this);\n\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_START }); // Rotating\n    };\n\n    proto._onRotationMouseMove = function (event) {\n\n        //ignore mousemove events if the dragging state hasn't been activated\n        if (!this.selection.rotating) return;\n\n        var cursor = this.editor.getMousePosition();\n        var position = this.markup.getClientPosition();\n\n        var r = getAngleBetweenPoints(position, cursor);\n        var r2 = getAngleBetweenPoints(position, initialHandlePosition);\n        var rotation = r - r2 + initialRotation;\n\n        // TODO: Make a mechanism to configure and use this feature from Markups Core.\n        if (this.editor.input.snapRotations) {\n            var snap = namespaceUtils.degreesToRadians(22.5);\n            rotation = Math.ceil(rotation / snap) * snap;\n        }\n\n        //pass rotation as degrees\n        updateSelectorBoxPosition.bind(this)(this.selection.x, this.selection.y, rotation);\n\n        //convert to radians\n        var setRotation = new namespace.SetRotation(this.editor, this.markup, rotation);\n        setRotation.execute();\n    };\n\n    proto._onRotationMouseUp = function (event) {\n\n        this.selection.rotating = false;\n        initialRotation = null;\n        initialHandlePosition = null;\n        this.editor.closeActionGroup();\n        this.fireEvent({ type: namespace.EVENT_EDITFRAME_EDITION_END }); // Rotating\n    };\n\n    /**\n     * Attaches double click listener and pass events to markup, markups such as text use it to enter text edit\n     * mode.\n     *\n     * @this EditFrame\n     */\n    function handleSelectionDoubleClick() {\n\n        var doubleClick = function (event) {\n            this.selection.dragging = false;\n            var editMode = this.editor.editMode;\n            editMode && editMode.onDoubleClick(this.markup);\n        }.bind(this);\n\n        var selectorBoxWrapper = this.selectionLayer;\n        selectorBoxWrapper.addEventListener('dblclick', doubleClick);\n    }\n\n    function togglePointerEvents(element, state) {\n\n        element.style.pointerEvents = state ? 'auto' : 'none';\n    }\n\n    function getAngleBetweenPoints(p1, p2) {\n\n        return Math.atan2(p2.y - p1.y, p2.x - p1.x);\n    }\n\n    function matchesSelectorAux(domElem, selector) {\n        if (domElem.matches) return domElem.matches(selector); //Un-prefixed\n        if (domElem.msMatchesSelector) return domElem.msMatchesSelector(selector); //IE\n        if (domElem.mozMatchesSelector) return domElem.mozMatchesSelector(selector); //Firefox (Gecko)\n        if (domElem.webkitMatchesSelector) return domElem.webkitMatchesSelector(selector); // Opera, Safari, Chrome\n        return false;\n    }\n\n    namespace.EditFrame = EditFrame;\n})();\n\nAutodesk.Viewing.Extensions.Markups.Core.Utils.Localization = {\n\n    MARKUP_TEXT_DEFAULT_TEXT: 'Write something...'\n};\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * @class\n     * Base class for all Markups.<br>\n     * A Markup is a class that is capable of rendering itself as an Svg node.<br>\n     * It can also render itself into a canvas-2d context.\n     * Component within {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore} extension.\n     *\n     * Any class extending Markup should contain at least the following methods:\n     * - getEditMode()\n     * - set()\n     * - updateStyle()\n     * - setParent()\n     * - setRotation()\n     * - setSize()\n     * - setPosition()\n     * - renderToCanvas()\n     * - setMetadata()\n     *\n     * A good reference is the rectangle markup implementation available in\n     * [MarkupRectangle.js]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupRectangle}.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     *\n     * @param {number} id - Identifier, populated with return value of {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getId getId()}.\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension\n     * @param {Array} styleAttributes - Attributes for customization. Related to {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#setStyle setStyle()}.\n     * @constructor\n     */\n    function Markup(id, editor, styleAttributes) {\n\n        this.id = id;\n        this.type = 0;\n        this.editor = editor;\n        this.viewer = editor.viewer;\n        this.position = { x: 0, y: 0 };\n        this.size = { x: 0, y: 0 };\n        this.rotation = 0;\n        this.style = namespaceUtils.createStyle(styleAttributes, this.viewer);\n        this.highlightColor = '#FAFF3C';\n        this.constraintWidth = false;\n        this.constraintHeight = false;\n        this.constraintRotation = false;\n        this.highlighted = false;\n        this.selected = false;\n\n        namespaceUtils.addTraitEventDispatcher(this);\n    }\n\n    /*\n     * Constants\n     */\n    namespace.MARKUP_TYPE_ARROW = 1;\n    namespace.MARKUP_TYPE_TEXT = 2;\n    namespace.MARKUP_TYPE_RECTANGLE = 3;\n    namespace.MARKUP_TYPE_CIRCLE = 4;\n    namespace.MARKUP_TYPE_CLOUD = 5;\n    namespace.MARKUP_TYPE_FREEHAND = 6;\n\n    namespace.MARKUP_EXPORT_TYPE_LABEL = 'Label';\n    namespace.MARKUP_EXPORT_TYPE_ARROW = 'Arrow';\n    namespace.MARKUP_EXPORT_TYPE_RECTANGLE = 'Rectangle';\n    namespace.MARKUP_EXPORT_TYPE_CIRCLE = 'Circle';\n    namespace.MARKUP_EXPORT_TYPE_CLOUD = 'Cloud';\n    namespace.MARKUP_EXPORT_TYPE_FREEHAND = 'Freehand';\n\n    /*\n     * Event types\n     */\n    namespace.EVENT_EDITMODE_CHANGED = \"EVENT_EDITMODE_CHANGED\";\n\n    namespace.EVENT_MARKUP_SELECTED = \"EVENT_MARKUP_SELECTED\";\n    namespace.EVENT_MARKUP_DRAGGING = \"EVENT_MARKUP_DRAGGING\";\n    namespace.EVENT_MARKUP_ENTER_EDITION = \"EVENT_MARKUP_ENTER_EDITION\";\n    namespace.EVENT_MARKUP_CANCEL_EDITION = \"EVENT_MARKUP_CANCEL_EDITION\";\n    namespace.EVENT_MARKUP_DELETE_EDITION = \"EVENT_MARKUP_DELETE_EDITION\";\n\n    var proto = Markup.prototype;\n    namespace.Markup = Markup;\n\n    proto.destroy = function () {};\n\n    /**\n     * Clones (deep-copy) the markup. Used internally by the copy/cut/paste mechanism in\n     * {@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore MarkupsCore}.\n     *\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup} clone of the current markup\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.clone = function () {\n\n        var clone = Object.create(this.__proto__);\n        var overrides = this.getCloneOverrides();\n\n        for (var name in this) {\n\n            if (!this.hasOwnProperty(name)) {\n                continue;\n            }\n\n            var member = this[name];\n\n            // Is there an override for this member?\n            if (overrides.hasOwnProperty(name)) {\n                clone[name] = overrides[name];\n                continue;\n            }\n\n            // Member has a clone function?\n            if (member['clone'] instanceof Function) {\n                clone[name] = member.clone();\n                continue;\n            }\n\n            // Is it a function?\n            if (member instanceof Function) {\n                clone[name] = member.bind(clone);\n                continue;\n            }\n\n            // Is it an html node?\n            if (member.nodeType) {\n                clone[name] = member.cloneNode(true);\n                continue;\n            }\n\n            // Just a plain object?\n            if (member instanceof Object) {\n                clone[name] = JSON.parse(JSON.stringify(member));\n                continue;\n            }\n\n            // Ok, it seems it's just a primitive type.\n            clone[name] = member;\n        }\n\n        clone.bindDomEvents();\n        return clone;\n    };\n\n    /**\n     * Used internally by\n     * {@link Autodesk.Viewing.Extensions.Markups.Core.Markup#clone clone()},\n     * provides a mechanism to avoid cloning specific attributes.<br>\n     * Developers only need to override this method when creating new Markup types.\n     * When overriding, first call the super() implementation and then include additional attribute/value pairs to it.\n     * @returns {Object} containing attributes that need not to be cloned.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.getCloneOverrides = function () {\n\n        return {\n            viewer: this.viewer,\n            editor: this.editor,\n            hammer: null,\n            listeners: {}\n        };\n    };\n\n    /**\n     * Used internally to select a markup.<br>\n     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_SELECTED.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.select = function () {\n\n        if (this.selected) {\n            return;\n        }\n\n        this.selected = true;\n        this.highlighted = false;\n        this.updateStyle();\n        this.fireEvent({ type: namespace.EVENT_MARKUP_SELECTED, markup: this });\n    };\n\n    /**\n     * Used internally to signal that the current markup has been unselected.<br>\n     * No event is fired.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.unselect = function () {\n\n        this.selected = false;\n    };\n\n    proto.highlight = function (highlight) {\n\n        if (this.interactionsDisabled) {\n            return;\n        }\n\n        this.highlighted = highlight;\n        this.updateStyle();\n    };\n\n    /**\n     * Returns a copy of the markup's style.\n     * @returns {Object}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.getStyle = function () {\n\n        return namespaceUtils.cloneStyle(this.style);\n    };\n\n    /**\n     * Used internally to set the style object. Triggers a re-render of the markup (Svg)\n     * @param {Object} style - Dictionary with key/value pairs\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.setStyle = function (style) {\n\n        namespaceUtils.copyStyle(style, this.style);\n        this.updateStyle();\n    };\n\n    /**\n     * Used internally and implemented by specific Markup types to render themselves as Svg.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.updateStyle = function () {};\n\n    /**\n     * Used internally to notify the markup that it is no longer being dragged (moved).<br>\n     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_DRAGGING.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.finishDragging = function () {\n\n        this.fireEvent({ type: namespace.EVENT_MARKUP_DRAGGING, markup: this, dragging: false });\n    };\n\n    /**\n     * Used internally to notify the markup that it is now being edited.<br>\n     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_ENTER_EDITION.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.edit = function () {\n\n        this.fireEvent({ type: namespace.EVENT_MARKUP_ENTER_EDITION, markup: this });\n    };\n\n    /**\n     * Used internally to signal that it is no longer being edited.<br>\n     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_CANCEL_EDITION.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.cancel = function () {\n\n        this.fireEvent({ type: namespace.EVENT_MARKUP_CANCEL_EDITION, markup: this });\n    };\n\n    /**\n     * Used internally to signal that the markup is being deleted.<br>\n     * Fires event Autodesk.Viewing.Extensions.Markups.Core.EVENT_MARKUP_DELETE_EDITION.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.deleteMarkup = function () {\n\n        this.fireEvent({ type: namespace.EVENT_MARKUP_DELETE_EDITION, markup: this });\n    };\n\n    proto.setParent = function (parent) {};\n\n    proto.setPosition = function (x, y) {};\n\n    /**\n     * Used internally to get the {@link Autodesk.Viewing.Extensions.Markups.Core.EditMode EditMode}\n     * associated with the current Markup.<br>\n     * Implemented by classes extending this one.\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.EditMode}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.getEditMode = function () {\n\n        console.warn('EditMode of markup type' + namespaceUtils.getTypeString(this.type) + ' not defined.');\n        return null;\n    };\n\n    /**\n     * Used internally to get the markup's position in browser pixel space.<br>\n     * Notice that (0,0) is top left.<br>\n     * See also\n     * [getClientSize()]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientSize}.\n     * @returns {*}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.getClientPosition = function () {\n\n        var position = this.position;\n        return this.editor.positionFromMarkupsToClient(position.x, position.y);\n    };\n\n    /**\n     * Used internally to get the markup's bounding rect in browser pixel space.<br>\n     * See also\n     * [getClientPosition()]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup#getClientPosition}.\n     * @returns {*}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.Markup.prototype.getClientSize = function () {\n\n        var size = this.size;\n        return this.editor.sizeFromMarkupsToClient(size.x, size.y);\n    };\n\n    proto.setRotation = function (angle) {};\n\n    proto.getRotation = function () {\n\n        return this.rotation;\n    };\n\n    proto.setSize = function (position, size) {};\n\n    proto.isWidthConstrained = function () {\n\n        return this.constraintWidth;\n    };\n\n    proto.isHeightConstrained = function () {\n\n        return this.constraintHeight;\n    };\n\n    proto.isRotationConstrained = function () {\n\n        return this.constraintRotation;\n    };\n\n    /**\n     * Used to disable highlight on annotations while a new annotation is being created.\n     * @param {Boolean} disable - Whether (mouse) interactions are enable.\n     */\n    proto.disableInteractions = function (disable) {\n\n        this.interactionsDisabled = disable;\n    };\n\n    /**\n     *\n     * @param width\n     */\n    proto.setStrokeWidth = function (width) {};\n\n    proto.constrainsToBounds = function (bounds) {};\n\n    proto.onMouseDown = function (event) {\n\n        this.select();\n        this.editor.editFrame.startDrag();\n    };\n\n    /**\n     * Implemented by extending classes.<br>\n     * Gets called automatically when\n     * [generateData()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#generateData}\n     * @returns {null|Element} - Either null (default) or the metadata Svg node\n     */\n    proto.setMetadata = function () {\n\n        return null; // No metadata is injected by default.\n    };\n\n    proto.bindTouchEvents = function (domElement) {\n        this.hammer = new Hammer.Manager(domElement, {\n            recognizers: [[Hammer.Tap, { event: 'singletap', pointers: 1, threshold: 2 }]],\n            inputClass: Hammer.TouchInput\n        });\n\n        this.onSingleTapBinded = function (event) {\n            this.onMouseDown(event);\n        }.bind(this);\n        this.hammer.on(\"singletap\", this.onSingleTapBinded);\n    };\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param id\n     * @param editor\n     * @constructor\n     */\n    function MarkupArrow(id, editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n\n        this.type = namespace.MARKUP_TYPE_ARROW;\n        this.constraintHeight = true;\n\n        // Create head and tail.\n        this.head = new THREE.Vector3();\n        this.tail = new THREE.Vector3();\n        this.size.y = this.style['stroke-width'] * 2;\n\n        this.createSVG();\n        this.bindDomEvents();\n    }\n\n    MarkupArrow.prototype = Object.create(namespace.Markup.prototype);\n    MarkupArrow.prototype.constructor = MarkupArrow;\n\n    var proto = MarkupArrow.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeArrow(this.editor);\n    };\n\n    /**\n     * Creates the DOM elements user will see and interact with.\n     */\n    proto.createSVG = function () {\n\n        this.shape = namespaceUtils.createSvgElement('polygon');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     * Sets top-left and bottom-right values in client space coordinates (2d).\n     * Notice that for the arrow, the top left is the \"tail\" of the arrow and\n     * the bottom right is the \"head\" of it.\n     *\n     * @param {Number} xO - tail\n     * @param {Number} yO - tail\n     * @param {Number} xF - head\n     * @param {Number} yF - head\n     */\n    proto.set = function (xO, yO, xF, yF) {\n\n        var vO = new THREE.Vector2(xO, yO);\n        var vF = new THREE.Vector2(xF, yF);\n        var vDir = vF.clone().sub(vO).normalize();\n\n        this.size.x = vO.distanceTo(vF); // TODO: Clamp min length\n        this.rotation = Math.acos(vDir.dot(new THREE.Vector2(1, 0)));\n        this.rotation = yF > yO ? Math.PI * 2 - this.rotation : this.rotation;\n\n        this.head.set(xO, yO, 0);\n        this.tail.set(xF, yF, 0);\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the rotation of the markup to the given angle.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n     *\n     * @param {Number} angle\n     */\n    proto.setRotation = function (angle) {\n\n        this.rotation = angle;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the position and size of the markup.\n     * This gets called by the namespace.SetSize edit action\n     * @param {{x: Number, y: Number}} position - arrow's center\n     * @param {Number} width - Arrow's length\n     * @param {Number} height - We ignore this one because we use the arrow's stroke width instead\n     */\n    proto.setSize = function (position, width, height) {\n\n        var xF = Math.cos(this.rotation);\n        var yF = Math.sin(this.rotation);\n        var vFDir = new THREE.Vector2(xF, yF); // already normalized\n        vFDir.multiplyScalar(width * 0.5);\n\n        var vCenter = new THREE.Vector2(position.x, position.y);\n        var vO = vCenter.clone().add(vFDir);\n        var vF = vCenter.clone().sub(vFDir);\n\n        this.head.set(vF.x, vF.y, 0);\n        this.tail.set(vO.x, vO.y, 0);\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Given the 3d positions for top-left and bottom-right, it recalculates\n     * all the 2d values in client space.\n     */\n    proto.updateTransformMatrix = function () {\n\n        var head = this.head;\n        var tail = this.tail;\n        var mid_x = this.size.x * 0.5;\n        var mid_y = this.style['stroke-width'];\n        var pos_x = (head.x + tail.x) * 0.5;\n        var pos_y = (head.y + tail.y) * 0.5;\n\n        // Used by updateStyle()\n        this.transformSvg = ['translate(', pos_x, ',', pos_y, ') ', 'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ') ', 'translate(', -mid_x, ',', -mid_y, ') '].join('');\n\n        // Update values used by EditFrame and Undo/Redo system //\n        this.position.x = tail.x + (head.x - tail.x) * 0.5;\n        this.position.y = tail.y + (head.y - tail.y) * 0.5;\n    };\n\n    proto.updateStyle = function () {\n\n        // Update size and transform,\n        this.size.y = this.style['stroke-width'] * 2;\n        this.updateTransformMatrix();\n\n        // Update style.\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n\n        var polygonPoints = this.getPolygonPoints();\n        // Transform points into SVG compliant format\n        // Meaning: 'x1,y1 x2,y2 ... x8,y8 x9,y9'\n        var mappedPoints = polygonPoints.map(function (point) {\n            return point[0] + ',' + point[1];\n        });\n        var polygonStr = mappedPoints.join(' '); // Leave a space between points\n        this.shape.setAttribute('points', polygonStr);\n        this.shape.setAttribute(\"transform\", this.transformSvg);\n        this.shape.setAttribute('fill', strokeColor);\n        this.shape.setAttribute('opacity', this.style['stroke-opacity']);\n    };\n\n    /**\n     * Generates a list of points that compose the arrow's visuals\n     * @return {Array} Where each element is an array with 2 values: [x, y]\n     * @private\n     */\n    proto.getPolygonPoints = function () {\n\n        // To build the arrow we need 7 points in total\n        // The 'default' arrow built here has the following characteristics:\n        //\n        // 1. It is built horizontally facing right\n        // 2. It's bounding rectangle has length: this.size.x\n        // 3. It's bounding rectangle has height: 2 * this.strokeWidth\n        // 4. The arrow tail's thickness is: this.strokeWidth\n        // 5. The arrow head's length is: 2/3 of (point 3)\n        // 6. The arrow head's thickness is: (point 3)\n        // 7. The arrow generated is centered in its local (0,0), meaning that\n        //    two points are placed with negative x values, and all other have\n        //    positive x values:\n        //\n        //                             (3)\n        //                              |  \\\n        //             (1)-------------(2)   \\\n        //              |         (0)        (4)\n        //             (7)-------------(6)   /\n        //                              |  /\n        //                             (5)\n        //\n\n        var strokeWidth = this.style['stroke-width'];\n        var half_len = this.size.x * 0.5;\n        var thickness = strokeWidth;\n        var half_thickness = strokeWidth * 0.5;\n        var head_len = half_len - 1.2 * thickness;\n\n        // Left side points\n        var p1 = [-half_len, -half_thickness];\n        var p7 = [-half_len, half_thickness];\n\n        // The tip\n        var p4 = [half_len, 0];\n\n        // Right side points (from top to bottom)\n        var p3 = [head_len, -thickness];\n        var p2 = [head_len, -half_thickness];\n        var p6 = [head_len, half_thickness];\n        var p5 = [head_len, thickness];\n\n        var points = [p1, p2, p3, p4, p5, p6, p7];\n\n        // TODO: The created arrow should have its (0,0) on the top left\n        // TODO: This was an oversight, and for now we fix it by offsetting before returning.\n        points.forEach(function (point) {\n            point[0] += half_len;\n            point[1] += thickness;\n        });\n\n        return points;\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        var div = this.shape;\n        div.parentNode && div.parentNode.removeChild(div);\n        parent && parent.appendChild(div);\n    };\n\n    /**\n     * Used by the EditFrame to move the markup in Client Space coordinates\n     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n     */\n    proto.setPosition = function (x, y) {\n\n        var head = this.head;\n        var tail = this.tail;\n\n        var dx = head.x - tail.x;\n        var dy = head.y - tail.y;\n\n        var xo = x - dx * 0.5;\n        var yo = y - dy * 0.5;\n\n        head.x = xo;\n        head.y = yo;\n\n        tail.x = xo + dx;\n        tail.y = yo + dy;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    proto.created = function () {};\n\n    proto.destroy = function () {\n\n        this.unselect();\n        this.setParent(null);\n    };\n\n    /**\n     *\n     * @param bounds\n     */\n    proto.constrainsToBounds = function (bounds) {};\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"arrow\";\n        metadata.head = [this.head.x, this.head.y].join(\" \");\n        metadata.tail = [this.tail.x, this.tail.y].join(\" \");\n        metadata.rotation = String(this.rotation);\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    proto.renderToCanvas = function (ctx) {\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n\n        var head = this.head;\n        var tail = this.tail;\n        var mid_x = this.size.x * 0.5;\n        var mid_y = strokeWidth;\n        var pos_x = (head.x + tail.x) * 0.5;\n        var pos_y = (head.y + tail.y) * 0.5;\n        var clientMid = this.editor.positionFromMarkupsToClient(mid_x, mid_y);\n        var clientPos = this.editor.positionFromMarkupsToClient(pos_x, pos_y);\n        var m1 = new THREE.Matrix4().makeTranslation(-clientMid.x, -clientMid.y, 0);\n        var m2 = new THREE.Matrix4().makeRotationZ(this.rotation);\n        var m3 = new THREE.Matrix4().makeTranslation(clientPos.x, clientPos.y, 0);\n        var transform = m3.multiply(m2).multiply(m1);\n\n        var points = this.getPolygonPoints();\n        ctx.fillStyle = namespaceUtils.composeRGBAString(strokeColor, strokeOpacity);\n        ctx.beginPath();\n        var that = this;\n        points.forEach(function (point) {\n            var x = point[0],\n                y = point[1];\n            var client = that.editor.positionFromMarkupsToClient(x, y);\n            client = client.applyMatrix4(transform);\n            ctx.lineTo(client.x, client.y);\n        });\n        ctx.fill();\n    };\n\n    namespace.MarkupArrow = MarkupArrow;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param id\n     * @param editor\n     * @constructor\n     */\n    function MarkupCircle(id, editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n\n        this.type = namespace.MARKUP_TYPE_CIRCLE;\n\n        this.createSVG();\n        this.bindDomEvents();\n    }\n\n    MarkupCircle.prototype = Object.create(namespace.Markup.prototype);\n    MarkupCircle.prototype.constructor = MarkupCircle;\n\n    var proto = MarkupCircle.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeCircle(this.editor);\n    };\n\n    proto.createSVG = function () {\n        this.shape = namespaceUtils.createSvgElement('ellipse');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     * Sets top-left and bottom-right values in client space coordinates (2d).\n     * @param {Object} position\n     * @param {Object} size\n     */\n    proto.set = function (position, size) {\n\n        this.rotation = 0; // Reset angle //\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = size.x;\n        this.size.y = size.y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Given the 3d positions for top-left and bottom-right, it recalculates\n     * all the 2d values in client space.\n     */\n    proto.updateTransformMatrix = function () {\n\n        var strokeWidth = this.style['stroke-width'];\n\n        var originX = Math.max(this.size.x - strokeWidth, 0) * 0.5;\n        var originY = Math.max(this.size.y - strokeWidth, 0) * 0.5;\n\n        this.transformSvg = ['translate(', this.position.x, ',', this.position.y, ') ', 'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ') ', 'translate(', -originX, ',', -originY, ') '].join('');\n    };\n\n    /**\n     * Applies data values into DOM element style/attribute(s)\n     *\n     */\n    proto.updateStyle = function () {\n\n        this.updateTransformMatrix();\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        var rad_x = Math.max(this.size.x - strokeWidth, 0) * 0.5;\n        var rad_y = Math.max(this.size.y - strokeWidth, 0) * 0.5;\n\n        this.shape.setAttribute(\"transform\", this.transformSvg);\n        this.shape.setAttribute(\"stroke-width\", strokeWidth);\n        this.shape.setAttribute(\"stroke\", namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n        this.shape.setAttribute('fill', namespaceUtils.composeRGBAString(fillColor, fillOpacity));\n        this.shape.setAttribute('cx', rad_x);\n        this.shape.setAttribute('cy', rad_y);\n        this.shape.setAttribute('rx', rad_x);\n        this.shape.setAttribute('ry', rad_y);\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        var div = this.shape;\n        div.parentNode && div.parentNode.removeChild(div);\n        parent && parent.appendChild(div);\n    };\n\n    /**\n     * Changes the rotation of the markup to the given angle.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n     *\n     * @param {Number} angle\n     */\n    proto.setRotation = function (angle) {\n\n        this.rotation = angle;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the position and size of the markup.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n     * @param {{x: Number, y: Number}} position\n     * @param {Number} width\n     * @param {Number} height\n     */\n    proto.setSize = function (position, width, height) {\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n        this.size.y = height;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Used by the EditFrame to move the markup in Client Space coordinates\n     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n     */\n    proto.setPosition = function (x, y) {\n\n        this.position.x = x;\n        this.position.y = y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Signals that the markup has been created\n     */\n    proto.created = function () {\n        // Nothing //\n    };\n\n    proto.destroy = function () {\n\n        this.unselect();\n        this.setParent(null);\n    };\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"ellipse\";\n        metadata.position = [this.position.x, this.position.y].join(\" \");\n        metadata.size = [this.size.x, this.size.y].join(\" \");\n        metadata.rotation = String(this.rotation);\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    /**\n     *\n     * @param ctx\n     */\n    proto.renderToCanvas = function (ctx) {\n\n        // ellipse method is not supported by all browsers, took this implementation from\n        // Stack Overflow: http://goo.gl/64esnm\n        function ellipse(ctx, cx, cy, w, h) {\n\n            ctx.beginPath();\n            var lx = cx - w / 2,\n                rx = cx + w / 2,\n                ty = cy - h / 2,\n                by = cy + h / 2;\n\n            var magic = 0.551784;\n            var xmagic = magic * w / 2;\n            var ymagic = magic * h / 2;\n\n            ctx.moveTo(cx, ty);\n            ctx.bezierCurveTo(cx + xmagic, ty, rx, cy - ymagic, rx, cy);\n            ctx.bezierCurveTo(rx, cy + ymagic, cx + xmagic, by, cx, by);\n            ctx.bezierCurveTo(cx - xmagic, by, lx, cy + ymagic, lx, cy);\n            ctx.bezierCurveTo(lx, cy - ymagic, cx - xmagic, ty, cx, ty);\n            ctx.stroke();\n        }\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        var width = this.size.x - strokeWidth;\n        var height = this.size.y - strokeWidth;\n        var size = this.editor.sizeFromMarkupsToClient(width, height);\n        var center = this.editor.positionFromMarkupsToClient(this.position.x, this.position.y);\n\n        ctx.strokeStyle = namespaceUtils.composeRGBAString(strokeColor, strokeOpacity);\n        ctx.fillStyle = namespaceUtils.composeRGBAString(fillColor, fillOpacity);\n        ctx.lineWidth = this.editor.sizeFromMarkupsToClient(strokeWidth, 0).x;\n        ctx.translate(center.x, center.y);\n        ctx.rotate(this.rotation);\n        ctx.beginPath();\n        ellipse(ctx, 0, 0, size.x, size.y);\n        fillOpacity !== 0 && ctx.fill();\n        ctx.stroke();\n    };\n\n    namespace.MarkupCircle = MarkupCircle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param id\n     * @param editor\n     * @constructor\n     */\n    function MarkupCloud(id, editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n\n        this.type = namespace.MARKUP_TYPE_CLOUD;\n        this.lineJoint = 'round';\n\n        this.createSVG();\n        this.bindDomEvents();\n    }\n\n    MarkupCloud.prototype = Object.create(namespace.Markup.prototype);\n    MarkupCloud.prototype.constructor = MarkupCloud;\n\n    var proto = MarkupCloud.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeCloud(this.editor);\n    };\n\n    proto.createSVG = function () {\n        this.shape = namespaceUtils.createSvgElement('path');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     * Sets position and size in markup space coordinates.\n     * @param {Object} position\n     * @param {Object} size\n     */\n    proto.set = function (position, size) {\n\n        this.rotation = 0; // Reset angle //\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = size.x;\n        this.size.y = size.y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Given the 3d positions for top-left and bottom-right, it recalculates\n     * all the 2d values in client space.\n     */\n    proto.updateTransformMatrix = function () {\n\n        var originX = this.size.x * 0.5;\n        var originY = this.size.y * 0.5;\n\n        this.transformSvg = ['translate(', this.position.x, ',', this.position.y, ') ', 'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ') ', 'translate(', -originX, ',', -originY, ') '].join('');\n    };\n\n    /**\n     * Applies data values into DOM element style/attribute(s)\n     *\n     */\n    proto.updateStyle = function () {\n\n        this.updateTransformMatrix();\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        this.shape.setAttribute(\"transform\", this.transformSvg);\n        this.shape.setAttribute(\"stroke-width\", strokeWidth);\n        this.shape.setAttribute(\"stroke\", namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n        this.shape.setAttribute('fill', namespaceUtils.composeRGBAString(fillColor, fillOpacity));\n        this.shape.setAttribute('stroke-linejoin', this.lineJoint);\n\n        var pathMovements = this.getPathMovements();\n        var mappedMovements = pathMovements.map(function (moves, index) {\n            if (index === 0) {\n                //start\n                //moves = [x, y]\n                return ['M'].concat(moves.join(',')).join(' '); //M x,y\n            } else {\n                //curve\n                //moves = [[x, y], [x, y], [x, y]]\n                var bezier = moves.map(function (move) {\n                    return move.join(','); // \"x,y\"\n                }); // [\"x,y\", \"x,y\", \"x,y\"]\n                return ['C'].concat(bezier).join(' '); // \"C x,y x,y x,y\"\n            }\n        });\n        mappedMovements.push('Z');\n        this.shape.setAttribute('d', mappedMovements.join(' '));\n    };\n\n    /**\n     * Helper function that creates intermediate points given the\n     * current position and size.\n     * @returns {Array}\n     */\n    proto.getPathMovements = function () {\n\n        var strokeWidth = this.style['stroke-width'];\n\n        var vWidth = this.size.x === 0 ? 1 : this.size.x;\n        var vHeight = this.size.y === 0 ? 1 : this.size.y;\n\n        var arcWidth = strokeWidth * 4; // MarkupCloud coord space value\n        var arcHeight = strokeWidth * 3; // MarkupCloud coord space value\n\n        var offsetFromVertex = arcHeight + strokeWidth / 2;\n        var cloudWidth = vWidth - offsetFromVertex * 2; //remove 2x to account for the left and right offsets\n        var cloudHeight = vHeight - offsetFromVertex * 2; //remove 2x to account for the top and bottom offsets\n\n        //determine how many arcs to draw horizontally\n        var numOfHorizontalArcs = cloudWidth / arcWidth;\n        //and vertically\n        var numOfVerticalArcs = cloudHeight / arcWidth;\n\n        //the # of arcs may be a decimal. In that case, draw a smaller arc to complete/fill the given width/height\n        var partialHorizontalArc = numOfHorizontalArcs % 1; //get the decimal portion only\n        var partialVerticalArc = numOfVerticalArcs % 1; ////get the decimal portion only\n\n        //drop the decimal\n        numOfHorizontalArcs = parseInt(numOfHorizontalArcs, 10);\n        numOfVerticalArcs = parseInt(numOfVerticalArcs, 10);\n\n        var currentX = offsetFromVertex,\n            currentY = offsetFromVertex;\n\n        function bezierCurve(width, height, side) {\n            //left control point offset\n            var lcpOffset = width * 0.25;\n            //right control point offset\n            var rcpOffset = width * 0.75;\n\n            switch (side) {\n                case \"top\":\n                    return [[currentX + lcpOffset, currentY - height], //control point 1\n                    [currentX + rcpOffset, currentY - height], //control point 2\n                    [currentX += width, currentY] //end point\n                    ];\n                case \"right\":\n                    return [[currentX + height, currentY + lcpOffset], [currentX + height, currentY + rcpOffset], [currentX, currentY += width]];\n                case \"bottom\":\n                    return [[currentX - lcpOffset, currentY + height], [currentX - rcpOffset, currentY + height], [currentX -= width, currentY]];\n                case \"left\":\n                    return [[currentX - height, currentY - lcpOffset], [currentX - height, currentY - rcpOffset], [currentX, currentY -= width]];\n            }\n        }\n\n        //create a movements array with the first movement\n        var movements = [[currentX, currentY] //M\n        ];\n\n        //create the bezier curve for each side\n        ['top', 'right', 'bottom', 'left'].forEach(function (side) {\n            var horizontal = isHorizontal(side);\n            var numOfArcs = horizontal ? numOfHorizontalArcs : numOfVerticalArcs;\n            var partialArc = horizontal ? partialHorizontalArc : partialVerticalArc;\n\n            for (var i = 0; i < numOfArcs; i++) {\n                movements.push(bezierCurve(arcWidth, arcHeight, side));\n            }\n            if (partialArc !== 0) movements.push(bezierCurve(partialArc * arcWidth, arcHeight, side));\n        });\n\n        return movements;\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        var div = this.shape;\n        div.parentNode && div.parentNode.removeChild(div);\n        parent && parent.appendChild(div);\n    };\n\n    /**\n     * Changes the rotation of the markup to the given angle.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n     *\n     * @param {Number} angle\n     */\n    proto.setRotation = function (angle) {\n\n        this.rotation = angle;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the position and size of the markup.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n     * @param {{x: Number, y: Number}} position\n     * @param {Number} width\n     * @param {Number} height\n     */\n    proto.setSize = function (position, width, height) {\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n        this.size.y = height;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Used by the EditFrame to move the markup in Client Space coordinates\n     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n     */\n    proto.setPosition = function (x, y) {\n\n        this.position.x = x;\n        this.position.y = y;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Signals that the markup has been created\n     */\n    proto.created = function () {};\n\n    proto.destroy = function () {\n\n        this.unselect();\n        this.setParent(null);\n    };\n\n    /**\n     *\n     * @param bounds\n     */\n    proto.constrainsToBounds = function (bounds) {};\n\n    function isHorizontal(side) {\n\n        return side === 'top' || side === 'bottom';\n    }\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"cloud\";\n        metadata.position = [this.position.x, this.position.y].join(\" \");\n        metadata.size = [this.size.x, this.size.y].join(\" \");\n        metadata.rotation = String(this.rotation);\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    /**\n     * Renders the Markup onto an HTML-5 canvas surface.\n     * @param {Object} ctx - Canvas rendering context\n     */\n    proto.renderToCanvas = function (ctx) {\n\n        var m1 = new THREE.Matrix4().makeTranslation(-this.size.x * 0.5, -this.size.y * 0.5, 0);\n        var m2 = new THREE.Matrix4().makeRotationZ(-this.rotation);\n        var m3 = new THREE.Matrix4().makeTranslation(this.position.x, this.position.y, 0);\n        var transform = m3.multiply(m2).multiply(m1);\n\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        ctx.strokeStyle = namespaceUtils.composeRGBAString(strokeColor, strokeOpacity);\n        ctx.fillStyle = namespaceUtils.composeRGBAString(fillColor, fillOpacity);\n        ctx.lineJoin = this.lineJoint;\n        ctx.lineWidth = this.editor.sizeFromMarkupsToClient(this.style['stroke-width'], 0).x;\n        ctx.beginPath();\n\n        var vector3 = new THREE.Vector3();\n        var mappingFn = this.editor.positionFromMarkupsToClient.bind(this.editor);\n        var pathMovements = this.getPathMovements();\n        pathMovements.forEach(function (moves, index) {\n            if (index === 0) {\n                //start or svg M\n                //moves = [x, y]\n                vector3.x = moves[0];\n                vector3.y = moves[1];\n                vector3.z = 0;\n                vector3 = vector3.applyMatrix4(transform);\n                var pos = mappingFn(vector3.x, vector3.y);\n                ctx.moveTo(pos.x, pos.y);\n            } else {\n                //curve or svg C\n                //moves = [[x, y], [x, y], [x, y]]\n                vector3.x = moves[0][0];\n                vector3.y = moves[0][1];\n                vector3.z = 0;\n                vector3 = vector3.applyMatrix4(transform);\n                var cp1 = mappingFn(vector3.x, vector3.y);\n\n                vector3.x = moves[1][0];\n                vector3.y = moves[1][1];\n                vector3.z = 0;\n                vector3 = vector3.applyMatrix4(transform);\n                var cp2 = mappingFn(vector3.x, vector3.y);\n\n                vector3.x = moves[2][0];\n                vector3.y = moves[2][1];\n                vector3.z = 0;\n                vector3 = vector3.applyMatrix4(transform);\n                var end = mappingFn(vector3.x, vector3.y);\n\n                ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);\n            }\n        });\n        ctx.closePath();\n        fillOpacity !== 0 && ctx.fill();\n        ctx.stroke();\n    };\n\n    namespace.MarkupCloud = MarkupCloud;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param id\n     * @param editor\n     * @constructor\n     */\n    function MarkupFreehand(id, editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n\n        this.type = namespace.MARKUP_TYPE_FREEHAND;\n\n        // Position represents top-left (instead of center as in most other markups).\n        this.iniSize = { x: 1, y: 1 };\n\n        this.createSVG();\n        this.bindDomEvents();\n    }\n\n    MarkupFreehand.prototype = Object.create(namespace.Markup.prototype);\n    MarkupFreehand.prototype.constructor = MarkupFreehand;\n\n    var proto = MarkupFreehand.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeFreehand(this.editor);\n    };\n\n    proto.createSVG = function () {\n        this.shape = namespaceUtils.createSvgElement('path');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     * Sets top-left and bottom-right values in client space coordinates (2d).\n     *\n     * @param position\n     * @param size\n     * @param locations\n     */\n    proto.set = function (position, size, locations) {\n\n        this.rotation = 0; // Reset angle //\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = size.x;\n        this.size.y = size.y;\n        this.locations = locations.concat();\n\n        this.iniSize.x = size.x === 0 ? 1 : size.x;\n        this.iniSize.y = size.y === 0 ? 1 : size.y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Given the 3d positions for top-left and bottom-right, it recalculates\n     * all the 2d values in client space.\n     */\n    proto.updateTransformMatrix = function () {\n\n        var scaleX = this.size.x / this.iniSize.x;\n        var scaleY = this.size.y / this.iniSize.y;\n\n        this.transformSvg = ['translate(', this.position.x, ',', this.position.y, ') ', 'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ') ', 'scale(', scaleX, ',', scaleY, ') '].join('');\n    };\n\n    /**\n     * Applies data values into DOM element style/attribute(s)\n     *\n     */\n    proto.updateStyle = function () {\n\n        this.updateTransformMatrix();\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n\n        this.shape.setAttribute(\"transform\", this.transformSvg);\n        this.shape.setAttribute(\"stroke-width\", strokeWidth);\n        this.shape.setAttribute(\"stroke\", namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n        this.shape.setAttribute('fill', 'none');\n        this.shape.setAttribute('opacity', namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n\n        var pathData = this.locations.map(function (point, i) {\n            if (i === 0) {\n                return ['M'].concat([point.x, point.y]).join(' ');\n            } else {\n                return ['L'].concat([point.x, point.y]).join(' ');\n            }\n        }).join(' ');\n        this.shape.setAttribute('d', pathData);\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        var div = this.shape;\n        div.parentNode && div.parentNode.removeChild(div);\n        parent && parent.appendChild(div);\n    };\n\n    /**\n     * Changes the rotation of the markup to the given angle.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n     *\n     * @param {Number} angle\n     */\n    proto.setRotation = function (angle) {\n\n        this.rotation = angle;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the position and size of the markup.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n     * @param {{x: Number, y: Number}} position\n     * @param {Number} width\n     * @param {Number} height\n     */\n    proto.setSize = function (position, width, height) {\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n        this.size.y = height;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Used by the EditFrame to move the markup in Client Space coordinates\n     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n     */\n    proto.setPosition = function (x, y) {\n\n        this.position.x = x;\n        this.position.y = y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Signals that the markup has been created\n     */\n    proto.created = function () {\n        // Nothing //\n    };\n\n    proto.destroy = function () {\n\n        this.unselect();\n        this.setParent(null);\n    };\n\n    /**\n     *\n     * @param bounds\n     */\n    proto.constrainsToBounds = function (bounds) {};\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"freehand\";\n        metadata.position = [this.position.x, this.position.y].join(\" \");\n        metadata.size = [this.size.x, this.size.y].join(\" \");\n        metadata.rotation = String(this.rotation);\n        metadata.locations = this.locations.map(function (point) {\n            return [point.x, point.y].join(\" \");\n        }).join(\" \");\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    proto.renderToCanvas = function (ctx) {\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n\n        var scaleX = this.size.x / this.iniSize.x;\n        var scaleY = this.size.y / this.iniSize.y;\n        var m0 = new THREE.Matrix4().makeScale(scaleX, scaleY, 1);\n        var m1 = new THREE.Matrix4().makeRotationZ(-this.rotation);\n        var m2 = new THREE.Matrix4().makeTranslation(this.position.x, this.position.y, 0);\n        var transform = m2.multiply(m1).multiply(m0);\n\n        ctx.strokeStyle = namespaceUtils.composeRGBAString(strokeColor, strokeOpacity);\n        ctx.lineWidth = this.editor.sizeFromMarkupsToClient(strokeWidth, 0).x;\n        ctx.beginPath();\n\n        var that = this;\n        var vector3 = new THREE.Vector3();\n        this.locations.forEach(function (point, i) {\n            vector3.x = point.x;\n            vector3.y = point.y;\n            vector3.z = 0;\n            vector3 = vector3.applyMatrix4(transform);\n            point = that.editor.positionFromMarkupsToClient(vector3.x, vector3.y);\n            if (i === 0) {\n                ctx.moveTo(point.x, point.y);\n            } else {\n                ctx.lineTo(point.x, point.y);\n            }\n        });\n        ctx.stroke();\n    };\n\n    namespace.MarkupFreehand = MarkupFreehand;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * @class\n     * Implements a Rectangle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.\n     * Included in documentation as an example of how to create\n     * a specific markup type. Developers are encourage to look into this class's source code and copy\n     * as much code as they need. Find link to source code below.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @extends Autodesk.Viewing.Extensions.Markups.Core.Markup\n     *\n     * @param {number} id\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n     * @constructor\n     */\n    function MarkupRectangle(id, editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n\n        this.type = namespace.MARKUP_TYPE_RECTANGLE;\n\n        this.createSVG();\n        this.bindDomEvents();\n    }\n\n    MarkupRectangle.prototype = Object.create(namespace.Markup.prototype);\n    MarkupRectangle.prototype.constructor = MarkupRectangle;\n\n    var proto = MarkupRectangle.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeRectangle(this.editor);\n    };\n\n    proto.createSVG = function () {\n        this.shape = namespaceUtils.createSvgElement('rect');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     * Sets position and size in markup space coordinates\n     * @param {Object} position\n     * @param {Object} size\n     */\n    proto.set = function (position, size) {\n\n        this.rotation = 0; // Reset angle //\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = size.x;\n        this.size.y = size.y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Given the 3d positions for top-left and bottom-right, it recalculates\n     * all the 2d values in client space.\n     */\n    proto.updateTransformMatrix = function () {\n\n        var strokeWidth = this.style['stroke-width'];\n\n        var originX = Math.max(this.size.x - strokeWidth, 0) * 0.5;\n        var originY = Math.max(this.size.y - strokeWidth, 0) * 0.5;\n\n        this.transformSvg = ['translate(', this.position.x, ',', this.position.y, ') ', 'rotate(', namespaceUtils.radiansToDegrees(-this.rotation), ') ', 'translate(', -originX, ',', -originY, ') '].join('');\n    };\n\n    /**\n     * Applies data values into DOM element style/attribute(s)\n     *\n     */\n    proto.updateStyle = function () {\n\n        this.updateTransformMatrix();\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        this.shape.setAttribute(\"transform\", this.transformSvg);\n        this.shape.setAttribute(\"stroke-width\", strokeWidth);\n        this.shape.setAttribute(\"stroke\", namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n        this.shape.setAttribute('fill', namespaceUtils.composeRGBAString(fillColor, fillOpacity));\n        this.shape.setAttribute('width', Math.max(this.size.x - strokeWidth, 0));\n        this.shape.setAttribute('height', Math.max(this.size.y - strokeWidth, 0));\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        var div = this.shape;\n        div.parentNode && div.parentNode.removeChild(div);\n        parent && parent.appendChild(div);\n    };\n\n    /**\n     * Changes the rotation of the markup to the given angle.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetRotation edit action\n     *\n     * @param {Number} angle\n     */\n    proto.setRotation = function (angle) {\n\n        this.rotation = angle;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Changes the position and size of the markup.\n     * This gets called by the Autodesk.Viewing.Extensions.Markups.Core.SetSize edit action\n     * @param {{x: Number, y: Number}} position\n     * @param {Number} width\n     * @param {Number} height\n     */\n    proto.setSize = function (position, width, height) {\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n        this.size.y = height;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Used by the EditFrame to move the markup in Client Space coordinates\n     * @param {Number} x - New X location for the markup. Notice that markups are centered on this value.\n     * @param {Number} y - New Y location for the markup. Notice that markups are centered on this value.\n     */\n    proto.setPosition = function (x, y) {\n\n        this.position.x = x;\n        this.position.y = y;\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    /**\n     * Signals that the markup has been created\n     */\n    proto.created = function () {};\n\n    proto.destroy = function () {\n\n        this.unselect();\n        this.setParent(null);\n    };\n\n    /**\n     *\n     * @param bounds\n     */\n    proto.constrainsToBounds = function (bounds) {};\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"rectangle\";\n        metadata.position = [this.position.x, this.position.y].join(\" \");\n        metadata.size = [this.size.x, this.size.y].join(\" \");\n        metadata.rotation = String(this.rotation);\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    proto.renderToCanvas = function (ctx) {\n\n        var strokeWidth = this.style['stroke-width'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n\n        var width = this.size.x - strokeWidth;\n        var height = this.size.y - strokeWidth;\n        var size = this.editor.sizeFromMarkupsToClient(width, height);\n        var clientWidth = size.x;\n        var clientHeight = size.y;\n        var clientCenter = this.editor.positionFromMarkupsToClient(this.position.x, this.position.y);\n\n        ctx.strokeStyle = namespaceUtils.composeRGBAString(strokeColor, strokeOpacity);\n        ctx.fillStyle = namespaceUtils.composeRGBAString(fillColor, fillOpacity);\n        ctx.lineWidth = this.editor.sizeFromMarkupsToClient(strokeWidth, 0).x;\n        ctx.translate(clientCenter.x, clientCenter.y);\n        ctx.rotate(this.getRotation());\n        fillOpacity !== 0 && ctx.fillRect(clientWidth / -2, clientHeight / -2, clientWidth, clientHeight);\n        ctx.strokeRect(clientWidth / -2, clientHeight / -2, clientWidth, clientHeight);\n    };\n\n    namespace.MarkupRectangle = MarkupRectangle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * Arrow Markup.\n     * @constructor\n     */\n    function MarkupText(id, editor, size) {\n\n        var styleAttributes = ['font-size', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity', 'font-family', 'font-style', 'font-weight'];\n        namespace.Markup.call(this, id, editor, styleAttributes);\n        this.constraintRotation = true;\n\n        this.type = namespace.MARKUP_TYPE_TEXT;\n\n        this.size.x = size.x;\n        this.size.y = size.y;\n        this.currentText = \"\";\n        this.currentTextLines = [\"\"];\n        this.textDirty = true;\n\n        // Note: We could have this property be a style property.\n        // However, there is no need for this property to be exposed to the user for alteration\n        // This value is a percentage of the font size used to offset vertically 2 text lines\n        // of the same paragraph.\n        // Notice that this value is used by EditorTextInput.js\n        this.lineHeight = 130;\n\n        this.createSvg();\n        this.bindDomEvents();\n    }\n\n    MarkupText.prototype = Object.create(namespace.Markup.prototype);\n    MarkupText.prototype.constructor = MarkupText;\n\n    var proto = MarkupText.prototype;\n\n    proto.getEditMode = function () {\n\n        return new namespace.EditModeText(this.editor);\n    };\n\n    proto.createSvg = function () {\n\n        // Used to clip rendering of text.\n        // We are particularly interested in vertical clipping\n        this.clipPath = namespaceUtils.createSvgElement('clipPath');\n        this.clipPathId = 'CO2_Markup_clip_' + this.id;\n        this.clipPath.setAttribute('id', this.clipPathId);\n        this.clipPath.removeAttribute('pointer-events');\n\n        // The actual clipping shape\n        this.clipRect = namespaceUtils.createSvgElement('rect');\n        this.clipRect.removeAttribute('pointer-events');\n        this.clipPath.appendChild(this.clipRect); // Add to clipPath\n\n        this.shape = namespaceUtils.createSvgElement('text');\n        this.shapeBg = namespaceUtils.createSvgElement('rect');\n    };\n\n    proto.bindDomEvents = function () {\n        if (namespaceUtils.isTouchDevice()) {\n            this.bindTouchEvents(this.shape);\n        }\n        this.shape.addEventListener(\"mousedown\", this.onMouseDown.bind(this), true);\n        this.shape.addEventListener(\"mouseout\", function () {\n            this.highlight(false);\n        }.bind(this));\n        this.shape.addEventListener(\"mouseover\", function () {\n            this.highlight(true);\n        }.bind(this));\n    };\n\n    /**\n     *\n     * @param {String} position\n     * @param {String} size\n     * @param {String} textString\n     * @param {Array} textLines\n     */\n    proto.set = function (position, size, textString, textLines) {\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = size.x;\n        this.size.y = size.y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n        this.setText(textString, textLines);\n    };\n\n    proto.updateTransformMatrix = function () {\n\n        var ox = this.size.x * 0.5;\n        var oy = this.size.y * 0.5;\n        var pos_x = this.position.x - ox;\n        var pos_y = this.position.y - oy;\n\n        this.transformSvg = ['translate(', pos_x, ',', pos_y, ') ', 'scale(', 1, ',', -1, ') '].join('');\n    };\n\n    proto.setPosition = function (x, y) {\n\n        this.position.x = x;\n        this.position.y = y;\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    proto.setSize = function (position, width, height) {\n\n        var recalcLines = this.size.x !== width;\n\n        this.position.x = position.x;\n        this.position.y = position.y;\n        this.size.x = width;\n        this.size.y = height;\n\n        if (recalcLines) {\n            var newLines = this.calcTextLines();\n            if (!this.linesAreEqual(newLines)) {\n                this.currentTextLines = newLines;\n                this.textDirty = true;\n                this.forceRedraw();\n            }\n        }\n\n        this.updateTransformMatrix();\n        this.updateStyle();\n    };\n\n    proto.calcTextLines = function () {\n        // TODO: This is ugly as hell. We need a better approach to this.\n        return this.editor.editMode.textInputHelper.getTextValuesForMarkup(this).lines;\n    };\n\n    proto.setStyle = function (style) {\n        namespaceUtils.copyStyle(style, this.style);\n        this.updateStyle(true); // For Text Markup we always force a re-render of text\n    };\n\n    /**\n     *\n     * @param {Array} lines - Array of strings\n     * @private\n     */\n    proto.linesAreEqual = function (lines) {\n        var curr = this.currentTextLines;\n        if (lines.length !== curr.length) return false;\n\n        var len = curr.length;\n        for (var i = 0; i < len; ++i) {\n            if (lines[i] !== curr[i]) return false;\n        }\n\n        return true;\n    };\n\n    /**\n     * Specifies the parent layer which will contain the markup.\n     * @param {HTMLElement} parent\n     */\n    proto.setParent = function (parent) {\n\n        // NOTE: Do not add clipPath into a <def> node.\n        // Reason: It doesn't work in Chrome (Firefox did work).\n        var currentParent = this.clipPath.parentNode;\n        currentParent && currentParent.removeChild(this.clipPath);\n        parent && parent.appendChild(this.clipPath);\n\n        currentParent = this.shapeBg.parentNode;\n        currentParent && currentParent.removeChild(this.shapeBg);\n        parent && parent.appendChild(this.shapeBg);\n\n        currentParent = this.shape.parentNode;\n        currentParent && currentParent.removeChild(this.shape);\n        parent && parent.appendChild(this.shape);\n    };\n\n    /**\n     *\n     * @param {String} text\n     */\n    proto.setText = function (text) {\n\n        this.currentText = text;\n        this.currentTextLines = this.calcTextLines();\n        this.textDirty = true;\n        this.updateStyle();\n    };\n\n    /**\n     * Returns the raw string value\n     * @returns {String}\n     */\n    proto.getText = function () {\n\n        return this.currentText;\n    };\n\n    /**\n     * Returns a shallow copy of the text lines used for rendering SVG text\n     * @returns {Array.<String>}\n     */\n    proto.getTextLines = function () {\n\n        return this.currentTextLines.concat();\n    };\n\n    /**\n     * Applies data values into DOM element style/attribute(s)\n     *\n     * @param {Boolean} [forceDirty] - Whether we want to re-render the text\n     */\n    proto.updateStyle = function (forceDirty) {\n\n        this.updateTransformMatrix();\n\n        var fontSize = this.style['font-size'];\n        var strokeColor = this.highlighted ? this.highlightColor : this.style['stroke-color'];\n        var strokeOpacity = this.style['stroke-opacity'];\n\n        // See standard: http://www.w3.org/TR/SVG/fonts.html\n        this.shape.setAttribute(\"font-family\", this.style['font-family']);\n        this.shape.setAttribute(\"font-size\", fontSize);\n        this.shape.setAttribute('font-weight', this.style['font-weight'] ? 'bold' : '');\n        this.shape.setAttribute(\"font-style\", this.style['font-style'] ? 'italic' : '');\n        this.shape.setAttribute(\"fill\", namespaceUtils.composeRGBAString(strokeColor, strokeOpacity));\n\n        // SVG text (as opposed to DIV text) is rendered \"on top\" of the indicated Y position.\n        // Thus, we need to offset it down a bit, and for that we need to take care into account\n        // the text bounding box's height (and maybe its y coordinate).\n        var bbox = this.shape.getBBox(); // Assumes font style is already in place.\n        var verticalTransform = ['translate(0, ', -this.size.y + fontSize, ')'].join('');\n        this.shape.setAttribute(\"transform\", this.transformSvg + verticalTransform);\n        this.shape.setAttribute('clip-path', 'url(#' + this.clipPathId + ')');\n\n        // Must be called AFTER shape's styles are in place.\n        if (this.textDirty || forceDirty) {\n            if (forceDirty) {\n                this.currentTextLines = this.calcTextLines();\n            }\n            this.rebuildTextSvg();\n            this.textDirty = false;\n        }\n\n        // Update clipping rect\n        this.clipRect.setAttribute('x', \"0\");\n        this.clipRect.setAttribute('y', bbox.y); // Negative number\n        this.clipRect.setAttribute('width', this.size.x);\n        this.clipRect.setAttribute('height', this.size.y);\n\n        // Update visible background rectangle\n        var fillColor = this.style['fill-color'];\n        var fillOpacity = this.style['fill-opacity'];\n        verticalTransform = ['translate(0, ', -this.size.y, ')'].join('');\n        this.shapeBg.setAttribute(\"transform\", this.transformSvg + verticalTransform);\n        this.shapeBg.setAttribute('width', this.size.x);\n        this.shapeBg.setAttribute('height', this.size.y);\n        this.shapeBg.setAttribute(\"stroke-width\", '0');\n        this.shapeBg.setAttribute('fill', namespaceUtils.composeRGBAString(fillColor, fillOpacity));\n    };\n\n    /**\n     * Re-creates SVG tags that render SVG text.\n     * Each line is placed around tspan tags which are vertically offset to each other.\n     */\n    proto.rebuildTextSvg = function () {\n\n        // Begin by removing all children (if any).\n        while (this.shape.childNodes.length > 0) {\n            this.shape.removeChild(this.shape.childNodes[0]);\n        }\n\n        // For each line, create a tspan, add as child and offset it vertically.\n        var dx = 0;\n        var dy = 0;\n        var yOffset = this.getLineHeight();\n        this.currentTextLines.forEach(function (line) {\n            var tspan = namespaceUtils.createSvgElement('tspan');\n            tspan.setAttribute('x', dx);\n            tspan.setAttribute('y', dy);\n            tspan.textContent = line;\n            this.shape.appendChild(tspan);\n            dy += yOffset;\n        }.bind(this));\n    };\n\n    proto.setMetadata = function () {\n\n        var metadata = namespaceUtils.cloneStyle(this.style);\n\n        metadata.type = \"label\";\n        metadata.position = [this.position.x, this.position.y].join(\" \");\n        metadata.size = [this.size.x, this.size.y].join(\" \");\n        metadata.text = String(this.currentText);\n\n        return namespaceUtils.addMarkupMetadata(this.shape, metadata);\n    };\n\n    /**\n     * Helper method that returns the font size in client space coords.\n     * @returns {Number}\n     */\n    proto.getClientFontSize = function () {\n\n        return this.editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n    };\n\n    proto.getLineHeight = function () {\n        return this.style['font-size'] * (this.lineHeight * 0.01);\n    };\n\n    proto.forceRedraw = function () {\n\n        // In chrome the text is not rendered until its style changes after creation.\n        // With this hack the text is drawn correctly.\n        window.requestAnimationFrame(function () {\n            this.highlighted = !this.highlighted;\n            this.updateStyle();\n            this.highlighted = !this.highlighted;\n            this.updateStyle();\n        }.bind(this));\n    };\n\n    /**\n     * Renders the lines of text to the canvas.\n     * This method does not attempt to figure out how to wrap text. Instead, it expects\n     * a set of lines that are already adjusted to fit in the given space.\n     * All this does it renders them in the correct vertical position\n     *\n     * @param {CanvasRenderingContext2D} ctx - the canvas context to draw on\n     * @param {String[]} lines - the lines of text to render already adjusted to wrap properly\n     * @param {Number} lineHeight - the height of each line\n     * @param {Number} maxHeight - maximum height the text will render to\n     */\n    function renderLinesOfText(ctx, lines, lineHeight, maxHeight) {\n\n        var y = 0; //only the vertical position changes\n        lines.forEach(function (line) {\n            //check if we're over the max height allowed\n            //if so, just end\n            if (y + lineHeight > maxHeight) {\n                return;\n            }\n            ctx.fillText(line, 0, y);\n            y += lineHeight;\n        });\n    }\n\n    proto.renderToCanvas = function (ctx) {\n\n        var fontFamily = this.style['font-family'];\n        var fontStyle = this.style['font-style'] ? \"italic\" : \"\";\n        var fontWeight = this.style['font-weight'] ? \"bold\" : \"\";\n        var strokeColor = this.style['stroke-color'];\n        var fontOpacity = this.style['stroke-opacity'];\n        var fontSize = this.getClientFontSize();\n        var lineHeight = fontSize * (this.lineHeight * 0.01);\n\n        //var rotation = this.getRotation(); TODO: Revisit rotation when it becomes available\n        var center = this.editor.positionFromMarkupsToClient(this.position.x, this.position.y);\n        var clientSize = this.editor.sizeFromMarkupsToClient(this.size.x, this.size.y);\n\n        // Background rect\n        ctx.save();\n        {\n            var fillColor = this.style['fill-color'];\n            var fillOpacity = this.style['fill-opacity'];\n            ctx.fillStyle = namespaceUtils.composeRGBAString(fillColor, fillOpacity);\n            ctx.translate(center.x, center.y);\n            //ctx.rotate(rotation);\n            fillOpacity !== 0 && ctx.fillRect(clientSize.x * -0.5, clientSize.y * -0.5, clientSize.x, clientSize.y);\n        }\n        ctx.restore();\n\n        // Text\n        ctx.fillStyle = strokeColor;\n        ctx.strokeStyle = strokeColor;\n        ctx.textBaseline = 'top';\n        ctx.translate(center.x - clientSize.x * 0.5, center.y - clientSize.y * 0.5);\n        //ctx.rotate(rotation);\n        ctx.font = fontStyle + \" \" + fontWeight + \" \" + fontSize + \"px \" + fontFamily;\n        ctx.globalAlpha = fontOpacity;\n        renderLinesOfText(ctx, this.currentTextLines, lineHeight, clientSize.y);\n    };\n\n    namespace.MarkupText = MarkupText;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    function MarkupTool() {\n\n        Autodesk.Viewing.ToolInterface.call(this);\n        this.names = [\"markups.core\"];\n        this.panTool = null;\n        this.allowNav = false;\n\n        this.coreExt = null;\n        this.hotkeysEnabled = true;\n\n        var _ctrlDown = false;\n        var _shiftDown = false;\n\n        // Non-ToolInterface methods //\n\n        this.allowNavigation = function (allow) {\n            this.allowNav = allow;\n        };\n        this.setCoreExtension = function (coreExt) {\n            this.coreExt = coreExt;\n        };\n        this.setHotkeysEnabled = function (enabled) {\n            this.hotkeysEnabled = enabled;\n        };\n\n        // ToolInterface methods //\n\n        this.activate = function (name, viewerApi) {\n            this.panTool = viewerApi.toolController.getTool(\"pan\");\n            if (this.panTool) {\n                this.panTool.activate(\"pan\"); // TODO: What if we want \"zoom\" here?\n            }\n        };\n        this.deactivate = function (name) {\n            if (this.panTool) {\n                this.panTool.deactivate(\"pan\");\n            }\n            this.panTool = null;\n        };\n\n        this.handleKeyDown = function (event, keyCode) {\n\n            if (!this.hotkeysEnabled) {\n                return true; // Consume event\n            }\n\n            // Don't propagate key handling down to tool //\n\n            switch (keyCode) {\n                case Autodesk.Viewing.KeyCode.CONTROL:\n                    _ctrlDown = true;break;\n                case Autodesk.Viewing.KeyCode.SHIFT:\n                    _shiftDown = true;break;\n\n                case Autodesk.Viewing.KeyCode.x:\n                    _ctrlDown && !this.allowNav && this.coreExt.cut();break;\n                case Autodesk.Viewing.KeyCode.c:\n                    _ctrlDown && !this.allowNav && this.coreExt.copy();break;\n                case Autodesk.Viewing.KeyCode.v:\n                    _ctrlDown && !this.allowNav && this.coreExt.paste();break;\n                case Autodesk.Viewing.KeyCode.d:\n                    if (_ctrlDown && !this.allowNav) {\n                        // Duplicate\n                        this.coreExt.copy();\n                        this.coreExt.paste();\n                    }\n                    break;\n                case Autodesk.Viewing.KeyCode.z:\n                    if (_ctrlDown && !_shiftDown && !this.allowNav) {\n                        this.coreExt.undo();\n                    } else if (_ctrlDown && _shiftDown && !this.allowNav) {\n                        this.coreExt.redo(); // Also support Ctrl+Y\n                    }\n                    break;\n                case Autodesk.Viewing.KeyCode.y:\n                    _ctrlDown && !this.allowNav && this.coreExt.redo();break; // Also support ctrl+shift+z\n                case Autodesk.Viewing.KeyCode.ESCAPE:\n                    this.coreExt.selectMarkup(null);break;\n                default:\n                    break;\n            }\n\n            return true; // Consume event\n        };\n        this.handleKeyUp = function (event, keyCode) {\n\n            if (!this.hotkeysEnabled) {\n                return true; // Consume event\n            }\n\n            // Don't propagate key handling down to tool\n\n            switch (keyCode) {\n                case Autodesk.Viewing.KeyCode.CONTROL:\n                    _ctrlDown = false;break;\n                case Autodesk.Viewing.KeyCode.SHIFT:\n                    _shiftDown = false;break;\n                default:\n                    break;\n            }\n\n            return true; // Consume event ONLY\n        };\n\n        this.update = function () {\n            if (this.allowNav && this.panTool && this.panTool.update) {\n                return this.panTool.update();\n            }\n            return false;\n        };\n\n        this.handleSingleClick = function (event, button) {\n            if (this.allowNav && this.panTool && this.panTool.handleSingleClick) {\n                return this.panTool.handleSingleClick(event, button);\n            }\n            return true; // Consume event\n        };\n        this.handleDoubleClick = function (event, button) {\n            if (this.allowNav && this.panTool && this.panTool.handleDoubleClick) {\n                return this.panTool.handleDoubleClick(event, button);\n            }\n            return true; // Consume event\n        };\n        this.handleSingleTap = function (event) {\n            if (this.allowNav && this.panTool && this.panTool.handleSingleTap) {\n                return this.panTool.handleSingleTap(event);\n            }\n            return true; // Consume event\n        };\n        this.handleDoubleTap = function (event) {\n            if (this.allowNav && this.panTool && this.panTool.handleDoubleTap) {\n                return this.panTool.handleDoubleTap(event);\n            }\n            return true; // Consume event\n        };\n        this.handleWheelInput = function (delta) {\n            if (this.allowNav && this.panTool && this.panTool.handleWheelInput) {\n                return this.panTool.handleWheelInput(delta);\n            }\n            return true; // Consume event\n        };\n        this.handleButtonDown = function (event, button) {\n            if (this.allowNav && this.panTool && this.panTool.handleButtonDown) {\n                return this.panTool.handleButtonDown(event, button);\n            }\n            return true; // Consume event\n        };\n        this.handleButtonUp = function (event, button) {\n            if (this.allowNav && this.panTool && this.panTool.handleButtonUp) {\n                return this.panTool.handleButtonUp(event, button);\n            }\n            return true; // Consume event\n        };\n        this.handleMouseMove = function (event) {\n            if (this.allowNav && this.panTool && this.panTool.handleMouseMove) {\n                return this.panTool.handleMouseMove(event);\n            }\n            return true; // Consume event\n        };\n        this.handleGesture = function (event) {\n            if (this.allowNav && this.panTool && this.panTool.handleGesture) {\n                return this.panTool.handleGesture(event);\n            }\n            return true; // Consume event\n        };\n        this.handleBlur = function (event) {\n            if (this.allowNav && this.panTool && this.panTool.handleBlur) {\n                return this.panTool.handleBlur(event);\n            }\n            return true; // Consume event\n        };\n    }\n\n    namespace.MarkupTool = MarkupTool;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core');\n    var namespaceUtils = AutodeskNamespace('Autodesk.Viewing.Extensions.Markups.Core.Utils');\n\n    /**\n     * @class\n     * Extension used to overlay 2d markups over 2d and 3d models.\n     *\n     * @tutorial feature_markup\n     * @param {Autodesk.Viewing.Viewer3D} viewer - Viewer instance used to operate on.\n     * @param {Object} options - Same Dictionary object passed into [Viewer3D]{@link Autodesk.Viewing.Viewer3D}'s constructor.\n     * @param {Boolean} [options.markupBypassOrthoCam] - Whether orthographic camera is forced onto 3d models when calling\n     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}.\n     * @param {Boolean} [options.markupDisableHotkeys] - Disables hotkeys for copy, cut, paste, duplicate, undo, redo and deselect.\n     * @param {Autodesk.Viewing.ToolInterface} [options.markupToolClass] - Class override for input handling.\n     * Use it to override/extend default hotkeys and/or mouse/gesture input.\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @constructor\n     */\n    function MarkupsCore(viewer, options) {\n\n        Autodesk.Viewing.Extension.call(this, viewer, options);\n\n        this.options = this.options || {};\n        this.markups = [];\n        this.styles = {};\n\n        this.duringViewMode = false;\n        this.duringEditMode = false;\n\n        // Add action manager.\n        this.actionManager = new namespace.EditActionManager(50); // history of 50 actions.\n        this.actionManager.addEventListener(namespace.EVENT_HISTORY_CHANGED, this.onEditActionHistoryChanged.bind(this));\n\n        this.nextId = 0; // Used to identify markups by id during an edit session.\n\n        // Clipboard.\n        this.clipboard = new namespace.Clipboard(this);\n\n        // Default Input handler.\n        this.input = new namespace.InputHandler();\n\n        // Extension will dispatch events.\n        namespaceUtils.addTraitEventDispatcher(this);\n\n        // Handled events.\n        this.onCameraChangeBinded = this.onCameraChange.bind(this);\n        this.onViewerResizeBinded = function (event) {\n            // This is ugly, but we need to do this twice\n            var self = this;\n            // First usage is to avoid a blinking scenario\n            self.onViewerResize(event);\n            requestAnimationFrame(function () {\n                // Second one is to actually make it work on some resize scenarios.\n                // Check the unlikely scenario that we are no longer in view mode.\n                if (self.duringViewMode) {\n                    self.onViewerResize(event);\n                }\n            });\n        }.bind(this);\n        this.onMarkupDraggingBinded = this.onMarkupDragging.bind(this);\n        this.onMarkupSelectedBinded = this.onMarkupSelected.bind(this);\n        this.onMarkupEnterEditionBinded = this.onMarkupEnterEdition.bind(this);\n        this.onMarkupCancelEditionBinded = this.onMarkupCancelEdition.bind(this);\n        this.onMarkupDeleteEditionBinded = this.onMarkupDeleteEdition.bind(this);\n    }\n\n    MarkupsCore.prototype = Object.create(Autodesk.Viewing.Extension.prototype);\n    MarkupsCore.prototype.constructor = MarkupsCore;\n    namespace.MarkupsCore = MarkupsCore;\n\n    /*\n     * Event types\n     */\n    namespace.EVENT_ENTER_EDIT_MODE = \"EVENT_MARKUP_CORE_ENTER_EDIT_MODE\";\n    namespace.EVENT_LEAVE_EDIT_MODE = \"EVENT_MARKUP_CORE_LEAVE_EDIT_MODE\";\n    namespace.EVENT_SELECTION_CHANGED = \"EVENT_MARKUP_SELECTION_CHANGED\";\n\n    var proto = MarkupsCore.prototype;\n\n    proto.load = function () {\n\n        // Add layer where annotations will actually live\n        var svg = this.svg = namespaceUtils.createSvgElement('svg');\n        namespaceUtils.setSvgParentAttributes(svg);\n\n        // NOTE: Required since LMV renders Y coordinates upwards,\n        // while browser's Y coordinates goes downwards.\n        var svgStyle = new namespaceUtils.DomElementStyle();\n        svgStyle.setAttribute('position', 'absolute');\n        svgStyle.setAttribute('left', '0');\n        svgStyle.setAttribute('top', '0');\n        svgStyle.setAttribute('transform', 'scale(1,-1)', { allBrowsers: true });\n        svgStyle.setAttribute('transformOrigin', '0, 0', { allBrowsers: true });\n        svgStyle.setAttribute('cursor', 'default');\n        svg.setAttribute('style', svgStyle.getStyleString());\n\n        this.bounds = { x: 0, y: 0, width: 0, height: 0 };\n\n        this.input.attachTo(this);\n\n        //Instantiate edit frame.\n        this.editFrame = new namespace.EditFrame(this.viewer.container, this);\n        this.editFrame.addEventListener(namespace.EVENT_EDITFRAME_EDITION_START, function () {\n            this.disableMarkupInteractions(true);\n        }.bind(this));\n        this.editFrame.addEventListener(namespace.EVENT_EDITFRAME_EDITION_END, function () {\n            this.disableMarkupInteractions(false);\n        }.bind(this));\n\n        // Register tool\n        var toolClass = this.options.markupToolClass || namespace.MarkupTool;\n        this.markupTool = new toolClass();\n        this.markupTool.setCoreExtension(this);\n        this.markupTool.setHotkeysEnabled(!this.options.markupDisableHotkeys);\n        this.viewer.toolController.registerTool(this.markupTool);\n\n        return true;\n    };\n\n    proto.unload = function () {\n\n        this.hide();\n\n        this.input.detachFrom(this);\n\n        if (this.markupTool) {\n            this.viewer.toolController.deregisterTool(this.markupTool);\n            this.markupTool = null;\n        }\n\n        var svg = this.svg;\n        if (svg && this.onMouseDownBinded) {\n            svg.removeEventListener(\"mousedown\", this.onMouseDownBinded);\n            this.onMouseDownBinded = null;\n        }\n        if (svg.parentNode) {\n            svg.parentNode.removeChild(svg);\n        }\n        this.editModeSvgLayerNode = null;\n        this.svg = null;\n\n        return true;\n    };\n\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.toggleEditMode = function () {\n        if (this.duringEditMode) {\n            this.leaveEditMode();\n        } else {\n            this.enterEditMode();\n        }\n    };\n\n    /**\n     * Enables click/touch interactions over Viewer canvas to create/draw markups.<br>\n     * Exit editMode by calling [leaveEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#leaveEditMode}.<br>\n     * See also:\n     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}\n     * @returns {boolean} Returns true if editMode is active\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.enterEditMode = function () {\n\n        // Return if already in edit mode.\n        if (this.duringEditMode) {\n            return true;\n        }\n\n        // If not currently shown, then show\n        if (!this.duringViewMode) {\n            if (!this.show()) {\n                return false; // Failed to enter view mode.\n            }\n        }\n\n        if (!this.editModeSvgLayerNode) {\n            this.editModeSvgLayerNode = namespaceUtils.createSvgElement('g');\n        }\n        this.svg.insertBefore(this.editModeSvgLayerNode, this.svg.firstChild);\n\n        this.input.enterEditMode();\n        this.viewer.setActiveNavigationTool(this.markupTool.getName());\n        this.allowNavigation(false);\n        this.changeEditMode(new namespace.EditModeArrow(this));\n        this.actionManager.clear();\n        this.styles = {}; // Clear EditMode styles.\n\n        this.duringEditMode = true;\n        return true;\n    };\n\n    /**\n     * Exits from editMode.<br>\n     * See also [enterEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}\n     * @returns {boolean} returns true if edit mode has been deactivated\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.leaveEditMode = function () {\n\n        var NOT_IN_EDIT_MODE = true;\n        var WE_ARE_STILL_IN_EDIT_MODE = false;\n\n        if (!this.duringEditMode || !this.duringViewMode) {\n            return NOT_IN_EDIT_MODE;\n        }\n\n        var viewer = this.viewer;\n        if (!viewer) {\n            return WE_ARE_STILL_IN_EDIT_MODE; // something is very wrong...\n        }\n\n        this.svg.removeChild(this.editModeSvgLayerNode);\n\n        this.input.leaveEditMode();\n        this.editFrame.setMarkup(null);\n        viewer.setActiveNavigationTool(this.markupTool.getName());\n        this.allowNavigation(true);\n\n        this.editMode.destroy();\n        this.editMode = null;\n\n        this.duringEditMode = false;\n        return NOT_IN_EDIT_MODE;\n    };\n\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.toggle = function () {\n        if (this.duringViewMode) {\n            this.hide();\n        } else {\n            this.show();\n        }\n    };\n\n    /**\n     * Enables loading of previously saved markups.<br>\n     * Exit editMode by calling [hide()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hide}.<br>\n     * See also:\n     * [enterEditMode()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}\n     * @returns {boolean} Whether it successfully entered view mode or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.show = function () {\n\n        var viewer = this.viewer;\n        if (!viewer || !viewer.model) {\n            return false;\n        }\n\n        // Return if already showing or in edit-mode.\n        // Notice that edit mode requires that we are currently show()-ing.\n        if (this.duringViewMode || this.duringEditMode) {\n            return true;\n        }\n\n        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);\n\n        // Add parent svg of all markups.\n        viewer.container.appendChild(this.svg);\n\n        this.input.enterViewMode();\n        namespaceUtils.hideLmvUi(viewer);\n\n        // TODO: Nasty hack, currently there is no API to disable mouse highlighting in 3d models.\n        // TODO: We nuke rollover function in viewer, for now, public api will be added soon.\n        this.onViewerRolloverObject = viewer.impl.rolloverObject;\n        viewer.impl.rolloverObject = function () {};\n\n        if (!this.options.markupBypassOrthoCam) {\n            namespaceUtils.forceOrthographicCamera(viewer);\n        }\n\n        this.cachedNavigationTool = this.viewer.getActiveNavigationTool();\n        viewer.setActiveNavigationTool(this.markupTool.getName());\n        this.allowNavigation(true);\n        var camera = viewer.impl.camera;\n        this.onViewerResize({ width: camera.clientWidth, height: camera.clientHeight });\n        this.clear();\n\n        // See function loadMarkups() for when the actual SVG gets added onstage //\n        this.svgLayersMap = {};\n        this.duringViewMode = true;\n        return true;\n    };\n\n    /**\n     * Removes any markup currently overlaid on the viewer. It will also exit EditMode if it is active.<br>\n     * See also:\n     * [show()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#show}\n     * @returns {boolean} Whether it successfully left view mode or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.hide = function () {\n\n        var RESULT_HIDE_OK = true;\n        var RESULT_HIDE_FAIL = false;\n\n        var viewer = this.viewer;\n        if (!viewer || !this.duringViewMode) {\n            return RESULT_HIDE_OK;\n        }\n\n        if (this.duringEditMode) {\n            if (!this.leaveEditMode()) {\n                return RESULT_HIDE_FAIL;\n            }\n        }\n\n        viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeBinded);\n        viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResizeBinded);\n\n        var svg = this.svg;\n        svg.parentNode && svg.parentNode.removeChild(svg);\n\n        // Remove all Markups and metadata (if any)\n        this.unloadMarkupsAllLayers();\n        namespaceUtils.removeAllMetadata(svg);\n\n        this.input.leaveViewMode();\n        namespaceUtils.restoreLmvUi(viewer);\n        this.viewer.impl.rolloverObject = this.onViewerRolloverObject;\n\n        this.viewer.setActiveNavigationTool(this.cachedNavigationTool);\n        this.cachedNavigationTool = null;\n\n        this.duringViewMode = false;\n        return RESULT_HIDE_OK;\n    };\n\n    /**\n     * Removes all markups from screen.<br>\n     * Markups should have been added while in\n     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.clear = function () {\n\n        var markups = this.markups;\n        while (markups.length > 0) {\n\n            var markup = markups[0];\n            this.removeMarkup(markup);\n            markup.destroy();\n        }\n\n        // At this point no other markups should be available.\n        var svg = this.editModeSvgLayerNode;\n        if (svg && svg.childNodes.length > 0) {\n            while (svg.childNodes.length) {\n                svg.removeChild(svg.childNodes[0]);\n            }\n        }\n    };\n\n    /**\n     * Returns an SVG string with the markups created so far.<br>\n     * Markups should have been added while in\n     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.\n     * @returns {string}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.generateData = function () {\n\n        // Sanity check, remove any lingering metadata nodes\n        namespaceUtils.removeAllMetadata(this.svg);\n\n        var tmpNode = namespaceUtils.createSvgElement(\"svg\");\n        namespaceUtils.transferChildNodes(this.svg, tmpNode); // Transfer includes this.editModeSvgLayerNode\n        namespaceUtils.transferChildNodes(this.editModeSvgLayerNode, this.svg);\n\n        var metadataObject = {\n            \"data-model-version\": \"1\"\n        };\n        var metadataNode = namespaceUtils.addSvgMetadata(this.svg, metadataObject);\n        var metadataNodes = [metadataNode];\n\n        // Notify each markup to inject metadata\n        this.markups.forEach(function (markup) {\n            var addedNode = markup.setMetadata();\n            if (addedNode) {\n                metadataNodes.push(addedNode);\n            }\n        });\n\n        // Generate the data!\n        var data = namespaceUtils.svgNodeToString(this.svg);\n\n        // Remove metadataObject before returning\n        metadataNodes.forEach(function (metadataNode) {\n            metadataNode.parentNode.removeChild(metadataNode);\n        });\n\n        namespaceUtils.transferChildNodes(this.svg, this.editModeSvgLayerNode);\n        namespaceUtils.transferChildNodes(tmpNode, this.svg);\n        tmpNode = null; // get rid of it.\n\n        return data;\n    };\n\n    /**\n     * Renders markups currently present on the canvas to be rendered into a &lt;canvas&gt; 2d context.<br>\n     * Internally, it will use each EditMode's renderToCanvas() api.<br>\n     * The intended use-case is to generate an image.\n     * @param {CanvasRenderingContext2D} context\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.renderToCanvas = function (context) {\n        this.markups.forEach(function (markup) {\n            context.save();\n            markup.renderToCanvas(context);\n            context.restore();\n        });\n    };\n\n    /**\n     * Changes the active drawing tool.<br>\n     * Use this method to change from, for example: the Arrow drawing tool into the Rectangle drawing tool.<br>\n     * Applicable only while in [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.<br>\n     * Fires EVENT_EDITMODE_CHANGED\n     * @param editMode\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.changeEditMode = function (editMode) {\n\n        var oldEditMode = this.editMode;\n        oldEditMode && oldEditMode.destroy();\n\n        editMode.addEventListener(namespace.EVENT_EDITMODE_CREATION_BEGIN, function () {\n            this.disableMarkupInteractions(true);\n        }.bind(this));\n        editMode.addEventListener(namespace.EVENT_EDITMODE_CREATION_END, function () {\n            this.disableMarkupInteractions(false);\n        }.bind(this));\n        editMode.addEventListener(namespace.EVENT_MARKUP_DESELECT, function (event) {\n            this.fireEvent(event);\n        }.bind(this));\n\n        this.editMode = editMode;\n        this.styles[editMode.type] = namespaceUtils.cloneStyle(editMode.getStyle());\n\n        this.fireEvent({ type: namespace.EVENT_EDITMODE_CHANGED, target: editMode });\n    };\n\n    /**\n     * While in [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode},\n     * it switches the click/tap/swipe behavior to allow camera zoom and panning operations.\n     *\n     * @param {Boolean} allow - Whether camera navigation interactions are active or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.allowNavigation = function (allow) {\n\n        var editMode = this.editMode;\n        this.navigating = allow;\n\n        if (allow) {\n            this.svg.setAttribute(\"pointer-events\", \"none\");\n            editMode && this.selectMarkup(null);\n        } else {\n            this.svg.setAttribute(\"pointer-events\", \"painted\");\n        }\n\n        this.markupTool.allowNavigation(allow);\n        editMode && editMode.notifyAllowNavigation(allow);\n    };\n\n    /**\n     * Sets mouse/tap interactions with all Markups present while in\n     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.\n     * @param {Boolean} disable - Whether markups will interact with mouse/tap actions.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.disableMarkupInteractions = function (disable) {\n\n        this.markups.forEach(function (markup) {\n            markup.disableInteractions(disable);\n        });\n    };\n\n    //// Input /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    proto.changeInputHandler = function (inputHandler) {\n\n        this.input.detachFrom(this);\n        inputHandler.attachTo(this);\n        this.input = inputHandler;\n\n        if (this.duringEditMode) {\n            inputHandler.enterEditMode();\n        }\n\n        if (this.duringViewMode) {\n            inputHandler.enterViewMode();\n        }\n    };\n\n    //// Copy and Paste System /////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Standard copy operation. Applies to any selected Markup. It has effect only when a markup is selected.<br>\n     * See also\n     * [cut()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#cut} and\n     * [paste()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#paste}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.copy = function () {\n\n        this.clipboard.copy();\n    };\n\n    /**\n     * Standard cut operation. Applies to any selected Markup, which gets removed from screen at call time.<br>\n     * See also\n     * [copy()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#copy} and\n     * [paste()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#paste}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.cut = function () {\n\n        this.clipboard.cut();\n    };\n\n    /**\n     * Standard paste operation. Will paste add to stage any previously copied or cut markup.\n     * Can be called repeatedly after after a single copy or cut operation.<br>\n     * See also\n     * [copy()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#copy} and\n     * [cut()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#cut}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.paste = function () {\n\n        this.clipboard.paste();\n    };\n\n    //// Undo and Redo System //////////////////////////////////////////////////////////////////////////////////////////\n    /**\n     * Will undo the previous operation.<br>\n     * The Undo/Redo stacks will track any change done through an EditAction.<br>\n     * See also\n     * [redo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#redo},\n     * [isUndoStackEmpty()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#isUndoStackEmpty}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.undo = function () {\n\n        this.actionManager.undo();\n    };\n\n    /**\n     * Will redo and previously undo operation.<br>\n     * See also\n     * [undo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo},\n     * [isRedoStackEmpty()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#isRedoStackEmpty}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.redo = function () {\n\n        this.actionManager.redo();\n    };\n\n    /**\n     * Returns true when [undo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo}\n     * will produce no changes.\n     * @return {Boolean}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.isUndoStackEmpty = function () {\n\n        return this.actionManager.isUndoStackEmpty();\n    };\n\n    /**\n     * Returns true when [redo()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#redo}\n     * will produce no changes.\n     * @return {Boolean}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.isRedoStackEmpty = function () {\n\n        return this.actionManager.isRedoStackEmpty();\n    };\n\n    proto.beginActionGroup = function () {\n\n        this.actionManager.beginActionGroup();\n    };\n\n    proto.closeActionGroup = function () {\n\n        this.actionManager.closeActionGroup();\n    };\n\n    proto.cancelActionGroup = function () {\n\n        this.actionManager.cancelActionGroup();\n    };\n\n    /**\n     * Helper function for generating unique markup ids.\n     * @returns {number}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.getId = function () {\n\n        return ++this.nextId;\n    };\n\n    /**\n     * @param event\n     * @private\n     */\n    proto.onEditActionHistoryChanged = function (event) {\n\n        var data = event.data;\n        var editMode = this.editMode;\n\n        var keepSelection = editMode && editMode.selectedMarkup && editMode.selectedMarkup.id === data.targetId;\n\n        if (data.action !== 'undo' && data.targetId !== -1 || data.action === 'undo' && keepSelection) {\n\n            // Markup can be null when deleting, that's ok, we unselect in that case.\n            var markup = this.getMarkup(data.targetId);\n            this.selectMarkup(markup);\n        }\n\n        this.fireEvent(event);\n    };\n\n    /**\n     * Returns a markup with the specified id. Returns null when not found.<br>\n     * See also:\n     * [getSelection()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getSelection}.\n     * @param {String} id Markup identifier.\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.getMarkup = function (id) {\n\n        var markups = this.markups;\n        var markupsCount = markups.length;\n\n        for (var i = 0; i < markupsCount; ++i) {\n            if (markups[i].id == id) {\n                return markups[i];\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Selects a markup.  A selected markup gets an overlayed UI that allows transformations such\n     * as resizing, rotations and translation.<br>\n     * Allows sending null to remove selection from the currently selected markup.\n     * See also:\n     * [getMarkup()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#getMarkup}.\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup|null} markup Markup instance to select, or null.\n     */\n    proto.selectMarkup = function (markup) {\n\n        if (markup) {\n\n            if (this.editMode.type === markup.type) {\n                this.editMode.setSelection(markup);\n            } else {\n\n                var editMode = markup.getEditMode();\n                editMode.setSelection(null);\n\n                this.changeEditMode(editMode);\n                this.setStyle(markup.getStyle());\n                this.editMode.setSelection(markup);\n            }\n        } else {\n\n            this.editMode.setSelection(null);\n        }\n    };\n\n    /**\n     * Returns the currently selected Markup.  A selected markup has custom UI overlayed that allows for\n     * resizing, rotation and translation.<br>\n     * See also:\n     * [selectMarkup()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#selectMarkup}.\n     * @returns {Autodesk.Viewing.Extensions.Markups.Core.Markup|null}\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.getSelection = function () {\n\n        return this.editMode.getSelection();\n    };\n\n    /**\n     * Deletes a markup from the scene. Applies only while in\n     * [Edit Mode]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#enterEditMode}.\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.Markup} markup\n     * @param {Boolean} [dontAddToHistory] Whether delete action can be [undone]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#undo}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.deleteMarkup = function (markup, dontAddToHistory) {\n\n        var editMode = markup.getEditMode();\n        editMode.deleteMarkup(markup, dontAddToHistory);\n    };\n\n    proto.addMarkup = function (markup) {\n\n        markup.setParent(this.editModeSvgLayerNode);\n\n        markup.addEventListener(namespace.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);\n        markup.addEventListener(namespace.EVENT_MARKUP_DRAGGING, this.onMarkupDraggingBinded);\n        markup.addEventListener(namespace.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);\n        markup.addEventListener(namespace.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);\n        markup.addEventListener(namespace.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);\n\n        this.markups.push(markup);\n    };\n\n    /**\n     *\n     * @param markup\n     * @private\n     */\n    proto.removeMarkup = function (markup) {\n\n        markup.setParent(null);\n\n        markup.removeEventListener(namespace.EVENT_MARKUP_SELECTED, this.onMarkupSelectedBinded);\n        markup.removeEventListener(namespace.EVENT_MARKUP_DRAGGING, this.onMarkupDraggingBinded);\n        markup.removeEventListener(namespace.EVENT_MARKUP_ENTER_EDITION, this.onMarkupEnterEditionBinded);\n        markup.removeEventListener(namespace.EVENT_MARKUP_CANCEL_EDITION, this.onMarkupCancelEditionBinded);\n        markup.removeEventListener(namespace.EVENT_MARKUP_DELETE_EDITION, this.onMarkupDeleteEditionBinded);\n\n        var markups = this.markups;\n        var markupsIndex = markups.indexOf(markup);\n        if (markupsIndex !== -1) {\n            markups.splice(markupsIndex, 1);\n        }\n\n        var editMode = this.editMode;\n        if (editMode) {\n            var selectedMarkup = editMode.getSelection();\n            if (selectedMarkup === markup) {\n                this.selectMarkup(null);\n            }\n        }\n    };\n\n    //// Markups style /////////////////////////////////////////////////////////////////////////////////////////////////\n\n    proto.setStyle = function (style) {\n\n        var styles = this.styles;\n        var editMode = this.editMode;\n\n        namespaceUtils.copyStyle(style, styles[editMode.type]);\n        editMode.setStyle(styles[editMode.type]);\n    };\n\n    proto.getStyle = function () {\n\n        return namespaceUtils.cloneStyle(this.styles[this.editMode.type]);\n    };\n\n    //// Markups depth order ///////////////////////////////////////////////////////////////////////////////////////////\n\n    /**\n     *\n     * @param markup\n     */\n    proto.bringToFront = function (markup) {\n\n        this.sendMarkupTo(markup, this.markups.length - 1);\n    };\n\n    /**\n     *\n     * @param markup\n     */\n    proto.sendToBack = function (markup) {\n\n        this.sendMarkupTo(markup, 0);\n    };\n\n    /**\n     *\n     * @param markup\n     */\n    proto.bringForward = function (markup) {\n\n        var markupIndex = this.markups.indexOf(markup);\n        this.sendMarkupTo(markup, markupIndex + 1);\n    };\n\n    /**\n     *\n     * @param markup\n     */\n    proto.bringBackward = function (markup) {\n\n        var markupIndex = this.markups.indexOf(markup);\n        this.sendMarkupTo(markup, markupIndex - 1);\n    };\n\n    /**\n     *\n     * @param markup\n     * @param index\n     * @private\n     */\n    proto.sendMarkupTo = function (markup, index) {\n\n        var markups = this.markups;\n        var markupIndex = markups.indexOf(markup);\n\n        if (markupIndex !== -1 || index < 0 || index >= markups.length) {\n            return;\n        }\n\n        markups.splice(markupIndex, 1);\n        index = markupIndex > index ? index - 1 : index;\n        markups.splice(index, 0, markup);\n\n        // TODO: Add markup in right position not always at the end.\n        markup.setParent(null);\n        markup.setParent(this.editModeSvgLayerNode);\n    };\n\n    //// Serialization and Restoration of Markups  /////////////////////////////////////////////////////////////////////\n\n    /**\n     * Overlays Markup data (SVG string) onto viewer's canvas. A layerId is required to group markups and reference\n     * them in operations such as\n     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.<br>\n     *\n     * See also:\n     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups},\n     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.\n     *\n     * @param {String} markupString - svg string with markups. See also [generateData()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#generateData}.\n     * @param {String} layerId - Identifier for the layer where the markup should be loaded to. Example \"Layer1\".\n     * @return {Boolean} Whether the markup string was able to be loaded successfully\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.loadMarkups = function (markupString, layerId) {\n\n        if (!this.duringViewMode) {\n            return false;\n        }\n\n        if (!layerId) {\n            console.warn(\"loadMarkups failed; missing 2nd argument 'layerId'\");\n            return false;\n        }\n\n        // Can it be parsed into SVG?\n        var parent = namespaceUtils.stringToSvgNode(markupString);\n        if (!parent) {\n            return false;\n        }\n\n        // Remove all metadata nodes\n        namespaceUtils.removeAllMetadata(parent);\n\n        // Create svg node for layer (if not present)\n        var svgLayerNode = this.svgLayersMap[layerId];\n        if (!svgLayerNode) {\n            svgLayerNode = namespaceUtils.createSvgElement('g');\n            this.svg.appendChild(svgLayerNode);\n            this.svgLayersMap[layerId] = svgLayerNode;\n        }\n\n        var children = parent.childNodes;\n        while (children.length) {\n            svgLayerNode.appendChild(children[0]);\n        }\n        return true;\n    };\n\n    /**\n     * Removes Markups from DOM, which is good to free up some memory.<br>\n     *\n     * See also:\n     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups},\n     * [unloadMarkupsAllLayers()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkupsAllLayers}.\n     *\n     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).\n     * @return {Boolean} Whether the operation succeeded or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.unloadMarkups = function (layerId) {\n\n        if (!layerId) {\n            console.warn(\"unloadMarkups failed; No layerId provided.\");\n            return false;\n        }\n\n        var svgLayerNode = this.svgLayersMap[layerId];\n        if (!svgLayerNode) {\n            // TODO: Do we need to log anything here?\n            return false;\n        }\n\n        this.svg.removeChild(svgLayerNode);\n        delete this.svgLayersMap[layerId];\n        return true;\n    };\n\n    /**\n     * Unload all markups loaded so far. Great for freeing up memory.\n     *\n     * See also:\n     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups},\n     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups}.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.unloadMarkupsAllLayers = function () {\n\n        for (var layerId in this.svgLayersMap) {\n            if (this.svgLayersMap.hasOwnProperty(layerId)) {\n                this.svg.removeChild(this.svgLayersMap[layerId]);\n            }\n        }\n        this.svgLayersMap = {};\n    };\n\n    /**\n     * Hides all markups from a specified layer. Note that markups will be hidden and not unloaded,\n     * thus memory will still be consumed to keep them around. However, no additional parsing is required\n     * to make them visible again through method\n     * [showMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#showMarkups}.\n     *\n     * See also:\n     * [showMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#showMarkups},\n     * [unloadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#unloadMarkups},\n     * [loadMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#loadMarkups}.\n     *\n     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).\n     * @return {Boolean} Whether the operation succeeded or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.hideMarkups = function (layerId) {\n\n        if (!layerId) {\n            console.warn(\"hideMarkups failed; No layerId provided.\");\n            return false;\n        }\n\n        var svgLayerNode = this.svgLayersMap[layerId];\n        if (!svgLayerNode) {\n            // TODO: Do we need to log anything here?\n            return false;\n        }\n\n        svgLayerNode.setAttribute(\"visibility\", \"hidden\");\n    };\n\n    /**\n     * Sets a layer containing markups visible again.  Markups can be set non-visible by calling\n     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.\n     *\n     * See also:\n     * [hideMarkups()]{@link Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore#hideMarkups}.\n     *\n     * @param {String} layerId - Id of the layer containing all markups to unload (from DOM).\n     * @return {Boolean} Whether the operation succeeded or not.\n     */\n    Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore.prototype.showMarkups = function (layerId) {\n\n        if (!layerId) {\n            console.warn(\"showMarkups failed; No layerId provided.\");\n            return false;\n        }\n\n        var svgLayerNode = this.svgLayersMap[layerId];\n        if (!svgLayerNode) {\n            // TODO: Do we need to log anything here?\n            return false;\n        }\n\n        svgLayerNode.setAttribute(\"visibility\", \"visible\");\n    };\n\n    //// Client Space <-> Markup Space /////////////////////////////////////////////////////////////////////////////////\n\n    proto.positionFromClientToMarkups = function (x, y) {\n\n        return this.clientToMarkups(x, y);\n    };\n\n    proto.positionFromMarkupsToClient = function (x, y) {\n\n        return this.markupsToClient(x, y);\n    };\n\n    proto.sizeFromClientToMarkups = function (w, h) {\n\n        var a = this.clientToMarkups(0, 0);\n        var b = this.clientToMarkups(w, h);\n\n        return { x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y) };\n    };\n\n    proto.sizeFromMarkupsToClient = function (w, h) {\n\n        var a = this.markupsToClient(0, 0);\n        var b = this.markupsToClient(w, h);\n\n        return { x: Math.abs(b.x - a.x), y: Math.abs(b.y - a.y) };\n    };\n\n    proto.markupsToClient = function (x, y) {\n\n        var point = new THREE.Vector3(x, y, 0);\n        var camera = this.viewer.impl.camera;\n\n        point.applyMatrix4(camera.matrixWorld);\n        point.sub(camera.position);\n        point = namespaceUtils.worldToClient(point, this.viewer, false);\n\n        return point;\n    };\n\n    proto.clientToMarkups = function (x, y) {\n\n        var point = namespaceUtils.clientToWorld(x, y, 0, this.viewer);\n        var camera = this.viewer.impl.camera;\n\n        point.add(camera.position).applyMatrix4(camera.matrixWorldInverse);\n        point.z = 0;\n\n        return point;\n    };\n\n    proto.getSvgViewBox = function (clientWidth, clientHeight) {\n\n        // Get pan offset.\n        var lt = this.clientToMarkups(0, 0);\n        var rb = this.clientToMarkups(clientWidth, clientHeight);\n\n        var l = Math.min(lt.x, rb.x);\n        var t = Math.min(lt.y, rb.y);\n        var r = Math.max(lt.x, rb.x);\n        var b = Math.max(lt.y, rb.y);\n\n        return [l, t, r - l, b - t].join(' ');\n    };\n\n    proto.getBounds = function () {\n\n        return this.bounds;\n    };\n\n    proto.getMousePosition = function () {\n\n        return this.input.getMousePosition();\n    };\n\n    //// Handled Events ////////////////////////////////////////////////////////////////////////////////////////////////\n\n    proto.onCameraChange = function (event) {\n\n        // Update annotations' parent transform.\n        var viewBox = this.getSvgViewBox(this.bounds.width, this.bounds.height);\n\n        // HACK, for some reason the 2nd frame returns an empty canvas.\n        // The reason why this happens is that the code above calls into the viewer\n        // and a division by zero occurs due to LMV canvas having zero width and height\n        // When we detect this case, avoid setting the viewBox value and rely on one\n        // previously set.\n        if (viewBox === \"NaN NaN NaN NaN\") {\n            return;\n        }\n\n        this.svg.setAttribute('viewBox', viewBox);\n\n        // Edit frame has to be updated, re-setting the selected markup does the job.\n        var editMode = this.editMode;\n        if (editMode) {\n            var selectedMarkup = editMode.getSelection();\n            this.editFrame.setMarkup(selectedMarkup);\n        }\n    };\n\n    proto.onViewerResize = function (event) {\n\n        this.bounds.x = 0;\n        this.bounds.y = 0;\n        this.bounds.width = event.width;\n        this.bounds.height = event.height;\n\n        this.svg.setAttribute('width', this.bounds.width);\n        this.svg.setAttribute('height', this.bounds.height);\n\n        this.onCameraChange();\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @private\n     */\n    proto.onMouseMove = function () {\n\n        if (this.navigating) {\n            return;\n        }\n\n        // Propagate event to edit frame.\n        if (this.editFrame.isActive()) {\n            this.editFrame.onMouseMove();\n            return;\n        }\n\n        this.editMode && this.editMode.onMouseMove();\n    };\n\n    /**\n     * Handler to mouse down events, used to start creation markups.\n     * @private\n     */\n    proto.onMouseDown = function (event) {\n\n        if (this.navigating) {\n            return;\n        }\n\n        namespaceUtils.dismissLmvHudMessage();\n\n        var bounds = this.getBounds();\n        var mousePosition = this.getMousePosition();\n\n        if (mousePosition.x >= bounds.x && mousePosition.x <= bounds.x + bounds.width && mousePosition.y >= bounds.y && mousePosition.y <= bounds.y + bounds.height) {\n            this.editMode.onMouseDown();\n        }\n\n        // TODO: There is a better way to do this, implement when undo/redo group.\n        if (!this.editMode.creating && event.target === this.svg) {\n            this.selectMarkup(null);\n        }\n        this.ignoreNextMouseUp = false;\n    };\n\n    proto.onMouseUp = function () {\n\n        if (this.navigating) {\n            return;\n        }\n\n        if (this.editFrame.isActive()) {\n            this.editFrame.onMouseUp();\n            return;\n        }\n\n        if (!this.ignoreNextMouseUp) {\n            this.editMode.onMouseUp();\n        }\n    };\n\n    /**\n     *\n     * @param event\n     */\n    proto.onMarkupSelected = function (event) {\n\n        this.selectMarkup(event.markup);\n        this.fireEvent(event);\n    };\n\n    // TODO: Check if these events are still relevant.\n    proto.onMarkupDragging = function (event) {\n\n        if (event.dragging) {\n            this.editMode.startDragging();\n        } else {\n            this.editMode.finishDragging();\n        }\n    };\n\n    proto.onMarkupEnterEdition = function (event) {};\n\n    proto.onMarkupCancelEdition = function (event) {\n\n        this.editMode.unselect();\n    };\n\n    proto.onMarkupDeleteEdition = function (event) {\n\n        this.removeMarkup(event.markup);\n        this.editMode.deleteMarkup();\n    };\n\n    Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Viewing.MarkupsCore', MarkupsCore);\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param id\n     * @param markup\n     * @param position\n     * @constructor\n     */\n    function CloneMarkup(editor, id, markup, position) {\n\n        namespace.EditAction.call(this, editor, 'CLONE-MARKUP', id);\n\n        this.clone = markup.clone();\n        this.clone.id = id;\n        this.position = { x: position.x, y: position.y };\n    }\n\n    CloneMarkup.prototype = Object.create(namespace.EditAction.prototype);\n    CloneMarkup.prototype.constructor = CloneMarkup;\n\n    var proto = CloneMarkup.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var clone = this.clone;\n        var position = this.position;\n\n        if (editor.getMarkup(this.targetId)) {\n            return;\n        }\n\n        var markup = clone.clone();\n        markup.setPosition(position.x, position.y);\n\n        editor.addMarkup(markup);\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CloneMarkup = CloneMarkup;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * @constructor\n     */\n    function CreateArrow(editor, id, head, tail, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-ARROW', id);\n\n        this.selectOnExecution = false;\n        this.tail = tail;\n        this.head = head;\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateArrow.prototype = Object.create(namespace.EditAction.prototype);\n    CreateArrow.prototype.constructor = CreateArrow;\n\n    var proto = CreateArrow.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var arrow = new namespace.MarkupArrow(this.targetId, editor);\n\n        editor.addMarkup(arrow);\n\n        arrow.set(this.head.x, this.head.y, this.tail.x, this.tail.y);\n        arrow.setStyle(this.style);\n\n        arrow.created();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CreateArrow = CreateArrow;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * @class\n     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}\n     * for creating a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.\n     * Included in documentation as an example of how to create\n     * a specific EditAction that deals with Markup creation.\n     * Developers are encourage to look into this class's source code and copy\n     * as much code as they need. Find link to source code below.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n     *\n     * @param editor\n     * @param id\n     * @param position\n     * @param size\n     * @param rotation\n     * @param style\n     */\n    function CreateCircle(editor, id, position, size, rotation, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-CIRCLE', id);\n\n        this.selectOnExecution = false;\n        this.position = { x: position.x, y: position.y };\n        this.size = { x: size.x, y: size.y };\n        this.rotation = rotation;\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateCircle.prototype = Object.create(namespace.EditAction.prototype);\n    CreateCircle.prototype.constructor = CreateCircle;\n\n    var proto = CreateCircle.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var circle = new namespace.MarkupCircle(this.targetId, editor);\n\n        editor.addMarkup(circle);\n\n        circle.set(this.position, this.size);\n        circle.setRotation(this.rotation);\n        circle.setStyle(this.style);\n\n        circle.created();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CreateCircle = CreateCircle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @param id\n     * @param position\n     * @param size\n     * @param rotation\n     * @param style\n     * @constructor\n     */\n    function CreateCloud(editor, id, position, size, rotation, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-CLOUD', id);\n\n        this.selectOnExecution = false;\n        this.position = { x: position.x, y: position.y };\n        this.size = { x: size.x, y: size.y };\n        this.rotation = rotation;\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateCloud.prototype = Object.create(namespace.EditAction.prototype);\n    CreateCloud.prototype.constructor = CreateCloud;\n\n    var proto = CreateCloud.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var cloud = new namespace.MarkupCloud(this.targetId, editor);\n\n        editor.addMarkup(cloud);\n\n        cloud.set(this.position, this.size);\n        cloud.setRotation(this.rotation);\n        cloud.setStyle(this.style);\n\n        cloud.created();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CreateCloud = CreateCloud;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @param id\n     * @param position\n     * @param size\n     * @param rotation\n     * @param locations\n     * @param style\n     * @constructor\n     */\n    function CreateFreehand(editor, id, position, size, rotation, locations, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-FREEHAND', id);\n\n        this.selectOnExecution = false;\n        this.position = position;\n        this.size = size;\n        this.rotation = rotation;\n        this.movements = locations.concat();\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateFreehand.prototype = Object.create(namespace.EditAction.prototype);\n    CreateFreehand.prototype.constructor = CreateFreehand;\n\n    var proto = CreateFreehand.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var freehand = new namespace.MarkupFreehand(this.targetId, editor);\n\n        editor.addMarkup(freehand);\n\n        freehand.set(this.position, this.size, this.movements);\n        freehand.setRotation(this.rotation);\n        freehand.setStyle(this.style);\n\n        freehand.created();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CreateFreehand = CreateFreehand;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @param id\n     * @param position\n     * @param size\n     * @param rotation\n     * @param style\n     * @constructor\n     */\n    function CreateRectangle(editor, id, position, size, rotation, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-RECTANGLE', id);\n\n        this.selectOnExecution = false;\n        this.position = { x: position.x, y: position.y };\n        this.size = { x: size.x, y: size.y };\n        this.rotation = rotation;\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateRectangle.prototype = Object.create(namespace.EditAction.prototype);\n    CreateRectangle.prototype.constructor = CreateRectangle;\n\n    var proto = CreateRectangle.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var rectangle = new namespace.MarkupRectangle(this.targetId, editor);\n\n        editor.addMarkup(rectangle);\n\n        rectangle.set(this.position, this.size);\n        rectangle.setRotation(this.rotation);\n        rectangle.setStyle(this.style);\n\n        rectangle.created();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && this.editor.removeMarkup(markup);\n    };\n\n    namespace.CreateRectangle = CreateRectangle;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @param id\n     * @param position\n     * @param size\n     * @param text\n     * @param style\n     * @constructor\n     */\n    function CreateText(editor, id, position, size, text, style) {\n\n        namespace.EditAction.call(this, editor, 'CREATE-TEXT', id);\n\n        this.text = text;\n        this.position = { x: position.x, y: position.y };\n        this.size = { x: size.x, y: size.y };\n        this.style = namespaceUtils.cloneStyle(style);\n    }\n\n    CreateText.prototype = Object.create(namespace.EditAction.prototype);\n    CreateText.prototype.constructor = CreateText;\n\n    var proto = CreateText.prototype;\n\n    proto.redo = function () {\n\n        var editor = this.editor;\n        var position = this.position;\n        var size = this.size;\n\n        var text = new namespace.MarkupText(this.targetId, editor, size);\n\n        editor.addMarkup(text);\n\n        text.setSize(position, size.x, size.y);\n        text.setText(this.text);\n        text.setStyle(this.style);\n\n        text.forceRedraw();\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        if (markup) {\n            this.editor.removeMarkup(markup);\n            markup.destroy();\n        }\n    };\n\n    namespace.CreateText = CreateText;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param arrow\n     * @constructor\n     */\n    function DeleteArrow(editor, arrow) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-ARROW', arrow.id);\n        this.createArrow = new namespace.CreateArrow(editor, arrow.id, arrow.head, arrow.tail, arrow.getStyle());\n    }\n\n    DeleteArrow.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteArrow.prototype.constructor = DeleteArrow;\n\n    var proto = DeleteArrow.prototype;\n\n    proto.redo = function () {\n\n        this.createArrow.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createArrow.redo();\n    };\n\n    namespace.DeleteArrow = DeleteArrow;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     * @class\n     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}\n     * for deleting a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.\n     * Included in documentation as an example of how to create\n     * a specific EditAction that deals with Markup deletion.\n     * Developers are encourage to look into this class's source code and copy\n     * as much code as they need. Find link to source code below.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n     *\n     * @param editor\n     * @param circle\n     */\n    function DeleteCircle(editor, circle) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-CIRCLE', circle.id);\n        this.createCircle = new namespace.CreateCircle(editor, circle.id, circle.position, circle.size, circle.rotation, circle.getStyle());\n    }\n\n    DeleteCircle.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteCircle.prototype.constructor = DeleteCircle;\n\n    var proto = DeleteCircle.prototype;\n\n    proto.redo = function () {\n\n        this.createCircle.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createCircle.redo();\n    };\n\n    namespace.DeleteCircle = DeleteCircle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param cloud\n     * @constructor\n     */\n    function DeleteCloud(editor, cloud) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-CLOUD', cloud.id);\n        this.createCloud = new namespace.CreateCloud(editor, cloud.id, cloud.position, cloud.size, cloud.rotation, cloud.getStyle());\n    }\n\n    DeleteCloud.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteCloud.prototype.constructor = DeleteCloud;\n\n    var proto = DeleteCloud.prototype;\n\n    proto.redo = function () {\n\n        this.createCloud.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createCloud.redo();\n    };\n\n    namespace.DeleteCloud = DeleteCloud;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param freehand\n     * @constructor\n     */\n    function DeleteFreehand(editor, freehand) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-FREEHAND', freehand.id);\n        this.createFreehand = new namespace.CreateFreehand(editor, freehand.id, freehand.position, freehand.size, freehand.rotation, freehand.locations, freehand.getStyle());\n    }\n\n    DeleteFreehand.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteFreehand.prototype.constructor = DeleteFreehand;\n\n    var proto = DeleteFreehand.prototype;\n\n    proto.redo = function () {\n\n        this.createFreehand.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createFreehand.redo();\n    };\n\n    namespace.DeleteFreehand = DeleteFreehand;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param rectangle\n     * @constructor\n     */\n    var DeleteRectangle = function DeleteRectangle(editor, rectangle) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-RECTANGLE', rectangle.id);\n        this.createRectangle = new namespace.CreateRectangle(editor, rectangle.id, rectangle.position, rectangle.size, rectangle.rotation, rectangle.getStyle());\n    };\n\n    DeleteRectangle.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteRectangle.prototype.constructor = DeleteRectangle;\n\n    var proto = DeleteRectangle.prototype;\n\n    proto.redo = function () {\n\n        this.createRectangle.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createRectangle.redo();\n    };\n\n    namespace.DeleteRectangle = DeleteRectangle;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param text\n     * @constructor\n     */\n    function DeleteText(editor, text) {\n\n        namespace.EditAction.call(this, editor, 'DELETE-TEXT', text.id);\n\n        var position = { x: text.position.x, y: text.position.y };\n        var size = { x: text.size.x, y: text.size.y };\n\n        this.createText = new namespace.CreateText(editor, text.id, position, size, text.getText(), text.getStyle());\n    }\n\n    DeleteText.prototype = Object.create(namespace.EditAction.prototype);\n    DeleteText.prototype.constructor = DeleteText;\n\n    var proto = DeleteText.prototype;\n\n    proto.redo = function () {\n\n        this.createText.undo();\n    };\n\n    proto.undo = function () {\n\n        this.createText.redo();\n    };\n\n    namespace.DeleteText = DeleteText;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     * This class will group actions edit actions that should be executed as a whole.\n     * When a group is open actions can be added to it, similar actions will be merged into one during this process.\n     * This class is not intended to be used by users, it's a helper class of EditActionManager.\n     * @constructor\n     */\n    function EditActionGroup() {\n\n        this.actions = [];\n        this.closed = true;\n    }\n\n    var proto = EditActionGroup.prototype;\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    proto.open = function () {\n\n        if (!this.closed) {\n            return false;\n        }\n\n        this.closed = false;\n        return true;\n    };\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    proto.close = function () {\n\n        if (this.closed) {\n            return false;\n        }\n\n        this.closed = true;\n        return true;\n    };\n\n    /**\n     *\n     * @returns {number} targetId\n     */\n    proto.undo = function () {\n\n        var actions = this.actions;\n        var actionsMaxIndex = actions.length - 1;\n\n        var targetId = -1;\n        for (var i = actionsMaxIndex; i >= 0; --i) {\n\n            var action = actions[i];\n            action.undo();\n\n            if (action.targetId !== -1) {\n                targetId = action.targetId;\n            }\n        }\n\n        return targetId;\n    };\n\n    /**\n     *\n     * @returns {number} targetId\n     */\n    proto.redo = function () {\n\n        var actions = this.actions;\n        var actionsCount = actions.length;\n\n        var targetId = -1;\n        for (var i = 0; i < actionsCount; ++i) {\n\n            var action = actions[i];\n            action.redo();\n\n            if (action.targetId !== -1) {\n                targetId = action.targetId;\n            }\n        }\n\n        return targetId;\n    };\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    proto.isOpen = function () {\n\n        return !this.closed;\n    };\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    proto.isClosed = function () {\n\n        return this.closed;\n    };\n\n    /**\n     *\n     * @returns {boolean}\n     */\n    proto.isEmpty = function () {\n\n        return this.actions.length === 0;\n    };\n\n    /**\n     *\n     * @param {EditAction} action\n     */\n    proto.addAction = function (action) {\n\n        if (this.closed) {\n            return false;\n        }\n\n        this.actions.push(action);\n        this.compact();\n\n        return true;\n    };\n\n    /**\n     * @private\n     */\n    proto.compact = function () {\n\n        var actions = this.actions;\n        var actionsCount = actions.length;\n\n        for (var i = 0; i < actionsCount; ++i) {\n\n            // If an action does nothing, remove it.\n            var actionA = actions[i];\n            if (actionA.isIdentity()) {\n                actions.splice(i, 1);\n                --actionsCount;\n                --i;\n                continue;\n            }\n\n            // If an action can be merged, merge it.\n            for (var j = i + 1; j < actionsCount; ++j) {\n\n                var actionB = actions[j];\n                if (actionA.type === actionB.type && actionA.merge(actionB)) {\n                    actions.splice(j, 1);\n                    --actionsCount;\n                    --i;\n                    break;\n                }\n            }\n        }\n    };\n\n    namespace.EditActionGroup = EditActionGroup;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param arrow\n     * @param head\n     * @param tail\n     * @constructor\n     */\n    function SetArrow(editor, arrow, head, tail) {\n\n        namespace.EditAction.call(this, editor, 'SET-ARROW', arrow.id);\n\n        this.newHead = { x: head.x, y: head.y };\n        this.newTail = { x: tail.x, y: tail.y };\n        this.oldHead = { x: arrow.head.x, y: arrow.head.y };\n        this.oldTail = { x: arrow.tail.x, y: arrow.tail.y };\n    }\n\n    SetArrow.prototype = Object.create(namespace.EditAction.prototype);\n    SetArrow.prototype.constructor = SetArrow;\n\n    var proto = SetArrow.prototype;\n\n    proto.redo = function () {\n\n        this.applyState(this.targetId, this.newHead, this.newTail);\n    };\n\n    proto.undo = function () {\n\n        this.applyState(this.targetId, this.oldHead, this.oldTail);\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newHead = action.newHead;\n            this.newTail = action.newTail;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     *\n     * @private\n     */\n    proto.applyState = function (targetId, head, tail) {\n\n        var arrow = this.editor.getMarkup(targetId);\n        if (!arrow) {\n            return;\n        }\n\n        // Different stroke widths make positions differ at sub-pixel level.\n        var epsilon = 0.0001;\n\n        if (Math.abs(arrow.head.x - head.x) >= epsilon || Math.abs(arrow.head.y - head.y) >= epsilon || Math.abs(arrow.tail.x - tail.x) >= epsilon || Math.abs(arrow.tail.y - tail.y) >= epsilon) {\n\n            arrow.set(head.x, head.y, tail.x, tail.y);\n        }\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return this.newHead.x === this.oldHead.x && this.newHead.y === this.oldHead.y && this.newTail.x === this.oldTail.x && this.newTail.y === this.oldTail.y;\n    };\n\n    namespace.SetArrow = SetArrow;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     * @class\n     * Implements an [EditAction]{@link Autodesk.Viewing.Extensions.Markups.Core.EditAction}\n     * for editing properties of a Circle [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.\n     * Included in documentation as an example of how to create\n     * a specific EditAction that deals with Markup edition.\n     * Developers are encourage to look into this class's source code and copy\n     * as much code as they need. Find link to source code below.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditAction\n     *\n     * @param editor\n     * @param circle\n     * @param position\n     * @param size\n     */\n    function SetCircle(editor, circle, position, size) {\n\n        namespace.EditAction.call(this, editor, 'SET-CIRCLE', circle.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.newSize = { x: size.x, y: size.y };\n        this.oldPosition = { x: circle.position.x, y: circle.position.y };\n        this.oldSize = { x: circle.size.x, y: circle.size.y };\n    }\n\n    SetCircle.prototype = Object.create(namespace.EditAction.prototype);\n    SetCircle.prototype.constructor = SetCircle;\n\n    var proto = SetCircle.prototype;\n\n    proto.redo = function () {\n\n        this.applyState(this.targetId, this.newPosition, this.newSize);\n    };\n\n    proto.undo = function () {\n\n        this.applyState(this.targetId, this.oldPosition, this.oldSize);\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newPosition = action.newPosition;\n            this.newSize = action.newSize;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     *\n     * @private\n     */\n    proto.applyState = function (targetId, position, size) {\n\n        var circle = this.editor.getMarkup(targetId);\n        if (!circle) {\n            return;\n        }\n\n        // Different stroke widths make positions differ at sub-pixel level.\n        var epsilon = 0.0001;\n\n        if (Math.abs(circle.position.x - position.x) > epsilon || Math.abs(circle.size.y - size.y) > epsilon || Math.abs(circle.position.y - position.y) > epsilon || Math.abs(circle.size.y - size.y) > epsilon) {\n\n            circle.set(position, size);\n        }\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return this.newPosition.x === this.oldPosition.x && this.newPosition.y === this.oldPosition.y && this.newSize.x === this.oldSize.x && this.newSize.y === this.oldSize.y;\n    };\n\n    namespace.SetCircle = SetCircle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param cloud\n     * @param position\n     * @param size\n     * @constructor\n     */\n    function SetCloud(editor, cloud, position, size) {\n\n        namespace.EditAction.call(this, editor, 'SET-CLOUD', cloud.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.newSize = { x: size.x, y: size.y };\n        this.oldPosition = { x: cloud.position.x, y: cloud.position.y };\n        this.oldSize = { x: cloud.size.x, y: cloud.size.y };\n    }\n\n    SetCloud.prototype = Object.create(namespace.EditAction.prototype);\n    SetCloud.prototype.constructor = SetCloud;\n\n    var proto = SetCloud.prototype;\n\n    proto.redo = function () {\n\n        this.applyState(this.targetId, this.newPosition, this.newSize, this.newStrokeWidth, this.newColor);\n    };\n\n    proto.undo = function () {\n\n        this.applyState(this.targetId, this.oldPosition, this.oldSize, this.oldStrokeWidth, this.oldColor);\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newPosition = action.newPosition;\n            this.newSize = action.newSize;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     *\n     * @private\n     */\n    proto.applyState = function (targetId, position, size) {\n\n        var cloud = this.editor.getMarkup(targetId);\n        if (!cloud) {\n            return;\n        }\n\n        // Different stroke widths make positions differ at sub-pixel level.\n        var epsilon = 0.0001;\n\n        if (Math.abs(cloud.position.x - position.x) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon || Math.abs(cloud.position.y - position.y) > epsilon || Math.abs(cloud.size.y - size.y) > epsilon) {\n\n            cloud.set(position, size);\n        }\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return this.newPosition.x === this.oldPosition.x && this.newPosition.y === this.oldPosition.y && this.newSize.x === this.oldSize.x && this.newSize.y === this.oldSize.y;\n    };\n\n    namespace.SetCloud = SetCloud;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param freehand\n     * @param position\n     * @param size\n     * @param locations\n     * @constructor\n     */\n    function SetFreehand(editor, freehand, position, size, locations) {\n\n        namespace.EditAction.call(this, editor, 'SET-FREEHAND', freehand.id);\n\n        this.position = position;\n        this.size = size;\n        this.locations = locations.concat();\n\n        // No need to save old data\n    }\n\n    SetFreehand.prototype = Object.create(namespace.EditAction.prototype);\n    SetFreehand.prototype.constructor = SetFreehand;\n\n    var proto = SetFreehand.prototype;\n\n    proto.redo = function () {\n\n        var freehand = this.editor.getMarkup(this.targetId);\n        if (!freehand) {\n            return;\n        }\n\n        freehand.set(this.position, this.size, this.locations);\n    };\n\n    proto.undo = function () {\n        // No need for undo.\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.locations = action.locations.concat();\n            this.position = action.position;\n            this.size = action.size;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return false; // No need to optimize, always false.\n    };\n\n    namespace.SetFreehand = SetFreehand;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    function SetPosition(editor, markup, position) {\n\n        namespace.EditAction.call(this, editor, 'SET-POSITION', markup.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.oldPosition = { x: markup.position.x, y: markup.position.y };\n    }\n\n    SetPosition.prototype = Object.create(namespace.EditAction.prototype);\n    SetPosition.prototype.constructor = SetPosition;\n\n    var proto = SetPosition.prototype;\n\n    proto.redo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setPosition(this.newPosition.x, this.newPosition.y);\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setPosition(this.oldPosition.x, this.oldPosition.y);\n    };\n\n    /**\n     *\n     * @param action\n     * @returns {boolean}\n     */\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newPosition = action.newPosition;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        var newPosition = this.newPosition;\n        var oldPosition = this.oldPosition;\n\n        return newPosition.x === oldPosition.x && newPosition.y === oldPosition.y;\n    };\n\n    namespace.SetPosition = SetPosition;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param rectangle\n     * @param position\n     * @param size\n     * @constructor\n     */\n    function SetRectangle(editor, rectangle, position, size) {\n\n        namespace.EditAction.call(this, editor, 'SET-RECTANGLE', rectangle.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.newSize = { x: size.x, y: size.y };\n        this.oldPosition = { x: rectangle.position.x, y: rectangle.position.y };\n        this.oldSize = { x: rectangle.size.x, y: rectangle.size.y };\n    }\n\n    SetRectangle.prototype = Object.create(namespace.EditAction.prototype);\n    SetRectangle.prototype.constructor = SetRectangle;\n\n    var proto = SetRectangle.prototype;\n\n    proto.redo = function () {\n\n        this.applyState(this.targetId, this.newPosition, this.newSize);\n    };\n\n    proto.undo = function () {\n\n        this.applyState(this.targetId, this.oldPosition, this.oldSize);\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newPosition = action.newPosition;\n            this.newSize = action.newSize;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     *\n     * @private\n     */\n    proto.applyState = function (targetId, position, size) {\n\n        var rectangle = this.editor.getMarkup(targetId);\n        if (!rectangle) {\n            return;\n        }\n\n        // Different stroke widths make positions differ at sub-pixel level.\n        var epsilon = 0.0001;\n\n        if (Math.abs(rectangle.position.x - position.x) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon || Math.abs(rectangle.position.y - position.y) > epsilon || Math.abs(rectangle.size.y - size.y) > epsilon) {\n\n            rectangle.set(position, size);\n        }\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return this.newPosition.x === this.oldPosition.x && this.newPosition.y === this.oldPosition.y && this.newSize.x === this.oldSize.x && this.newSize.y === this.oldSize.y;\n    };\n\n    namespace.SetRectangle = SetRectangle;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param markup\n     * @param angle\n     * @constructor\n     */\n    function SetRotation(editor, markup, angle) {\n\n        namespace.EditAction.call(this, editor, 'SET-ROTATION', markup.id);\n\n        var curAngle = markup.getRotation();\n\n        this.newRotation = { angle: angle };\n        this.oldRotation = { angle: curAngle };\n    }\n\n    SetRotation.prototype = Object.create(namespace.EditAction.prototype);\n    SetRotation.prototype.constructor = SetRotation;\n\n    var proto = SetRotation.prototype;\n\n    proto.redo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setRotation(this.newRotation.angle);\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setRotation(this.oldRotation.angle);\n    };\n\n    /**\n     *\n     * @param action\n     * @returns {boolean}\n     */\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newRotation = action.newRotation;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        return this.newRotation.angle === this.oldRotation.angle;\n    };\n\n    namespace.SetRotation = SetRotation;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param markup\n     * @param position\n     * @param width\n     * @param height\n     * @constructor\n     */\n    function SetSize(editor, markup, position, width, height) {\n\n        namespace.EditAction.call(this, editor, 'SET-SIZE', markup.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.oldPosition = { x: markup.position.x, y: markup.position.y };\n        this.newWidth = width;\n        this.oldWidth = markup.size.x;\n        this.newHeight = height;\n        this.oldHeight = markup.size.y;\n    }\n\n    SetSize.prototype = Object.create(namespace.EditAction.prototype);\n    SetSize.prototype.constructor = SetSize;\n\n    var proto = SetSize.prototype;\n\n    proto.redo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setSize(this.newPosition, this.newWidth, this.newHeight);\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setSize(this.oldPosition, this.oldWidth, this.oldHeight);\n    };\n\n    proto.merge = function (action) {\n\n        if (this.targetId === action.targetId && this.type === action.type) {\n\n            this.newPosition = action.newPosition;\n            this.newWidth = action.newWidth;\n            this.newHeight = action.newHeight;\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * @returns {boolean}\n     */\n    proto.isIdentity = function () {\n\n        var identity = this.newPosition.x === this.oldPosition.x && this.newPosition.y === this.oldPosition.y && this.newWidth === this.oldWidth && this.newHeight === this.oldHeight;\n\n        return identity;\n    };\n\n    namespace.SetSize = SetSize;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @param markup\n     * @param style\n     * @constructor\n     */\n    function SetStyle(editor, markup, style) {\n\n        namespace.EditAction.call(this, editor, 'SET-STYLE', markup.id);\n\n        this.newStyle = namespaceUtils.cloneStyle(style);\n        this.oldStyle = markup.getStyle();\n    }\n\n    SetStyle.prototype = Object.create(namespace.EditAction.prototype);\n    SetStyle.prototype.constructor = SetStyle;\n\n    var proto = SetStyle.prototype;\n\n    proto.redo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setStyle(this.newStyle);\n    };\n\n    proto.undo = function () {\n\n        var markup = this.editor.getMarkup(this.targetId);\n        markup && markup.setStyle(this.oldStyle);\n    };\n\n    namespace.SetStyle = SetStyle;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @param markup\n     * @param position\n     * @param size\n     * @param text\n     * @constructor\n     */\n    function SetText(editor, markup, position, size, text) {\n\n        namespace.EditAction.call(this, editor, 'SET-TEXT', markup.id);\n\n        this.newPosition = { x: position.x, y: position.y };\n        this.oldPosition = { x: markup.position.x, y: markup.position.y };\n        this.newSize = { x: size.x, y: size.y };\n        this.oldSize = { x: markup.size.x, y: markup.size.y };\n        this.newText = text;\n        this.oldText = markup.getText();\n    }\n\n    SetText.prototype = Object.create(namespace.EditAction.prototype);\n    SetText.prototype.constructor = SetText;\n\n    var proto = SetText.prototype;\n\n    proto.redo = function () {\n\n        var text = this.editor.getMarkup(this.targetId);\n        text && text.set(this.newPosition, this.newSize, this.newText);\n    };\n\n    proto.undo = function () {\n\n        var text = this.editor.getMarkup(this.targetId);\n        text && text.set(this.oldPosition, this.oldSize, this.oldText);\n    };\n\n    namespace.SetText = SetText;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function Clipboard(editor) {\n\n        this.editor = editor;\n        this.content = null;\n        this.pastePosition = { x: 0, y: 0 };\n\n        namespaceUtils.addTraitEventDispatcher(this);\n    }\n\n    var proto = Clipboard.prototype;\n\n    proto.copy = function () {\n\n        var selectedMarkup = this.editor.getSelection();\n        if (!selectedMarkup) {\n            return;\n        }\n\n        this.content = selectedMarkup.clone();\n        this.pastePosition.x = selectedMarkup.position.x;\n        this.pastePosition.y = selectedMarkup.position.y;\n    };\n\n    proto.cut = function () {\n\n        var selectedMarkup = this.editor.getSelection();\n        if (!selectedMarkup) {\n            return;\n        }\n\n        this.copy();\n        this.editor.deleteMarkup(selectedMarkup);\n    };\n\n    proto.paste = function () {\n\n        var content = this.content;\n        if (!content) {\n            return;\n        }\n\n        var editor = this.editor;\n        var position = this.pastePosition;\n        var delta = editor.sizeFromClientToMarkups(20, 20);\n\n        position.x += delta.x;\n        position.y -= delta.y;\n\n        var cloneMarkup = new namespace.CloneMarkup(editor, editor.getId(), content, position);\n        cloneMarkup.execute();\n    };\n\n    namespace.Clipboard = Clipboard;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    function InputHandler() {\n\n        this.editor = null;\n        this.mousePosition = { x: 0, y: 0 };\n        this.makeSameXY = false; // TODO: FIND a better way to name and communicate these.\n        this.snapRotations = false;\n        this.keepAspectRatio = false;\n        this.constrainAxis = false;\n\n        this.onHammerDragBinded = this.onHammerDrag.bind(this);\n        this.onSingleTapBinded = this.onSingleTap.bind(this);\n        this.onMouseMoveBinded = this.onMouseMove.bind(this);\n        this.onMouseUpBinded = this.onMouseUp.bind(this);\n        this.onMouseDownBinded = this.onMouseDown.bind(this);\n    }\n\n    var proto = InputHandler.prototype;\n\n    proto.attachTo = function (editor) {\n\n        this.editor && this.detachFrom(this.editor);\n        this.editor = editor;\n\n        if (namespaceUtils.isTouchDevice()) {\n            this.hammer = new Hammer.Manager(editor.svg, {\n                recognizers: [[Hammer.Pan, { event: 'drag', pointers: 1 }], [Hammer.Tap, { event: 'singletap', pointers: 1, threshold: 2 }]],\n                inputClass: Hammer.TouchInput\n            });\n        }\n    };\n\n    proto.detachFrom = function (editor) {\n\n        this.hammer && this.hammer.destroy();\n\n        document.removeEventListener('mousemove', this.onMouseMoveBinded, true);\n        document.removeEventListener('mouseup', this.onMouseUpBinded, true);\n        this.editor && this.editor.svg.removeEventListener(\"mousedown\", this.onMouseDownBinded);\n        this.editor = editor;\n    };\n\n    proto.enterEditMode = function () {\n\n        if (this.hammer) {\n            this.hammer.on(\"dragstart dragmove dragend\", this.onHammerDragBinded);\n            this.hammer.on(\"singletap\", this.onSingleTapBinded);\n        }\n        document.addEventListener('mousemove', this.onMouseMoveBinded, true);\n        document.addEventListener('mouseup', this.onMouseUpBinded, true);\n        this.editor.svg.addEventListener(\"mousedown\", this.onMouseDownBinded);\n    };\n\n    proto.leaveEditMode = function () {\n\n        if (this.hammer) {\n            this.hammer.off(\"dragstart dragmove dragend\", this.onHammerDragBinded);\n            this.hammer.off(\"singletap\", this.onSingleTapBinded);\n        }\n        document.removeEventListener(\"mousemove\", this.onMouseMoveBinded, true);\n        document.removeEventListener(\"mouseup\", this.onMouseUpBinded, true);\n        this.editor.svg.removeEventListener(\"mousedown\", this.onMouseDownBinded);\n    };\n\n    proto.enterViewMode = function () {};\n\n    proto.leaveViewMode = function () {};\n\n    proto.getMousePosition = function () {\n\n        return { x: this.mousePosition.x, y: this.mousePosition.y };\n    };\n\n    proto.onMouseMove = function (event) {\n\n        processMouseEvent(this, event);\n        this.editor.onMouseMove();\n        event.preventDefault();\n    };\n\n    proto.onMouseDown = function (event) {\n\n        processMouseEvent(this, event);\n        this.editor.onMouseDown(event); // TODO: There should be no need to send event here.\n        event.preventDefault();\n    };\n\n    proto.onMouseUp = function (event) {\n\n        processMouseEvent(this, event);\n        this.editor.onMouseUp();\n        event.preventDefault();\n    };\n\n    proto.onHammerDrag = function (event) {\n\n        convertEventHammerToMouse(event);\n        switch (event.type) {\n            case 'dragstart':\n                this.onMouseDown(event);\n                break;\n            case 'dragmove':\n                this.onMouseMove(event);\n                break;\n            case 'dragend':\n                this.onMouseUp(event);\n                break;\n        }\n    };\n\n    proto.onSingleTap = function (event) {\n\n        convertEventHammerToMouse(event);\n\n        this.onMouseDown(event);\n        this.onMouseUp(event);\n    };\n\n    function processMouseEvent(input, event) {\n\n        var rect = input.editor.svg.getBoundingClientRect();\n\n        input.makeSameXY = event.shiftKey;\n        input.snapRotations = event.shiftKey;\n        input.keepAspectRatio = event.shiftKey;\n        input.constrainAxis = event.shiftKey;\n\n        input.mousePosition.x = event.clientX - rect.left;\n        input.mousePosition.y = event.clientY - rect.top;\n    }\n\n    function convertEventHammerToMouse(event) {\n\n        // Convert Hammer touch-event X,Y into mouse-event X,Y.\n        event.shiftKey = false;\n        event.clientX = event.pointers[0].clientX;\n        event.clientY = event.pointers[0].clientY;\n    }\n\n    namespace.InputHandler = InputHandler;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * @class\n     * Base class for all EditModes.<br>\n     * An EditMode is responsible for handling user input to create and edit a\n     * [Markup]{@link Autodesk.Viewing.Extensions.Markups.Core.Markup}.\n     *\n     * Any class extending Markup should contain at least the following methods:\n     * - deleteMarkup()\n     * - onMouseDown()\n     * - onMouseMove()\n     *\n     * A good reference is the Circle EditMode implementation available in\n     * [EditModeCircle.js]{@link Autodesk.Viewing.Extensions.Markups.Core.EditModeCircle}.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     *\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor - Markups extension.\n     * @param {String} type - An identifier for the EditMode type. Not to be confused by the Markup's id.\n     * @param {Array} styleAttributes - Attributes for customization.\n     * @constructor\n     */\n    function EditMode(editor, type, styleAttributes) {\n\n        this.editor = editor;\n        this.viewer = editor.viewer;\n        this.type = type;\n        this.selectedMarkup = null;\n        this.dragging = false;\n        this.draggingAnnotationIniPosition = null;\n        this.draggingMouseIniPosition = new THREE.Vector2();\n        this.initialX = 0;\n        this.initialY = 0;\n        this.minSize = 9; // In pixels\n        this.creating = false;\n        this.size = { x: 0, y: 0 };\n        this.style = namespaceUtils.createStyle(styleAttributes, this.viewer);\n\n        namespaceUtils.addTraitEventDispatcher(this);\n    }\n\n    // Event types //\n    namespace.EVENT_EDITMODE_CREATION_BEGIN = \"EVENT_EDITMODE_CREATION_BEGIN\";\n    namespace.EVENT_EDITMODE_CREATION_END = \"EVENT_EDITMODE_CREATION_END\";\n    namespace.EVENT_MARKUP_DESELECT = \"EVENT_MARKUP_DESELECT\";\n\n    var proto = EditMode.prototype;\n\n    proto.destroy = function () {\n\n        this.unselect();\n        namespaceUtils.removeTraitEventDispatcher(this);\n    };\n\n    proto.unselect = function () {\n\n        var fireEv = false;\n        var selectedMarkup = this.selectedMarkup;\n        if (selectedMarkup) {\n            selectedMarkup.unselect();\n            this.selectedMarkup = null;\n            fireEv = true;\n        }\n\n        this.editor.editFrame.setMarkup(null);\n\n        if (fireEv) {\n            this.fireEvent({ type: namespace.EVENT_MARKUP_DESELECT });\n        }\n    };\n\n    proto.createBegin = function () {\n\n        if (!this.creating) {\n            this.creating = true;\n            this.fireEvent({ type: namespace.EVENT_EDITMODE_CREATION_BEGIN });\n        }\n    };\n\n    proto.createEnd = function () {\n\n        if (this.creating) {\n            this.creating = false;\n            this.fireEvent({ type: namespace.EVENT_EDITMODE_CREATION_END });\n        }\n    };\n\n    /**\n     *\n     * @param style\n     */\n    proto.setStyle = function (style) {\n\n        this.style = style;\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup) {\n            return;\n        }\n\n        var setStyle = new namespace.SetStyle(this.editor, selectedMarkup, style);\n        setStyle.execute();\n    };\n\n    proto.getStyle = function () {\n\n        return this.style;\n    };\n\n    proto.setSelection = function (markup) {\n\n        if (this.selectedMarkup !== markup) {\n            this.unselect();\n            markup && markup.select();\n        }\n\n        this.selectedMarkup = markup;\n\n        var editor = this.editor;\n        markup && editor.bringToFront(markup);\n\n        if (!this.creating) {\n            editor.editFrame.setMarkup(markup);\n        }\n    };\n\n    proto.getSelection = function () {\n\n        return this.selectedMarkup;\n    };\n\n    /**\n     *\n     * @param [markup] If provided deletes markup (has to have same type that the edit mode), otherwise deletes selected one.\n     * @param [cantUndo] If true to not add deletion to undo history.\n     * @returns {boolean}\n     */\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        return false;\n    };\n\n    /**\n     * Used by classes extending EditMode to validate the minimum size (in screen coordinates) of the markup.\n     * See minSize attribute\n     * @return {Boolean} Whether current size is valid for creating the markup\n     * @private\n     */\n    proto.isMinSizeValid = function () {\n        if (this.minSize === 0) return true;\n        var tmp = this.editor.sizeFromMarkupsToClient(this.size.x, this.size.y);\n        return tmp.x * tmp.x + tmp.y * tmp.y >= this.minSize * this.minSize;\n    };\n\n    /**\n     * @private\n     */\n    proto.startDragging = function () {\n\n        var selectedMarkup = this.selectedMarkup;\n        var mousePosition = this.editor.getMousePosition();\n\n        if (selectedMarkup) {\n            this.dragging = true;\n            this.draggingAnnotationIniPosition = selectedMarkup.getClientPosition();\n            this.draggingMouseIniPosition.set(mousePosition.x, mousePosition.y);\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto.finishDragging = function () {\n\n        var dragging = this.dragging;\n        var selectedMarkup = this.selectedMarkup;\n\n        this.dragging = false;\n\n        if (selectedMarkup && dragging) {\n            selectedMarkup.finishDragging();\n        }\n    };\n\n    /**\n     *\n     * @returns {{x: number, y: number}}\n     */\n    proto.getFinalMouseDraggingPosition = function () {\n\n        var editor = this.editor;\n        var bounds = editor.getBounds();\n        var mousePosition = editor.getMousePosition();\n\n        var initialX = this.initialX;\n        var initialY = this.initialY;\n\n        var finalX = Math.min(Math.max(bounds.x, mousePosition.x), bounds.x + bounds.width);\n        var finalY = Math.min(Math.max(bounds.y, mousePosition.y), bounds.y + bounds.height);\n\n        if (finalX == initialX && finalY == initialY) {\n            finalX++;\n            finalY++;\n        }\n\n        // Make equal x/y when shift is down\n        if (editor.input.makeSameXY) {\n            var dx = Math.abs(finalX - initialX);\n            var dy = Math.abs(finalY - initialY);\n\n            var maxDelta = Math.max(dx, dy);\n\n            // These calculations have the opportunity to go beyond 'bounds'.\n            finalX = initialX + maxDelta * namespaceUtils.sign(finalX - initialX);\n            finalY = initialY + maxDelta * namespaceUtils.sign(finalY - initialY);\n        }\n\n        return { x: finalX, y: finalY };\n    };\n\n    proto.notifyAllowNavigation = function (allows) {};\n\n    proto.onMouseDown = function () {};\n\n    /**\n     * Handler to mouse up events, used to start annotations creation.\n     * It will cancel the creation of a markup if its minSize conditions are not met.\n     *\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseUp = function (event) {\n\n        if (this.selectedMarkup && this.creating && !this.isMinSizeValid()) {\n\n            this.createEnd();\n            this.editor.cancelActionGroup();\n            this.selectedMarkup = null;\n\n            return; // Yup, just return\n        }\n\n        this.finishDragging();\n        var selectedMarkup = this.selectedMarkup;\n        if (selectedMarkup && this.creating) {\n\n            selectedMarkup.created();\n            this.createEnd();\n\n            // Opened on mouse down.\n            this.editor.closeActionGroup();\n            this.unselect();\n        }\n    };\n\n    proto.onMouseMove = function (event) {};\n\n    proto.onDoubleClick = function (markup) {};\n\n    proto.cancelMarkupCreation = function () {\n\n        this.createEnd();\n        this.editor.cancelActionGroup();\n        this.selectedMarkup = null; // No need to call unselect\n    };\n\n    /**\n     *\n     * @returns {{x: *, y: *}}\n     */\n    proto.getDraggingPosition = function () {\n\n        var mousePosition = this.editor.getMousePosition();\n\n        var dx = mousePosition.x - this.draggingMouseIniPosition.x;\n        var dy = mousePosition.y - this.draggingMouseIniPosition.y;\n\n        return {\n            x: this.draggingAnnotationIniPosition.x + dx,\n            y: this.draggingAnnotationIniPosition.y + dy\n        };\n    };\n\n    /**\n     *\n     * @param x\n     * @param y\n     * @param bounds\n     * @returns {boolean}\n     * @orivate\n     */\n    proto.isInsideBounds = function (x, y, bounds) {\n\n        return x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;\n    };\n\n    namespace.EditMode = EditMode;\n})();\n\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function EditModeArrow(editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_ARROW, styleAttributes);\n    }\n\n    EditModeArrow.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeArrow.prototype.constructor = EditModeArrow;\n\n    var proto = EditModeArrow.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteArrow = new namespace.DeleteArrow(this.editor, markup);\n            deleteArrow.addToHistory = !cantUndo;\n            deleteArrow.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     * @private\n     */\n    proto.onMouseDown = function () {\n\n        namespace.EditMode.prototype.onMouseDown.call(this);\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var mousePosition = this.editor.getMousePosition();\n\n        this.initialX = mousePosition.x;\n        this.initialY = mousePosition.y;\n\n        // Calculate head and tail.\n        var width = 1; // TODO: When an Arrow too short is created, it should actually be ignored.\n        var head = { x: this.initialX, y: this.initialY };\n        var tail = { x: Math.round(head.x + Math.cos(Math.PI * 0.25) * width), y: Math.round(head.y + Math.sin(-Math.PI * 0.25) * width) };\n\n        // Constrain head and tail inside working area.\n        var constrain = function (head, tail, width, bounds) {\n\n            if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n                return;\n            }\n\n            tail.y = Math.round(head.y + Math.sin(Math.PI * 0.25) * width);\n            if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n                return;\n            }\n\n            tail.x = Math.round(head.y + Math.cos(-Math.PI * 0.25) * width);\n            if (this.isInsideBounds(tail.x, tail.y, bounds)) {\n                return;\n            }\n\n            tail.y = Math.round(head.y + Math.sin(-Math.PI * 0.25) * width);\n        }.bind(this);\n\n        var editor = this.editor;\n        constrain(head, tail, width, editor.getBounds());\n\n        // Create arrow.\n        editor.beginActionGroup();\n\n        head = editor.positionFromClientToMarkups(head.x, head.y);\n        tail = editor.positionFromClientToMarkups(tail.x, tail.y);\n        this.size = { x: tail.x - head.x, y: tail.y - head.y };\n\n        var arrowId = editor.getId();\n        var create = new namespace.CreateArrow(editor, arrowId, head, tail, this.style);\n        create.execute();\n\n        this.selectedMarkup = editor.getMarkup(arrowId);\n        this.createBegin();\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseMove = function (event) {\n\n        namespace.EditMode.prototype.onMouseMove.call(this, event);\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup || !this.creating) {\n            return;\n        }\n\n        var editor = this.editor;\n        var final = this.getFinalMouseDraggingPosition();\n\n        var head = editor.positionFromClientToMarkups(this.initialX, this.initialY);\n        var tail = editor.positionFromClientToMarkups(final.x, final.y);\n        this.size = { x: tail.x - head.x, y: tail.y - head.y };\n\n        var setArrow = new namespace.SetArrow(editor, selectedMarkup, head, tail);\n        setArrow.execute();\n    };\n\n    namespace.EditModeArrow = EditModeArrow;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     * @class\n     * Implements a Circle [EditMode]{@link Autodesk.Viewing.Extensions.Markups.Core.EditMode}.\n     * Included in documentation as an example of how to create\n     * an EditMode for a specific markup type. Developers are encourage to look into this class's source code and copy\n     * as much code as they need. Find link to source code below.\n     *\n     * @tutorial feature_markup\n     * @constructor\n     * @memberof Autodesk.Viewing.Extensions.Markups.Core\n     * @extends Autodesk.Viewing.Extensions.Markups.Core.EditMode\n     *\n     * @param {Autodesk.Viewing.Extensions.Markups.Core.MarkupsCore} editor\n     */\n    function EditModeCircle(editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_CIRCLE, styleAttributes);\n    }\n\n    EditModeCircle.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeCircle.prototype.constructor = EditModeCircle;\n\n    var proto = EditModeCircle.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteCircle = new namespace.DeleteCircle(this.editor, markup);\n            deleteCircle.addToHistory = !cantUndo;\n            deleteCircle.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseMove = function (event) {\n\n        namespace.EditMode.prototype.onMouseMove.call(this, event);\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup || !this.creating) {\n            return;\n        }\n\n        var editor = this.editor;\n        var initialX = this.initialX;\n        var initialY = this.initialY;\n\n        var final = this.getFinalMouseDraggingPosition();\n        var position = editor.clientToMarkups((initialX + final.x) / 2, (initialY + final.y) / 2);\n        var size = this.size = editor.sizeFromClientToMarkups(final.x - initialX, final.y - initialY);\n\n        var setCircle = new namespace.SetCircle(editor, selectedMarkup, position, size);\n\n        setCircle.execute();\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     * @private\n     */\n    proto.onMouseDown = function () {\n\n        namespace.EditMode.prototype.onMouseDown.call(this);\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n\n        this.initialX = mousePosition.x;\n        this.initialY = mousePosition.y;\n\n        // Calculate center and size.\n        var position = editor.clientToMarkups(this.initialX, this.initialY);\n        var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n        // Create circle.\n        editor.beginActionGroup();\n\n        var markupId = editor.getId();\n        var create = new namespace.CreateCircle(editor, markupId, position, size, 0, this.style);\n        create.execute();\n\n        this.selectedMarkup = editor.getMarkup(markupId);\n        this.createBegin();\n    };\n\n    namespace.EditModeCircle = EditModeCircle;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function EditModeCloud(editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_CLOUD, styleAttributes);\n    }\n\n    EditModeCloud.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeCloud.prototype.constructor = EditModeCloud;\n\n    var proto = EditModeCloud.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteCloud = new namespace.DeleteCloud(this.editor, markup);\n            deleteCloud.addToHistory = !cantUndo;\n            deleteCloud.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseMove = function (event) {\n\n        namespace.EditMode.prototype.onMouseMove.call(this, event);\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup || !this.creating) {\n            return;\n        }\n\n        var editor = this.editor;\n        var initialX = this.initialX;\n        var initialY = this.initialY;\n\n        var final = this.getFinalMouseDraggingPosition();\n        var position = editor.clientToMarkups((initialX + final.x) / 2, (initialY + final.y) / 2);\n        var size = this.size = editor.sizeFromClientToMarkups(final.x - initialX, final.y - initialY);\n\n        var setCloud = new namespace.SetCloud(editor, selectedMarkup, position, size);\n\n        setCloud.execute();\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     * @private\n     */\n    proto.onMouseDown = function () {\n\n        namespace.EditMode.prototype.onMouseDown.call(this);\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n\n        this.initialX = mousePosition.x;\n        this.initialY = mousePosition.y;\n\n        // Calculate center and size.\n        var position = editor.clientToMarkups(this.initialX, this.initialY);\n        var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n        // Create Cloud.\n        editor.beginActionGroup();\n\n        var markupId = editor.getId();\n        var create = new namespace.CreateCloud(editor, markupId, position, size, 0, this.style);\n\n        create.execute();\n\n        this.selectedMarkup = editor.getMarkup(markupId);\n        this.createBegin();\n    };\n\n    namespace.EditModeCloud = EditModeCloud;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function EditModeFreehand(editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_FREEHAND, styleAttributes);\n        this.style['stroke-opacity'] = 0.75;\n    }\n\n    EditModeFreehand.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeFreehand.prototype.constructor = EditModeFreehand;\n\n    var proto = EditModeFreehand.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteFreehand = new namespace.DeleteFreehand(this.editor, markup);\n            deleteFreehand.addToHistory = !cantUndo;\n            deleteFreehand.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseMove = function (event) {\n\n        namespace.EditMode.prototype.onMouseMove.call(this, event);\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup || !this.creating) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n        var movements = this.movements;\n\n        var location = editor.clientToMarkups(mousePosition.x, mousePosition.y);\n        movements.push(location);\n\n        // determine the position of the top-left and bottom-right points\n        var minFn = function minFn(collection, key) {\n            var targets = collection.map(function (item) {\n                return item[key];\n            });\n            return Math.min.apply(null, targets);\n        };\n\n        var maxFn = function maxFn(collection, key) {\n            var targets = collection.map(function (item) {\n                return item[key];\n            });\n            return Math.max.apply(null, targets);\n        };\n\n        var l = minFn(movements, 'x');\n        var t = minFn(movements, 'y');\n        var r = maxFn(movements, 'x');\n        var b = maxFn(movements, 'y');\n\n        var width = r - l; // Already in markup coords space\n        var height = b - t; // Already in markup coords space\n\n        var position = {\n            x: l + width * 0.5,\n            y: t + height * 0.5\n        };\n        var size = this.size = { x: width, y: height };\n\n        // Adjust points to relate from the shape's center\n        var locations = movements.map(function (point) {\n            return {\n                x: point.x - position.x,\n                y: point.y - position.y\n            };\n        });\n\n        var setFreehand = new namespace.SetFreehand(editor, selectedMarkup, position, size, locations);\n\n        setFreehand.execute();\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     * @private\n     */\n    proto.onMouseDown = function () {\n\n        namespace.EditMode.prototype.onMouseDown.call(this);\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n\n        this.initialX = mousePosition.x;\n        this.initialY = mousePosition.y;\n\n        //set the starting point\n        var position = editor.clientToMarkups(this.initialX, this.initialY);\n        this.movements = [position];\n\n        var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n        // Create arrow.\n        editor.beginActionGroup();\n\n        var markupId = editor.getId();\n        var create = new namespace.CreateFreehand(editor, markupId, position, size, 0, [{ x: 0, y: 0 }], this.style);\n\n        create.execute();\n\n        this.selectedMarkup = editor.getMarkup(markupId);\n        this.createBegin();\n    };\n\n    namespace.EditModeFreehand = EditModeFreehand;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function EditModeRectangle(editor) {\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_RECTANGLE, styleAttributes);\n    }\n\n    EditModeRectangle.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeRectangle.prototype.constructor = EditModeRectangle;\n\n    var proto = EditModeRectangle.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteRectangle = new namespace.DeleteRectangle(this.editor, markup);\n            deleteRectangle.addToHistory = !cantUndo;\n            deleteRectangle.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Sets multiple text properties at once\n     * @param {Object} style\n     */\n    proto.setStyle = function (style) {\n\n        namespace.EditMode.prototype.setStyle.call(this, style);\n\n        var rectangle = this.selectedMarkup;\n        if (!rectangle) {\n            return;\n        }\n\n        // TODO: Change to use SetStyle //\n        var setRectangle = new namespace.SetRectangle(this.editor, rectangle, rectangle.position, rectangle.size);\n\n        setRectangle.execute();\n    };\n\n    /**\n     * Handler to mouse move events, used to create markups.\n     * @param {MouseEvent} event Mouse event.\n     * @private\n     */\n    proto.onMouseMove = function (event) {\n\n        namespace.EditMode.prototype.onMouseMove.call(this, event);\n\n        var selectedMarkup = this.selectedMarkup;\n        if (!selectedMarkup || !this.creating) {\n            return;\n        }\n\n        var editor = this.editor;\n        var initialX = this.initialX;\n        var initialY = this.initialY;\n\n        var final = this.getFinalMouseDraggingPosition();\n        var position = editor.clientToMarkups((initialX + final.x) / 2, (initialY + final.y) / 2);\n        var size = this.size = editor.sizeFromClientToMarkups(final.x - initialX, final.y - initialY);\n\n        var setRectangle = new namespace.SetRectangle(editor, selectedMarkup, position, size);\n\n        setRectangle.execute();\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     * @private\n     */\n    proto.onMouseDown = function () {\n\n        namespace.EditMode.prototype.onMouseDown.call(this);\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n\n        this.initialX = mousePosition.x;\n        this.initialY = mousePosition.y;\n\n        // Calculate center and size.\n        var position = editor.clientToMarkups(this.initialX, this.initialY);\n        var size = this.size = editor.sizeFromClientToMarkups(1, 1);\n\n        // Create rectangle.\n        editor.beginActionGroup();\n\n        var markupId = editor.getId();\n        var create = new namespace.CreateRectangle(editor, markupId, position, size, 0, this.style);\n\n        create.execute();\n\n        this.selectedMarkup = editor.getMarkup(markupId);\n        this.createBegin();\n    };\n\n    namespace.EditModeRectangle = EditModeRectangle;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n\n    /**\n     *\n     * @param editor\n     * @constructor\n     */\n    function EditModeText(editor) {\n\n        var styleAttributes = ['font-size', 'stroke-color', 'stroke-opacity', 'fill-color', 'fill-opacity', 'font-family', 'font-style', 'font-weight'];\n        namespace.EditMode.call(this, editor, namespace.MARKUP_TYPE_TEXT, styleAttributes);\n        this.style['fill-color'] = '#ffffff';\n\n        var helper = new namespace.EditorTextInput(this.viewer.container, this.editor);\n        helper.addEventListener(helper.EVENT_TEXT_CHANGE, this.onHelperTextChange.bind(this), false);\n        this.textInputHelper = helper;\n        this.onHistoryChangeBinded = this.onHistoryChange.bind(this);\n        this.minSize = 0; // No need to size it initially\n    }\n\n    EditModeText.prototype = Object.create(namespace.EditMode.prototype);\n    EditModeText.prototype.constructor = EditModeText;\n\n    var proto = EditModeText.prototype;\n\n    proto.deleteMarkup = function (markup, cantUndo) {\n\n        markup = markup || this.selectedMarkup;\n        if (markup && markup.type == this.type) {\n            var deleteText = new namespace.DeleteText(this.editor, markup);\n            deleteText.addToHistory = !cantUndo;\n            deleteText.execute();\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Handler to mouse down events, used to start markups creation.\n     */\n    proto.onMouseDown = function () {\n\n        if (this.textInputHelper.isActive()) {\n            this.textInputHelper.acceptAndExit();\n            return;\n        }\n\n        if (this.selectedMarkup) {\n            return;\n        }\n\n        var editor = this.editor;\n        var mousePosition = editor.getMousePosition();\n        var clientFontSize = editor.sizeFromMarkupsToClient(0, this.style['font-size']).y;\n        var initialWidth = clientFontSize * 15; // Find better way to initialize size.\n        var initialHeight = clientFontSize * 3;\n\n        // Center position.\n        var size = this.size = editor.sizeFromClientToMarkups(initialWidth, initialHeight);\n        var position = editor.positionFromClientToMarkups(mousePosition.x + initialWidth * 0.5, mousePosition.y + initialHeight * 0.5);\n\n        editor.beginActionGroup();\n\n        // Given the initial width and font size, we assume that the text fits in one line.\n        var createText = new namespace.CreateText(editor, editor.getId(), position, size, '', this.style);\n\n        createText.execute();\n\n        this.createBegin();\n        this.createEnd();\n\n        this.selectedMarkup = editor.getMarkup(createText.targetId);\n        this.textInputHelper.setActive(this.selectedMarkup, true);\n        this.editor.actionManager.addEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n    };\n\n    proto.onDoubleClick = function (markup) {\n        if (markup === this.selectedMarkup) {\n            this.editor.selectMarkup(null);\n            this.textInputHelper.setActive(markup, false);\n        }\n    };\n\n    proto.onHelperTextChange = function (event) {\n\n        var dataBag = event.data;\n        var textMarkup = dataBag.markup;\n        var textStyle = dataBag.style;\n\n        this.editor.actionManager.removeEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n\n        // Deal with edge case first: Creating a Label without text\n        if (dataBag.newText === '') {\n\n            // If the text field is being created for the first time,\n            // we need only to cancel the action group in progress\n            if (dataBag.firstEdit) {\n                this.editor.cancelActionGroup();\n                this.editor.selectMarkup(null);\n                return;\n            }\n            // Else, we must perform a Delete action\n            else {\n                    var deleteText = new namespace.DeleteText(this.editor, textMarkup);\n                    deleteText.execute();\n                    this.editor.selectMarkup(null);\n                    return;\n                }\n        }\n\n        // When the text is created for the first time, an action group\n        // is already created and it includes the CreateText action.\n        // Thus, no need to begin another action group.\n        if (!dataBag.firstEdit) {\n            this.editor.beginActionGroup();\n        }\n\n        // Size change action //\n        var position = this.editor.positionFromClientToMarkups(dataBag.newPos.x, dataBag.newPos.y);\n        var size = this.editor.sizeFromClientToMarkups(dataBag.width, dataBag.height);\n        var setSize = new namespace.SetSize(this.editor, textMarkup, position, size.x, size.y);\n        setSize.execute();\n\n        // Text change action //\n        var setText = new namespace.SetText(this.editor, textMarkup, textMarkup.position, textMarkup.size, dataBag.newText);\n        setText.execute();\n\n        var setStyle = new namespace.SetStyle(this.editor, textMarkup, textStyle);\n        setStyle.execute();\n\n        // However, we do need to close the action group at this point. For both cases.\n        this.editor.closeActionGroup();\n        this.editor.selectMarkup(null);\n\n        // There seems to be some rendering issues when coming out of the text-edit mode\n        textMarkup.forceRedraw();\n    };\n\n    /**\n     *\n     * @param style\n     */\n    proto.setStyle = function (style) {\n\n        if (this.textInputHelper.isActive()) {\n\n            this.textInputHelper.setStyle(style);\n        } else {\n            namespace.EditMode.prototype.setStyle.call(this, style);\n\n            // After changing styles, the text gets screwed up. Fix by re-rendering it.\n            var selectedMarkup = this.selectedMarkup;\n            if (selectedMarkup) {\n                selectedMarkup.forceRedraw();\n            }\n        }\n    };\n\n    /**\n     * We want to make sure that the Input Helper gets removed from the screen\n     * whenever the user attempts to perform an undo or redo action.\n     * @param {Event} event\n     * @private\n     */\n    proto.onHistoryChange = function (event) {\n        if (this.textInputHelper.isActive()) {\n            this.editor.actionManager.removeEventListener(namespace.EVENT_HISTORY_CHANGED, this.onHistoryChangeBinded);\n            this.textInputHelper.setInactive();\n        }\n    };\n\n    proto.notifyAllowNavigation = function (allows) {\n        if (allows && this.textInputHelper.isActive()) {\n            this.textInputHelper.acceptAndExit();\n        }\n    };\n\n    proto.destroy = function () {\n        if (this.textInputHelper) {\n            if (this.textInputHelper.isActive()) {\n                this.textInputHelper.acceptAndExit();\n            }\n            this.textInputHelper.destroy();\n            this.textInputHelper = null;\n        }\n        namespace.EditMode.prototype.destroy.call(this);\n    };\n\n    namespace.EditModeText = EditModeText;\n})();\n(function () {\n    'use strict';\n\n    var namespace = Autodesk.Viewing.Extensions.Markups.Core;\n    var namespaceUtils = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n\n    /**\n     * Auxiliary class that handles all input for the Label Markup (MarkupText.js)\n     * It instantiates a TEXTAREA where the user can input text. When user input is\n     * disabled, the textarea gets hidden and further rendering is delegated to\n     * MarkupText.js\n     *\n     * @param {HTMLElement} parentDiv\n     * @param {Object} editor - Core Extension\n     * @constructor\n     */\n    function EditorTextInput(parentDiv, editor) {\n\n        this.parentDiv = parentDiv;\n        this.editor = editor;\n\n        // Constants\n        this.EVENT_TEXT_CHANGE = 'EVENT_CO2_TEXT_CHANGE';\n\n        // The actual TextArea input\n        this.textArea = document.createElement('textarea');\n        this.textArea.setAttribute('maxlength', '260'); // TODO: Make constant? Change value?\n        this.textArea.setAttribute('placeholder', namespaceUtils.Localization.MARKUP_TEXT_DEFAULT_TEXT);\n        this.onKeyHandlerBinded = this.onKeyHandler.bind(this);\n        this.textArea.addEventListener('keydown', this.onKeyHandlerBinded);\n\n        this.styleTextArea = new namespaceUtils.DomElementStyle(); // TODO: Move this to EditMode.\n        this.styleTextArea.setAttribute('position', 'absolute').setAttribute('overflow-y', 'hidden');\n\n        // Helper div to measure text width\n        this.measureDiv = document.createElement('div');\n\n        // Become an event dispatcher\n        namespaceUtils.addTraitEventDispatcher(this);\n\n        this.onResizeBinded = this.onWindowResize.bind(this);\n    }\n\n    var proto = EditorTextInput.prototype;\n\n    proto.destroy = function () {\n\n        this.textArea.removeEventListener('keydown', this.onKeyHandlerBinded);\n        this.setInactive();\n    };\n\n    /**\n     * Initializes itself given an Label Markup (textMarkup)\n     * @param {Object} textMarkup\n     * @param {Boolean} firstEdit - Whether the markup is being edited for the first time.\n     */\n    proto.setActive = function (textMarkup, firstEdit) {\n\n        if (this.textMarkup === textMarkup) {\n            return;\n        }\n\n        this.setInactive();\n        this.parentDiv.appendChild(this.textArea);\n        this.textMarkup = textMarkup;\n        this.firstEdit = firstEdit || false;\n        this.initFromMarkup();\n\n        // Component breaks when resizing. Thus, we force close it\n        window.addEventListener('resize', this.onResizeBinded);\n\n        // Focus on next frame\n        var txtArea = this.textArea;\n        window.requestAnimationFrame(function () {\n            txtArea.focus();\n        });\n    };\n\n    /**\n     * Closes the editor text input and goes back into normal markup edition mode.\n     */\n    proto.setInactive = function () {\n\n        window.removeEventListener('resize', this.onResizeBinded);\n\n        if (this.textMarkup) {\n            this.textMarkup = null;\n            this.parentDiv.removeChild(this.textArea);\n        }\n        this.style = null;\n    };\n\n    proto.isActive = function () {\n\n        return !!this.textMarkup;\n    };\n\n    /**\n     * Applies Markup styles to TextArea used for editing.\n     * It also saves a copy of the style object.\n     * @private\n     */\n    proto.initFromMarkup = function () {\n\n        var markup = this.textMarkup;\n        var position = markup.getClientPosition(),\n            size = markup.getClientSize();\n\n        var left = position.x - size.x * 0.5;\n        var top = position.y - size.y * 0.5;\n\n        var lineHeightPercentage = markup.lineHeight + \"%\";\n        this.styleTextArea.setAttribute('line-height', lineHeightPercentage);\n\n        this.setPosAndSize(left, top, size.x, size.y);\n        this.setStyle(markup.getStyle());\n        this.textArea.value = markup.getText();\n    };\n\n    proto.setPosAndSize = function (left, top, width, height) {\n\n        // We also check here that it doesn't overflow out of the canvas\n        if (left + width >= this.editor.viewer.container.clientWidth) {\n            left = this.editor.viewer.container.clientWidth - (width + 10);\n        }\n        if (top + height >= this.editor.viewer.container.clientHeight) {\n            top = this.editor.viewer.container.clientHeight - (height + 10);\n        }\n\n        this.styleTextArea\n        // Size and position\n        .setAttribute('left', left + 'px').setAttribute('top', top + 'px').setAttribute('width', width + 'px').setAttribute('height', height + 'px');\n    };\n\n    proto.setStyle = function (style) {\n        if (this.style) {\n            // An already present style means that the user\n            // has changed the style using the UI buttons.\n            // We need to account for the user having changed the\n            // width/height of the TextArea. Since there is no event\n            // we can detect for it, we do it here.\n            var temp = {};\n            this.injectSizeValues(temp);\n            this.setPosAndSize(temp.newPos.x - temp.width * 0.5, temp.newPos.y - temp.height * 0.5, temp.width, temp.height);\n        }\n        var fontHeight = this.editor.sizeFromMarkupsToClient(0, style['font-size']).y;\n        var textAreaStyle = this.styleTextArea\n        // Visuals\n        .setAttribute('color', style['stroke-color']).setAttribute('font-family', style['font-family']).setAttribute('font-size', fontHeight + 'px').setAttribute('font-weight', style['font-weight'] ? 'bold' : '').setAttribute('font-style', style['font-style'] ? 'italic' : '').getStyleString();\n        this.textArea.setAttribute('style', textAreaStyle);\n        this.style = namespaceUtils.cloneStyle(style);\n    };\n\n    /**\n     * Helper function that, for a given markup with some text in it\n     * returns an Array of lines in it.\n     * @param {Object} markup\n     * @returns {{text, lines}|{text: String, lines: Array.<String>}}\n     */\n    proto.getTextValuesForMarkup = function (markup) {\n\n        this.setActive(markup, false);\n        var textValues = this.getTextValues();\n        this.setInactive();\n        return textValues;\n    };\n\n    /**\n     * Returns the current text as one string and an array of lines\n     * of how the text is being rendered (1 string per line)\n     * @returns {{text: String, lines: Array.<String>}}\n     */\n    proto.getTextValues = function () {\n\n        var newText = this.textArea.value;\n        if (newText === namespaceUtils.Localization.MARKUP_TEXT_DEFAULT_TEXT) {\n            newText = '';\n        }\n        return {\n            text: newText,\n            lines: this.generateLines()\n        };\n    };\n\n    /**\n     * Function called by UI\n     */\n    proto.acceptAndExit = function () {\n\n        // If placeholder text, then remove.\n        var textValues = this.getTextValues();\n\n        var dataBag = {\n            markup: this.textMarkup,\n            style: this.style,\n            firstEdit: this.firstEdit,\n            newText: textValues.text,\n            newLines: textValues.lines\n        };\n        this.injectSizeValues(dataBag);\n        this.fireEvent({ type: this.EVENT_TEXT_CHANGE, data: dataBag });\n        this.setInactive(); // Do this last //\n    };\n\n    /**\n     * Injects position, width and height of the textarea rect\n     * @param {Object} dataBag\n     * @private\n     */\n    proto.injectSizeValues = function (dataBag) {\n\n        // Explicit usage of parseFloat to remove the 'px' suffix.\n        var width = parseFloat(this.textArea.style.width);\n        var height = parseFloat(this.textArea.style.height);\n        var ox = parseFloat(this.textArea.style.left);\n        var oy = parseFloat(this.textArea.style.top);\n\n        dataBag.width = width;\n        dataBag.height = height;\n        dataBag.newPos = {\n            x: ox + width * 0.5,\n            y: oy + height * 0.5\n        };\n    };\n\n    /**\n     * Handler for when the window gets resized\n     * @param {Object} event - Window resize event\n     * @private\n     */\n    proto.onWindowResize = function (event) {\n        window.requestAnimationFrame(function () {\n            var str = this.textArea.value;\n            this.style = null; // TODO: Revisit this code because style changes are lost by doing this.\n            this.initFromMarkup();\n            this.textArea.value = str;\n        }.bind(this));\n    };\n\n    proto.onKeyHandler = function (event) {\n        var keyCode = event.keyCode;\n        var shiftDown = event.shiftKey;\n\n        // We only allow RETURN when used along with SHIFT\n        if (!shiftDown && keyCode === 13) {\n            // Return\n            event.preventDefault();\n            this.acceptAndExit();\n        }\n    };\n\n    /**\n     * Grabs the text content of the textarea and returns\n     * an Array of lines.  Wrapped lines are returned as 2 lines.\n     */\n    proto.generateLines = function () {\n\n        // First, get lines separated by line breaks:\n        var textContent = this.textArea.value;\n        var linesBreaks = textContent.split(/\\r*\\n/);\n\n        var styleMeasureStr = this.styleTextArea.clone().removeAttribute(['top', 'left', 'width', 'height', 'overflow-y']).setAttribute('position', 'absolute').setAttribute('white-space', 'nowrap').setAttribute('float', 'left').setAttribute('visibility', 'hidden').getStyleString();\n        this.measureDiv.setAttribute('style', styleMeasureStr);\n        this.parentDiv.appendChild(this.measureDiv);\n\n        var maxLineLength = parseFloat(this.textArea.style.width);\n\n        // Now check whether the lines are wrapped.\n        // If so, subdivide into other lines.\n        var linesOutput = [];\n\n        for (var i = 0, len = linesBreaks.length; i < len; ++i) {\n            var line = trimRight(linesBreaks[i]);\n            this.splitLine(line, maxLineLength, linesOutput);\n        }\n\n        this.parentDiv.removeChild(this.measureDiv);\n        return linesOutput;\n    };\n\n    /**\n     * Given a String that represents one line of text that is\n     * longer than the max length a line is allowed, this method\n     * cuts text into several ones that are no longer than the max\n     * length.\n     *\n     * @param {String} text\n     * @param {Number} maxLength\n     * @param {Array} output\n     * @private\n     */\n    proto.splitLine = function (text, maxLength, output) {\n\n        // End condition\n        if (text === '') {\n            return;\n        }\n\n        var remaining = '';\n        var done = false;\n\n        while (!done) {\n            this.measureDiv.innerHTML = text;\n            var lineLen = this.measureDiv.clientWidth;\n            if (lineLen <= maxLength) {\n                output.push(text);\n                this.splitLine(trimLeft(remaining), maxLength, output);\n                done = true;\n            } else {\n                // Need to try with a shorter word!\n                var parts = this.getShorterLine(text);\n                if (parts.length === 1) {\n                    // text is only one word that is way too long.\n                    this.splitWord(text, remaining, maxLength, output);\n                    done = true;\n                } else {\n                    text = parts[0];\n                    remaining = parts[1] + remaining;\n                }\n            }\n        }\n    };\n\n    /**\n     * Given a line of text such as \"hi there programmer\", it returns\n     * an array with 2 parts: [\"hi there\", \" programmer\"].\n     *\n     * It accounts for special cases with multi-spaces, such as for\n     * \"hi there  two-spaces\" returns [\"hi there\", \"  two-spaces\"]\n     *\n     * When there is only one word, it returns the whole word:\n     * \"JustOneWord\" returns [\"JustOneWord\"] (an array of 1 element)\n     *\n     * @param {String} line\n     * @returns {Array}\n     */\n    proto.getShorterLine = function (line) {\n\n        // TODO: Account for TABs\n        // Will probably never do unless a bug is reported.\n\n        var iLastSpace = line.lastIndexOf(' ');\n        if (iLastSpace === -1) {\n            return [line]; // This is a single word\n        }\n\n        // Else\n        // Iterate back removing additional spaces (multi spaces)\n        while (line.charAt(iLastSpace - 1) === ' ') {\n            iLastSpace--;\n        }\n\n        var trailingWord = line.substr(iLastSpace); // Contains the spaces\n        var shorterLine = line.substr(0, iLastSpace);\n        return [shorterLine, trailingWord];\n    };\n\n    /**\n     * Given a single word, splits it into multiple lines that fits in maxWidth\n     * @param {String} word\n     * @param {String} remaining\n     * @param {Number} maxLength\n     * @param {Array} output\n     */\n    proto.splitWord = function (word, remaining, maxLength, output) {\n\n        var lenSoFar = 1;\n        var fits = true;\n        while (fits) {\n\n            var part = word.substr(0, lenSoFar);\n            this.measureDiv.innerHTML = part;\n            var lineLen = this.measureDiv.clientWidth;\n\n            if (lineLen > maxLength) {\n\n                if (lenSoFar === 1) {\n                    // we can't split 1 character any longer.\n                    output.push(part);\n                    this.splitWord(word.substr(1), remaining, maxLength, output);\n                    return;\n                }\n\n                // It was fine until one less char //\n                var okayWord = word.substr(0, lenSoFar - 1);\n                output.push(okayWord);\n                var extraWord = word.substr(lenSoFar - 1);\n                this.splitLine(extraWord + remaining, maxLength, output);\n                return;\n            }\n\n            // Try one more character\n            lenSoFar++;\n\n            // Check if we are done with all characters\n            if (lenSoFar > word.length) {\n                // Okay it fits\n                output.push(word);\n                return;\n            }\n        }\n    };\n\n    function trimRight(text) {\n        if (text.length === 0) {\n            return \"\";\n        }\n        var lastNonSpace = text.length - 1;\n        for (var i = lastNonSpace; i >= 0; --i) {\n            if (text.charAt(i) !== ' ') {\n                lastNonSpace = i;\n                break;\n            }\n        }\n        return text.substr(0, lastNonSpace + 1);\n    }\n\n    function trimLeft(text) {\n        if (text.length === 0) {\n            return \"\";\n        }\n        var firstNonSpace = 0;\n        for (var i = 0; i < text.length; ++i) {\n            if (text.charAt(i) !== ' ') {\n                firstNonSpace = i;\n                break;\n            }\n        }\n        return text.substr(firstNonSpace);\n    }\n\n    namespace.EditorTextInput = EditorTextInput;\n})();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvTWFya3Vwc0NvcmUuanM/NjQwOCJdLCJuYW1lcyI6WyJuYW1lc3BhY2UiLCJBdXRvZGVza05hbWVzcGFjZSIsImdldFR5cGVTdHJpbmciLCJtYXJrdXBUeXBlIiwiY29yZSIsIkF1dG9kZXNrIiwiVmlld2luZyIsIkV4dGVuc2lvbnMiLCJNYXJrdXBzIiwiQ29yZSIsIk1BUktVUF9UWVBFX1RFWFQiLCJNQVJLVVBfRVhQT1JUX1RZUEVfTEFCRUwiLCJNQVJLVVBfVFlQRV9BUlJPVyIsIk1BUktVUF9FWFBPUlRfVFlQRV9BUlJPVyIsIk1BUktVUF9UWVBFX1JFQ1RBTkdMRSIsIk1BUktVUF9FWFBPUlRfVFlQRV9SRUNUQU5HTEUiLCJNQVJLVVBfVFlQRV9DSVJDTEUiLCJNQVJLVVBfRVhQT1JUX1RZUEVfQ0lSQ0xFIiwiTUFSS1VQX1RZUEVfQ0xPVUQiLCJNQVJLVVBfRVhQT1JUX1RZUEVfQ0xPVUQiLCJNQVJLVVBfVFlQRV9GUkVFSEFORCIsIk1BUktVUF9FWFBPUlRfVFlQRV9GUkVFSEFORCIsImlkIiwiaXNUb3VjaERldmljZSIsIkhhbW1lciIsImNyZWF0ZVN2Z0VsZW1lbnQiLCJ0eXBlIiwic3ZnIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGUiLCJzZXRTdmdQYXJlbnRBdHRyaWJ1dGVzIiwiYWRkU3ZnTWV0YWRhdGEiLCJtZXRhZGF0YSIsIm1ldGFkYXRhTm9kZSIsImRhdGFWZXJzaW9uTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJhZGRNYXJrdXBNZXRhZGF0YSIsIm1hcmt1cE5vZGUiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsInJlbW92ZUFsbE1ldGFkYXRhIiwic3ZnTm9kZSIsIm5vZGVzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpIiwibGVuZ3RoIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwic3ZnQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJ0cmFuc2ZlckNoaWxkTm9kZXMiLCJub2RlRnJvbSIsIm5vZGVJbnRvIiwidG1wQXJyYXkiLCJwdXNoIiwiZm9yRWFjaCIsIm5vZGUiLCJzdmdOb2RlVG9TdHJpbmciLCJkb21Ob2RlIiwicmVzdWx0IiwieG1sU2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJzZXJpYWxpemVUb1N0cmluZyIsImVyciIsImNvbnNvbGUiLCJ3YXJuIiwic3RyaW5nVG9TdmdOb2RlIiwic3RyaW5nTm9kZSIsImRvbVBhcnNlciIsIkRPTVBhcnNlciIsImRvYyIsInBhcnNlRnJvbVN0cmluZyIsImFkZFRyYWl0RXZlbnREaXNwYXRjaGVyIiwiY2xpZW50IiwibGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwiaGFzRXZlbnRMaXN0ZW5lciIsInVuZGVmaW5lZCIsImluZGV4T2YiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQXJyYXkiLCJsaSIsImxlbiIsInNwbGljZSIsImZpcmVFdmVudCIsImV2ZW50IiwidGFyZ2V0IiwiRXJyb3IiLCJ0eXBlTGlzdGVuZXJzIiwic2xpY2UiLCJjYWxsIiwicmVtb3ZlVHJhaXRFdmVudERpc3BhdGNoZXIiLCJlIiwid29ybGRUb0NsaWVudCIsInBvaW50Iiwidmlld2VyIiwic25hcCIsInAiLCJ3b3JsZFRvVmlld3BvcnQiLCJpbXBsIiwidmlld3BvcnRUb0NsaWVudCIsIngiLCJ5IiwieiIsIk1hdGgiLCJmbG9vciIsImNsaWVudFRvV29ybGQiLCJjbGllbnRYIiwiY2xpZW50WSIsImRlcHRoIiwiY2xpZW50VG9WaWV3cG9ydCIsInVucHJvamVjdCIsImNhbWVyYSIsIlRIUkVFIiwiVmVjdG9yMyIsInByb2plY3QiLCJtZXRlcnNUb01vZGVsIiwibWV0ZXJzIiwibW9kZWxUb01ldGVyIiwibW9kZWwiLCJnZXRVbml0U2NhbGUiLCJtZXRlclRvTW9kZWwiLCJyYWRpYW5zVG9EZWdyZWVzIiwicmFkaWFucyIsIlBJIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJzaWduIiwidmFsdWUiLCJmb3JjZU9ydGhvZ3JhcGhpY0NhbWVyYSIsIm5hdmlnYXRpb24iLCJpczJkIiwibmF2QXBpIiwiZ2V0Q2FtZXJhIiwiaXNQZXJzcGVjdGl2ZSIsInRvT3J0aG9ncmFwaGljIiwiaGlkZUxtdlVpIiwic2V0QWN0aXZlTmF2aWdhdGlvblRvb2wiLCJkaXNtaXNzTG12SHVkTWVzc2FnZSIsImhpZGVMbXZQYW5lbHMiLCJoaWRlTG12VG9vbHNBbmRQYW5lbHMiLCJyZXN0b3JlTG12VWkiLCJzaG93TG12VG9vbHNBbmRQYW5lbHMiLCJoaWRlIiwiZG9ja2luZ1BhbmVscyIsInBhbmVsIiwicGFuZWxDb250YWluZXIiLCJjb250YWluZXIiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsInN0eWxlIiwiZGlzcGxheSIsInZpc2liaWxpdHlDaGFuZ2VkIiwiZGlzcGxheVZpZXdDdWJlIiwiaG9tZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJpbmZvIiwiYW5pbSIsInRvb2xiYXIiLCJ2aWV3ZXJDb250YWluZXIiLCJ2aWV3ZXJDb250YWluZXJDaGlsZHJlbkNvdW50IiwiYW5pbWF0b3IiLCJrZXlGcmFtZUFuaW1hdG9yIiwiaXNQYXVzZWQiLCJwYXVzZUNhbWVyYUFuaW1hdGlvbnMiLCJwYXVzZSIsInBsYXlCdXR0b24iLCJtb2RlbFRvb2xzIiwiZ2V0Q29udHJvbCIsInNldEljb24iLCJzZXRUb29sVGlwIiwia2VlcERpc21pc3NpbmciLCJQcml2YXRlIiwiSHVkTWVzc2FnZSIsImRpc21pc3MiLCJpZ25vcmUiLCJjcmVhdGVTdHlsZSIsImF0dHJpYnV0ZXMiLCJkZWZhdWx0cyIsImdldFN0eWxlRGVmYXVsdFZhbHVlcyIsImF0dHJpYnV0ZSIsInZhbHVlcyIsImRlZmF1bHQiLCJjb3B5U3R5bGUiLCJzb3VyY2UiLCJkZXN0aW5hdGlvbiIsImNsb25lU3R5bGUiLCJjbG9uZSIsImdldFN0cm9rZVdpZHRoIiwid2lkdGgiLCJkYXRhIiwiZ2V0RGF0YSIsImEiLCJiIiwiYWJzIiwiZ2V0V2lkdGhzIiwic21hbGxXaWR0aCIsIm5hbWUiLCJnZXRGb250U2l6ZXMiLCJnZXRDb2xvcnMiLCJnZXRPcGFjaXRpZXMiLCJkZWZhdWx0VHJhbnNwYXJlbnQiLCJnZXRGb250RmFtaWxpZXMiLCJnZXRGb250U3R5bGVzIiwiZ2V0Rm9udFdlaWdodHMiLCJjb21wb3NlUkdCQVN0cmluZyIsImhleFJHQlN0cmluZyIsIm9wYWNpdHkiLCJyZ2JhIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJqb2luIiwiRWRpdEFjdGlvbiIsImVkaXRvciIsInRhcmdldElkIiwiYWRkVG9IaXN0b3J5Iiwic2VsZWN0T25FeGVjdXRpb24iLCJwcm90b3R5cGUiLCJleGVjdXRlIiwiYWN0aW9uTWFuYWdlciIsInJlZG8iLCJ1bmRvIiwibWVyZ2UiLCJhY3Rpb24iLCJpc0lkZW50aXR5IiwibmFtZXNwYWNlVXRpbHMiLCJVdGlscyIsIkVkaXRBY3Rpb25NYW5hZ2VyIiwiaGlzdG9yeVNpemUiLCJ1bmRvU3RhY2siLCJyZWRvU3RhY2siLCJFVkVOVF9ISVNUT1JZX0NIQU5HRUQiLCJwcm90byIsImdyb3VwIiwiZ2V0RWRpdEFjdGlvbkdyb3VwIiwiaXNPcGVuIiwiYWRkQWN0aW9uIiwib3BlbiIsImNsb3NlIiwiYmVnaW5BY3Rpb25Hcm91cCIsInVuZG9TdGFja0NvdW50IiwiaXNDbG9zZWQiLCJjbG9zZUFjdGlvbkdyb3VwIiwiaXNFbXB0eSIsInBvcCIsImNhbmNlbEFjdGlvbkdyb3VwIiwiY2xlYXIiLCJpc1VuZG9TdGFja0VtcHR5IiwiaXNSZWRvU3RhY2tFbXB0eSIsIkVkaXRBY3Rpb25Hcm91cCIsIkRvbUVsZW1lbnRTdHlsZSIsInJlc2V0IiwiQlJPV1NFUl9QUkVGSVhFUyIsImRpcnR5Iiwic3R5bGVTdHJpbmciLCJvcHRpb25zIiwiYWxsQnJvd3NlcnMiLCJ0aGF0IiwicHJlZml4IiwicmVtb3ZlQXR0cmlidXRlIiwiaXNBcnJheSIsInNlbGYiLCJrIiwiZ2V0U3R5bGVTdHJpbmciLCJnZW5lcmF0ZVN0eWxlIiwiZWxlbWVudHMiLCJ2YWwiLCJFZGl0RnJhbWUiLCJjb250YWluaW5nRGl2Iiwic2VsZWN0aW9uTGF5ZXIiLCJjcmVhdGVTZWxlY3Rpb25MYXllciIsInNlbGVjdGlvbiIsImhlaWdodCIsInJvdGF0aW9uIiwiZWxlbWVudCIsImFjdGl2ZSIsImRyYWdnaW5nIiwicmVzaXppbmciLCJoYW5kbGUiLCJjcmVhdGVTZWxlY3RvckJveCIsImJpbmQiLCJvbkhhbW1lckRyYWdCaW5kZWQiLCJvbkhhbW1lckRyYWciLCJoYW1tZXIiLCJNYW5hZ2VyIiwicmVjb2duaXplcnMiLCJQYW4iLCJwb2ludGVycyIsImlucHV0Q2xhc3MiLCJUb3VjaElucHV0IiwiaGFuZGxlU2VsZWN0aW9uQm94RHJhZ2dpbmciLCJoYW5kbGVTZWxlY3Rpb25Cb3hSZXNpemluZyIsImhhbmRsZVNlbGVjdGlvbkRvdWJsZUNsaWNrIiwiaGFuZGxlU2VsZWN0aW9uQm94Um90YXRpbmciLCJFVkVOVF9FRElURlJBTUVfRURJVElPTl9TVEFSVCIsIkVWRU5UX0VESVRGUkFNRV9FRElUSU9OX0VORCIsInNldFNlbGVjdGlvbiIsInVwZGF0ZVNlbGVjdG9yQm94RGltZW5zaW9ucyIsInVwZGF0ZVNlbGVjdG9yQm94UG9zaXRpb24iLCJ1cGRhdGVTZWxlY3Rpb25Cb3hTdGF0ZSIsInZpc2liaWxpdHkiLCJzZXRNYXJrdXAiLCJtYXJrdXAiLCJvZmYiLCJvbiIsInNpemUiLCJnZXRDbGllbnRTaXplIiwicG9zaXRpb24iLCJnZXRDbGllbnRQb3NpdGlvbiIsImdldFJvdGF0aW9uIiwiZW5hYmxlUmVzaXplSGFuZGxlcyIsImVuYWJsZVJvdGF0aW9uSGFuZGxlIiwic3RhcnREcmFnIiwiX29uUmVwb3NpdGlvbk1vdXNlRG93biIsImdldE1vdXNlUG9zaXRpb24iLCJpc0FjdGl2ZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNSb3RhdGluZyIsInJvdGF0aW5nIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlVXAiLCJ1cGRhdGVFZGl0b3JJbnB1dCIsImlucHV0IiwicGFyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIm1vdXNlUG9zaXRpb24iLCJwYWdlWCIsImxlZnQiLCJwYWdlWSIsInRvcCIsImNvbnZlcnRFdmVudEhhbW1lclRvTW91c2UiLCJpc1JvdGF0ZVBvaW50IiwiX29uUm90YXRpb25Nb3VzZURvd24iLCJpc0RyYWdQb2ludCIsIl9vblJlc2l6ZU1vdXNlRG93biIsInByZXZlbnREZWZhdWx0IiwiaXNIZWlnaHRDb25zdHJhaW5lZCIsImlzV2lkdGhDb25zdHJhaW5lZCIsImRpcmVjdGlvbiIsInJvdGF0aW9uSGFuZGxlIiwiaXNSb3RhdGlvbkNvbnN0cmFpbmVkIiwiYm90dG9tIiwicmlnaHQiLCJvdmVyZmxvdyIsInRvZ2dsZVBvaW50ZXJFdmVudHMiLCJjcmVhdGVEcmFnUG9pbnQiLCJkaWFtZXRlciIsInBvaW50Qm9yZGVyV2lkdGgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJib3hTaXppbmciLCJzZXRSZXNpemVDdXJzb3IiLCJjbGFzc05hbWUiLCJwbGFjZW1lbnRPZmZzZXQiLCJ3cmFwcGVyIiwibWFyZ2luIiwidHJhbnNmb3JtIiwiY3JlYXRlUm90YXRlUG9pbnQiLCJhZGQiLCJjdXJzb3IiLCJjcmVhdGVEcmFnUG9pbnRzIiwic2VsZWN0b3IiLCJwb2ludERpYW1ldGVyIiwibWF0Y2hlc1NlbGVjdG9yQXV4IiwiYm9yZGVyV2lkdGgiLCJib3JkZXJDb2xvciIsInNlbGVjdG9yQm94IiwiekluZGV4IiwidG9UcmFuc2xhdGUzZCIsIm1zVHJhbnNmb3JtIiwibXNUcmFuc2Zvcm1PcmlnaW4iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJ3ZWJraXRUcmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJzeW50aGV0aWNTdGFydCIsIk1vdXNlRXZlbnQiLCJpbml0aWFsQ3Vyc29yIiwiaW5pdGlhbFBvc2l0aW9uIiwiYXJlQXhpc0NvbnN0cmFpbmVkIiwiYXhpc0NvbnN0cmFpbnMiLCJWZWN0b3IyIiwiX29uUmVwb3NpdGlvbk1vdXNlTW92ZSIsIl9vblJlcG9zaXRpb25Nb3VzZVVwIiwiYWx0S2V5IiwiY2xvbmVNYXJrdXAiLCJDbG9uZU1hcmt1cCIsImdldElkIiwiY29uc3RyYWluQXhpcyIsIm1vdmVtZW50IiwiZGVhZFpvbmUiLCJwb3NpdGlvbkZyb21DbGllbnRUb01hcmt1cHMiLCJzZXRQb3NpdGlvbiIsIlNldFBvc2l0aW9uIiwibGFzdCIsImdldEF0dHJpYnV0ZSIsImluaXRpYWwiLCJtb3VzZVgiLCJtb3VzZVkiLCJfb25SZXNpemVNb3VzZU1vdmUiLCJfb25SZXNpemVNb3VzZVVwIiwidmVjdG9yIiwidW5kb1JvdGF0aW9uIiwiTWF0cml4NCIsIm1ha2VSb3RhdGlvbloiLCJhcHBseU1hdHJpeDQiLCJsb2NhbFNwYWNlRGVsdGEiLCJrZWVwQXNwZWN0UmF0aW8iLCJkZWx0YSIsInNldCIsIm5vcm1hbGl6ZSIsInByb2plY3RPblZlY3RvciIsInRyYW5zbGF0aW9ucyIsIm4iLCJzIiwidyIsIm53IiwibmUiLCJzdyIsInNlIiwicmVkb1JvdGF0aW9uIiwiYWN0dWFsRGVsdGEiLCJuZXdQb3MiLCJuZXdTaXplIiwic2l6ZUZyb21DbGllbnRUb01hcmt1cHMiLCJzZXRTaXplIiwiU2V0U2l6ZSIsImluaXRpYWxSb3RhdGlvbiIsImluaXRpYWxIYW5kbGVQb3NpdGlvbiIsIl9vblJvdGF0aW9uTW91c2VNb3ZlIiwiX29uUm90YXRpb25Nb3VzZVVwIiwiciIsImdldEFuZ2xlQmV0d2VlblBvaW50cyIsInIyIiwic25hcFJvdGF0aW9ucyIsImNlaWwiLCJzZXRSb3RhdGlvbiIsIlNldFJvdGF0aW9uIiwiZG91YmxlQ2xpY2siLCJlZGl0TW9kZSIsIm9uRG91YmxlQ2xpY2siLCJzZWxlY3RvckJveFdyYXBwZXIiLCJzdGF0ZSIsInBvaW50ZXJFdmVudHMiLCJwMSIsInAyIiwiYXRhbjIiLCJkb21FbGVtIiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiTG9jYWxpemF0aW9uIiwiTUFSS1VQX1RFWFRfREVGQVVMVF9URVhUIiwiTWFya3VwIiwic3R5bGVBdHRyaWJ1dGVzIiwiaGlnaGxpZ2h0Q29sb3IiLCJjb25zdHJhaW50V2lkdGgiLCJjb25zdHJhaW50SGVpZ2h0IiwiY29uc3RyYWludFJvdGF0aW9uIiwiaGlnaGxpZ2h0ZWQiLCJzZWxlY3RlZCIsIkVWRU5UX0VESVRNT0RFX0NIQU5HRUQiLCJFVkVOVF9NQVJLVVBfU0VMRUNURUQiLCJFVkVOVF9NQVJLVVBfRFJBR0dJTkciLCJFVkVOVF9NQVJLVVBfRU5URVJfRURJVElPTiIsIkVWRU5UX01BUktVUF9DQU5DRUxfRURJVElPTiIsIkVWRU5UX01BUktVUF9ERUxFVEVfRURJVElPTiIsImRlc3Ryb3kiLCJPYmplY3QiLCJjcmVhdGUiLCJfX3Byb3RvX18iLCJvdmVycmlkZXMiLCJnZXRDbG9uZU92ZXJyaWRlcyIsIm1lbWJlciIsIkZ1bmN0aW9uIiwibm9kZVR5cGUiLCJjbG9uZU5vZGUiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJiaW5kRG9tRXZlbnRzIiwic2VsZWN0IiwidXBkYXRlU3R5bGUiLCJ1bnNlbGVjdCIsImhpZ2hsaWdodCIsImludGVyYWN0aW9uc0Rpc2FibGVkIiwiZ2V0U3R5bGUiLCJzZXRTdHlsZSIsImZpbmlzaERyYWdnaW5nIiwiZWRpdCIsImNhbmNlbCIsImRlbGV0ZU1hcmt1cCIsInNldFBhcmVudCIsImdldEVkaXRNb2RlIiwicG9zaXRpb25Gcm9tTWFya3Vwc1RvQ2xpZW50Iiwic2l6ZUZyb21NYXJrdXBzVG9DbGllbnQiLCJhbmdsZSIsImRpc2FibGVJbnRlcmFjdGlvbnMiLCJkaXNhYmxlIiwic2V0U3Ryb2tlV2lkdGgiLCJjb25zdHJhaW5zVG9Cb3VuZHMiLCJib3VuZHMiLCJvbk1vdXNlRG93biIsImVkaXRGcmFtZSIsInNldE1ldGFkYXRhIiwiYmluZFRvdWNoRXZlbnRzIiwiZG9tRWxlbWVudCIsIlRhcCIsInRocmVzaG9sZCIsIm9uU2luZ2xlVGFwQmluZGVkIiwiTWFya3VwQXJyb3ciLCJoZWFkIiwidGFpbCIsImNyZWF0ZVNWRyIsImNvbnN0cnVjdG9yIiwiRWRpdE1vZGVBcnJvdyIsInNoYXBlIiwieE8iLCJ5TyIsInhGIiwieUYiLCJ2TyIsInZGIiwidkRpciIsInN1YiIsImRpc3RhbmNlVG8iLCJhY29zIiwiZG90IiwidXBkYXRlVHJhbnNmb3JtTWF0cml4IiwiY29zIiwic2luIiwidkZEaXIiLCJtdWx0aXBseVNjYWxhciIsInZDZW50ZXIiLCJtaWRfeCIsIm1pZF95IiwicG9zX3giLCJwb3NfeSIsInRyYW5zZm9ybVN2ZyIsInN0cm9rZUNvbG9yIiwicG9seWdvblBvaW50cyIsImdldFBvbHlnb25Qb2ludHMiLCJtYXBwZWRQb2ludHMiLCJtYXAiLCJwb2x5Z29uU3RyIiwic3Ryb2tlV2lkdGgiLCJoYWxmX2xlbiIsInRoaWNrbmVzcyIsImhhbGZfdGhpY2tuZXNzIiwiaGVhZF9sZW4iLCJwNyIsInA0IiwicDMiLCJwNiIsInA1IiwicG9pbnRzIiwiZGl2IiwiZHgiLCJkeSIsInhvIiwieW8iLCJjcmVhdGVkIiwiU3RyaW5nIiwicmVuZGVyVG9DYW52YXMiLCJjdHgiLCJzdHJva2VPcGFjaXR5IiwiY2xpZW50TWlkIiwiY2xpZW50UG9zIiwibTEiLCJtYWtlVHJhbnNsYXRpb24iLCJtMiIsIm0zIiwibXVsdGlwbHkiLCJmaWxsU3R5bGUiLCJiZWdpblBhdGgiLCJsaW5lVG8iLCJmaWxsIiwiTWFya3VwQ2lyY2xlIiwiRWRpdE1vZGVDaXJjbGUiLCJvcmlnaW5YIiwibWF4Iiwib3JpZ2luWSIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwicmFkX3giLCJyYWRfeSIsImVsbGlwc2UiLCJjeCIsImN5IiwiaCIsImx4IiwicngiLCJ0eSIsImJ5IiwibWFnaWMiLCJ4bWFnaWMiLCJ5bWFnaWMiLCJtb3ZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwic3Ryb2tlIiwiY2VudGVyIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJ0cmFuc2xhdGUiLCJyb3RhdGUiLCJNYXJrdXBDbG91ZCIsImxpbmVKb2ludCIsIkVkaXRNb2RlQ2xvdWQiLCJwYXRoTW92ZW1lbnRzIiwiZ2V0UGF0aE1vdmVtZW50cyIsIm1hcHBlZE1vdmVtZW50cyIsIm1vdmVzIiwiaW5kZXgiLCJjb25jYXQiLCJiZXppZXIiLCJtb3ZlIiwidldpZHRoIiwidkhlaWdodCIsImFyY1dpZHRoIiwiYXJjSGVpZ2h0Iiwib2Zmc2V0RnJvbVZlcnRleCIsImNsb3VkV2lkdGgiLCJjbG91ZEhlaWdodCIsIm51bU9mSG9yaXpvbnRhbEFyY3MiLCJudW1PZlZlcnRpY2FsQXJjcyIsInBhcnRpYWxIb3Jpem9udGFsQXJjIiwicGFydGlhbFZlcnRpY2FsQXJjIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImJlemllckN1cnZlIiwic2lkZSIsImxjcE9mZnNldCIsInJjcE9mZnNldCIsIm1vdmVtZW50cyIsImhvcml6b250YWwiLCJpc0hvcml6b250YWwiLCJudW1PZkFyY3MiLCJwYXJ0aWFsQXJjIiwibGluZUpvaW4iLCJ2ZWN0b3IzIiwibWFwcGluZ0ZuIiwicG9zIiwiY3AxIiwiY3AyIiwiZW5kIiwiY2xvc2VQYXRoIiwiTWFya3VwRnJlZWhhbmQiLCJpbmlTaXplIiwiRWRpdE1vZGVGcmVlaGFuZCIsImxvY2F0aW9ucyIsInNjYWxlWCIsInNjYWxlWSIsInBhdGhEYXRhIiwibTAiLCJtYWtlU2NhbGUiLCJNYXJrdXBSZWN0YW5nbGUiLCJFZGl0TW9kZVJlY3RhbmdsZSIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50Q2VudGVyIiwiZmlsbFJlY3QiLCJzdHJva2VSZWN0IiwiTWFya3VwVGV4dCIsImN1cnJlbnRUZXh0IiwiY3VycmVudFRleHRMaW5lcyIsInRleHREaXJ0eSIsImxpbmVIZWlnaHQiLCJjcmVhdGVTdmciLCJFZGl0TW9kZVRleHQiLCJjbGlwUGF0aCIsImNsaXBQYXRoSWQiLCJjbGlwUmVjdCIsInNoYXBlQmciLCJ0ZXh0U3RyaW5nIiwidGV4dExpbmVzIiwic2V0VGV4dCIsIm94Iiwib3kiLCJyZWNhbGNMaW5lcyIsIm5ld0xpbmVzIiwiY2FsY1RleHRMaW5lcyIsImxpbmVzQXJlRXF1YWwiLCJmb3JjZVJlZHJhdyIsInRleHRJbnB1dEhlbHBlciIsImdldFRleHRWYWx1ZXNGb3JNYXJrdXAiLCJsaW5lcyIsImN1cnIiLCJjdXJyZW50UGFyZW50IiwidGV4dCIsImdldFRleHQiLCJnZXRUZXh0TGluZXMiLCJmb3JjZURpcnR5IiwiZm9udFNpemUiLCJiYm94IiwiZ2V0QkJveCIsInZlcnRpY2FsVHJhbnNmb3JtIiwicmVidWlsZFRleHRTdmciLCJ5T2Zmc2V0IiwiZ2V0TGluZUhlaWdodCIsImxpbmUiLCJ0c3BhbiIsInRleHRDb250ZW50IiwiZ2V0Q2xpZW50Rm9udFNpemUiLCJ3aW5kb3ciLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW5kZXJMaW5lc09mVGV4dCIsIm1heEhlaWdodCIsImZpbGxUZXh0IiwiZm9udEZhbWlseSIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJmb250T3BhY2l0eSIsImNsaWVudFNpemUiLCJzYXZlIiwicmVzdG9yZSIsInRleHRCYXNlbGluZSIsImZvbnQiLCJnbG9iYWxBbHBoYSIsIk1hcmt1cFRvb2wiLCJUb29sSW50ZXJmYWNlIiwibmFtZXMiLCJwYW5Ub29sIiwiYWxsb3dOYXYiLCJjb3JlRXh0IiwiaG90a2V5c0VuYWJsZWQiLCJfY3RybERvd24iLCJfc2hpZnREb3duIiwiYWxsb3dOYXZpZ2F0aW9uIiwiYWxsb3ciLCJzZXRDb3JlRXh0ZW5zaW9uIiwic2V0SG90a2V5c0VuYWJsZWQiLCJlbmFibGVkIiwiYWN0aXZhdGUiLCJ2aWV3ZXJBcGkiLCJ0b29sQ29udHJvbGxlciIsImdldFRvb2wiLCJkZWFjdGl2YXRlIiwiaGFuZGxlS2V5RG93biIsImtleUNvZGUiLCJLZXlDb2RlIiwiQ09OVFJPTCIsIlNISUZUIiwiY3V0IiwiYyIsImNvcHkiLCJ2IiwicGFzdGUiLCJkIiwiRVNDQVBFIiwic2VsZWN0TWFya3VwIiwiaGFuZGxlS2V5VXAiLCJ1cGRhdGUiLCJoYW5kbGVTaW5nbGVDbGljayIsImJ1dHRvbiIsImhhbmRsZURvdWJsZUNsaWNrIiwiaGFuZGxlU2luZ2xlVGFwIiwiaGFuZGxlRG91YmxlVGFwIiwiaGFuZGxlV2hlZWxJbnB1dCIsImhhbmRsZUJ1dHRvbkRvd24iLCJoYW5kbGVCdXR0b25VcCIsImhhbmRsZU1vdXNlTW92ZSIsImhhbmRsZUdlc3R1cmUiLCJoYW5kbGVCbHVyIiwiTWFya3Vwc0NvcmUiLCJFeHRlbnNpb24iLCJtYXJrdXBzIiwic3R5bGVzIiwiZHVyaW5nVmlld01vZGUiLCJkdXJpbmdFZGl0TW9kZSIsIm9uRWRpdEFjdGlvbkhpc3RvcnlDaGFuZ2VkIiwibmV4dElkIiwiY2xpcGJvYXJkIiwiQ2xpcGJvYXJkIiwiSW5wdXRIYW5kbGVyIiwib25DYW1lcmFDaGFuZ2VCaW5kZWQiLCJvbkNhbWVyYUNoYW5nZSIsIm9uVmlld2VyUmVzaXplQmluZGVkIiwib25WaWV3ZXJSZXNpemUiLCJvbk1hcmt1cERyYWdnaW5nQmluZGVkIiwib25NYXJrdXBEcmFnZ2luZyIsIm9uTWFya3VwU2VsZWN0ZWRCaW5kZWQiLCJvbk1hcmt1cFNlbGVjdGVkIiwib25NYXJrdXBFbnRlckVkaXRpb25CaW5kZWQiLCJvbk1hcmt1cEVudGVyRWRpdGlvbiIsIm9uTWFya3VwQ2FuY2VsRWRpdGlvbkJpbmRlZCIsIm9uTWFya3VwQ2FuY2VsRWRpdGlvbiIsIm9uTWFya3VwRGVsZXRlRWRpdGlvbkJpbmRlZCIsIm9uTWFya3VwRGVsZXRlRWRpdGlvbiIsIkVWRU5UX0VOVEVSX0VESVRfTU9ERSIsIkVWRU5UX0xFQVZFX0VESVRfTU9ERSIsIkVWRU5UX1NFTEVDVElPTl9DSEFOR0VEIiwibG9hZCIsInN2Z1N0eWxlIiwiYXR0YWNoVG8iLCJkaXNhYmxlTWFya3VwSW50ZXJhY3Rpb25zIiwidG9vbENsYXNzIiwibWFya3VwVG9vbENsYXNzIiwibWFya3VwVG9vbCIsIm1hcmt1cERpc2FibGVIb3RrZXlzIiwicmVnaXN0ZXJUb29sIiwidW5sb2FkIiwiZGV0YWNoRnJvbSIsImRlcmVnaXN0ZXJUb29sIiwib25Nb3VzZURvd25CaW5kZWQiLCJlZGl0TW9kZVN2Z0xheWVyTm9kZSIsInRvZ2dsZUVkaXRNb2RlIiwibGVhdmVFZGl0TW9kZSIsImVudGVyRWRpdE1vZGUiLCJzaG93IiwiZ2V0TmFtZSIsImNoYW5nZUVkaXRNb2RlIiwiTk9UX0lOX0VESVRfTU9ERSIsIldFX0FSRV9TVElMTF9JTl9FRElUX01PREUiLCJ0b2dnbGUiLCJDQU1FUkFfQ0hBTkdFX0VWRU5UIiwiVklFV0VSX1JFU0laRV9FVkVOVCIsImVudGVyVmlld01vZGUiLCJvblZpZXdlclJvbGxvdmVyT2JqZWN0Iiwicm9sbG92ZXJPYmplY3QiLCJtYXJrdXBCeXBhc3NPcnRob0NhbSIsImNhY2hlZE5hdmlnYXRpb25Ub29sIiwiZ2V0QWN0aXZlTmF2aWdhdGlvblRvb2wiLCJzdmdMYXllcnNNYXAiLCJSRVNVTFRfSElERV9PSyIsIlJFU1VMVF9ISURFX0ZBSUwiLCJ1bmxvYWRNYXJrdXBzQWxsTGF5ZXJzIiwibGVhdmVWaWV3TW9kZSIsInJlbW92ZU1hcmt1cCIsImdlbmVyYXRlRGF0YSIsInRtcE5vZGUiLCJtZXRhZGF0YU9iamVjdCIsIm1ldGFkYXRhTm9kZXMiLCJhZGRlZE5vZGUiLCJjb250ZXh0Iiwib2xkRWRpdE1vZGUiLCJFVkVOVF9FRElUTU9ERV9DUkVBVElPTl9CRUdJTiIsIkVWRU5UX0VESVRNT0RFX0NSRUFUSU9OX0VORCIsIkVWRU5UX01BUktVUF9ERVNFTEVDVCIsIm5hdmlnYXRpbmciLCJub3RpZnlBbGxvd05hdmlnYXRpb24iLCJjaGFuZ2VJbnB1dEhhbmRsZXIiLCJpbnB1dEhhbmRsZXIiLCJrZWVwU2VsZWN0aW9uIiwic2VsZWN0ZWRNYXJrdXAiLCJnZXRNYXJrdXAiLCJtYXJrdXBzQ291bnQiLCJnZXRTZWxlY3Rpb24iLCJkb250QWRkVG9IaXN0b3J5IiwiYWRkTWFya3VwIiwibWFya3Vwc0luZGV4IiwiYnJpbmdUb0Zyb250Iiwic2VuZE1hcmt1cFRvIiwic2VuZFRvQmFjayIsImJyaW5nRm9yd2FyZCIsIm1hcmt1cEluZGV4IiwiYnJpbmdCYWNrd2FyZCIsImxvYWRNYXJrdXBzIiwibWFya3VwU3RyaW5nIiwibGF5ZXJJZCIsInN2Z0xheWVyTm9kZSIsInVubG9hZE1hcmt1cHMiLCJoaWRlTWFya3VwcyIsInNob3dNYXJrdXBzIiwiY2xpZW50VG9NYXJrdXBzIiwibWFya3Vwc1RvQ2xpZW50IiwibWF0cml4V29ybGQiLCJtYXRyaXhXb3JsZEludmVyc2UiLCJnZXRTdmdWaWV3Qm94IiwibHQiLCJyYiIsImwiLCJtaW4iLCJ0IiwiZ2V0Qm91bmRzIiwidmlld0JveCIsImNyZWF0aW5nIiwiaWdub3JlTmV4dE1vdXNlVXAiLCJzdGFydERyYWdnaW5nIiwidGhlRXh0ZW5zaW9uTWFuYWdlciIsInJlZ2lzdGVyRXh0ZW5zaW9uIiwiQ3JlYXRlQXJyb3ciLCJhcnJvdyIsIkNyZWF0ZUNpcmNsZSIsImNpcmNsZSIsIkNyZWF0ZUNsb3VkIiwiY2xvdWQiLCJDcmVhdGVGcmVlaGFuZCIsImZyZWVoYW5kIiwiQ3JlYXRlUmVjdGFuZ2xlIiwicmVjdGFuZ2xlIiwiQ3JlYXRlVGV4dCIsIkRlbGV0ZUFycm93IiwiY3JlYXRlQXJyb3ciLCJEZWxldGVDaXJjbGUiLCJjcmVhdGVDaXJjbGUiLCJEZWxldGVDbG91ZCIsImNyZWF0ZUNsb3VkIiwiRGVsZXRlRnJlZWhhbmQiLCJjcmVhdGVGcmVlaGFuZCIsIkRlbGV0ZVJlY3RhbmdsZSIsImNyZWF0ZVJlY3RhbmdsZSIsIkRlbGV0ZVRleHQiLCJjcmVhdGVUZXh0IiwiYWN0aW9ucyIsImNsb3NlZCIsImFjdGlvbnNNYXhJbmRleCIsImFjdGlvbnNDb3VudCIsImNvbXBhY3QiLCJhY3Rpb25BIiwiaiIsImFjdGlvbkIiLCJTZXRBcnJvdyIsIm5ld0hlYWQiLCJuZXdUYWlsIiwib2xkSGVhZCIsIm9sZFRhaWwiLCJhcHBseVN0YXRlIiwiZXBzaWxvbiIsIlNldENpcmNsZSIsIm5ld1Bvc2l0aW9uIiwib2xkUG9zaXRpb24iLCJvbGRTaXplIiwiU2V0Q2xvdWQiLCJuZXdTdHJva2VXaWR0aCIsIm5ld0NvbG9yIiwib2xkU3Ryb2tlV2lkdGgiLCJvbGRDb2xvciIsIlNldEZyZWVoYW5kIiwiU2V0UmVjdGFuZ2xlIiwiY3VyQW5nbGUiLCJuZXdSb3RhdGlvbiIsIm9sZFJvdGF0aW9uIiwibmV3V2lkdGgiLCJvbGRXaWR0aCIsIm5ld0hlaWdodCIsIm9sZEhlaWdodCIsImlkZW50aXR5IiwiU2V0U3R5bGUiLCJuZXdTdHlsZSIsIm9sZFN0eWxlIiwiU2V0VGV4dCIsIm5ld1RleHQiLCJvbGRUZXh0IiwiY29udGVudCIsInBhc3RlUG9zaXRpb24iLCJtYWtlU2FtZVhZIiwib25TaW5nbGVUYXAiLCJvbk1vdXNlTW92ZUJpbmRlZCIsIm9uTW91c2VVcEJpbmRlZCIsInByb2Nlc3NNb3VzZUV2ZW50Iiwic2hpZnRLZXkiLCJFZGl0TW9kZSIsImRyYWdnaW5nQW5ub3RhdGlvbkluaVBvc2l0aW9uIiwiZHJhZ2dpbmdNb3VzZUluaVBvc2l0aW9uIiwiaW5pdGlhbFgiLCJpbml0aWFsWSIsIm1pblNpemUiLCJmaXJlRXYiLCJjcmVhdGVCZWdpbiIsImNyZWF0ZUVuZCIsImNhbnRVbmRvIiwiaXNNaW5TaXplVmFsaWQiLCJ0bXAiLCJnZXRGaW5hbE1vdXNlRHJhZ2dpbmdQb3NpdGlvbiIsImZpbmFsWCIsImZpbmFsWSIsIm1heERlbHRhIiwiYWxsb3dzIiwiY2FuY2VsTWFya3VwQ3JlYXRpb24iLCJnZXREcmFnZ2luZ1Bvc2l0aW9uIiwiaXNJbnNpZGVCb3VuZHMiLCJkZWxldGVBcnJvdyIsInJvdW5kIiwiY29uc3RyYWluIiwiYXJyb3dJZCIsImZpbmFsIiwic2V0QXJyb3ciLCJkZWxldGVDaXJjbGUiLCJzZXRDaXJjbGUiLCJtYXJrdXBJZCIsImRlbGV0ZUNsb3VkIiwic2V0Q2xvdWQiLCJkZWxldGVGcmVlaGFuZCIsImxvY2F0aW9uIiwibWluRm4iLCJjb2xsZWN0aW9uIiwidGFyZ2V0cyIsIml0ZW0iLCJhcHBseSIsIm1heEZuIiwic2V0RnJlZWhhbmQiLCJkZWxldGVSZWN0YW5nbGUiLCJzZXRSZWN0YW5nbGUiLCJoZWxwZXIiLCJFZGl0b3JUZXh0SW5wdXQiLCJFVkVOVF9URVhUX0NIQU5HRSIsIm9uSGVscGVyVGV4dENoYW5nZSIsIm9uSGlzdG9yeUNoYW5nZUJpbmRlZCIsIm9uSGlzdG9yeUNoYW5nZSIsImRlbGV0ZVRleHQiLCJhY2NlcHRBbmRFeGl0IiwiY2xpZW50Rm9udFNpemUiLCJpbml0aWFsV2lkdGgiLCJpbml0aWFsSGVpZ2h0Iiwic2V0QWN0aXZlIiwiZGF0YUJhZyIsInRleHRNYXJrdXAiLCJ0ZXh0U3R5bGUiLCJmaXJzdEVkaXQiLCJzZXRJbmFjdGl2ZSIsInBhcmVudERpdiIsInRleHRBcmVhIiwib25LZXlIYW5kbGVyQmluZGVkIiwib25LZXlIYW5kbGVyIiwic3R5bGVUZXh0QXJlYSIsIm1lYXN1cmVEaXYiLCJvblJlc2l6ZUJpbmRlZCIsIm9uV2luZG93UmVzaXplIiwiaW5pdEZyb21NYXJrdXAiLCJ0eHRBcmVhIiwiZm9jdXMiLCJsaW5lSGVpZ2h0UGVyY2VudGFnZSIsInNldFBvc0FuZFNpemUiLCJ0ZW1wIiwiaW5qZWN0U2l6ZVZhbHVlcyIsImZvbnRIZWlnaHQiLCJ0ZXh0QXJlYVN0eWxlIiwidGV4dFZhbHVlcyIsImdldFRleHRWYWx1ZXMiLCJnZW5lcmF0ZUxpbmVzIiwicGFyc2VGbG9hdCIsInN0ciIsInNoaWZ0RG93biIsImxpbmVzQnJlYWtzIiwic3BsaXQiLCJzdHlsZU1lYXN1cmVTdHIiLCJtYXhMaW5lTGVuZ3RoIiwibGluZXNPdXRwdXQiLCJ0cmltUmlnaHQiLCJzcGxpdExpbmUiLCJtYXhMZW5ndGgiLCJvdXRwdXQiLCJyZW1haW5pbmciLCJkb25lIiwiaW5uZXJIVE1MIiwibGluZUxlbiIsInRyaW1MZWZ0IiwicGFydHMiLCJnZXRTaG9ydGVyTGluZSIsInNwbGl0V29yZCIsImlMYXN0U3BhY2UiLCJsYXN0SW5kZXhPZiIsImNoYXJBdCIsInRyYWlsaW5nV29yZCIsInNob3J0ZXJMaW5lIiwid29yZCIsImxlblNvRmFyIiwiZml0cyIsInBhcnQiLCJva2F5V29yZCIsImV4dHJhV29yZCIsImxhc3ROb25TcGFjZSIsImZpcnN0Tm9uU3BhY2UiXSwibWFwcGluZ3MiOiI7O0FBQUEsQ0FBQyxZQUFVO0FBQUU7O0FBRVQsUUFBSUEsWUFBWUMsa0JBQWtCLGdEQUFsQixDQUFoQjs7QUFFQTs7Ozs7QUFLQUQsY0FBVUUsYUFBVixHQUEwQixVQUFTQyxVQUFULEVBQXFCOztBQUUzQyxZQUFJQyxPQUFPQyxTQUFTQyxPQUFULENBQWlCQyxVQUFqQixDQUE0QkMsT0FBNUIsQ0FBb0NDLElBQS9DO0FBQ0EsZ0JBQVFOLFVBQVI7QUFDSSxpQkFBS0MsS0FBS00sZ0JBQVY7QUFDSSx1QkFBT04sS0FBS08sd0JBQVo7QUFDSixpQkFBS1AsS0FBS1EsaUJBQVY7QUFDSSx1QkFBT1IsS0FBS1Msd0JBQVo7QUFDSixpQkFBS1QsS0FBS1UscUJBQVY7QUFDSSx1QkFBT1YsS0FBS1csNEJBQVo7QUFDSixpQkFBS1gsS0FBS1ksa0JBQVY7QUFDSSx1QkFBT1osS0FBS2EseUJBQVo7QUFDSixpQkFBS2IsS0FBS2MsaUJBQVY7QUFDSSx1QkFBT2QsS0FBS2Usd0JBQVo7QUFDSixpQkFBS2YsS0FBS2dCLG9CQUFWO0FBQ0ksdUJBQU9oQixLQUFLaUIsMkJBQVo7QUFaUjtBQWNBLGVBQU8sYUFBYUMsRUFBYixHQUFrQixHQUF6QjtBQUNILEtBbEJEOztBQW9CQTs7OztBQUlBdEIsY0FBVXVCLGFBQVYsR0FBMEIsWUFBVztBQUNqQztBQUNBO0FBQ0EsWUFBSSxPQUFPQSxhQUFQLEtBQXlCLFVBQXpCLElBQXVDLE9BQU9DLE1BQVAsS0FBa0IsVUFBN0QsRUFBeUU7QUFDckUsbUJBQU9ELGVBQVA7QUFDSDtBQUNELGVB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VixHQUE0QkEsZUFBNUI7QUFFSCxDQWxjRCIsImZpbGUiOiIxNDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrTmFtZXNwYWNlKCdBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzJyk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXJrdXBUeXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgbmFtZXNwYWNlLmdldFR5cGVTdHJpbmcgPSBmdW5jdGlvbihtYXJrdXBUeXBlKSB7XG5cbiAgICAgICAgdmFyIGNvcmUgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgICAgICBzd2l0Y2ggKG1hcmt1cFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZS5NQVJLVVBfVFlQRV9URVhUOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLk1BUktVUF9FWFBPUlRfVFlQRV9MQUJFTDtcbiAgICAgICAgICAgIGNhc2UgY29yZS5NQVJLVVBfVFlQRV9BUlJPVzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5NQVJLVVBfRVhQT1JUX1RZUEVfQVJST1c7XG4gICAgICAgICAgICBjYXNlIGNvcmUuTUFSS1VQX1RZUEVfUkVDVEFOR0xFOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLk1BUktVUF9FWFBPUlRfVFlQRV9SRUNUQU5HTEU7XG4gICAgICAgICAgICBjYXNlIGNvcmUuTUFSS1VQX1RZUEVfQ0lSQ0xFOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLk1BUktVUF9FWFBPUlRfVFlQRV9DSVJDTEU7XG4gICAgICAgICAgICBjYXNlIGNvcmUuTUFSS1VQX1RZUEVfQ0xPVUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuTUFSS1VQX0VYUE9SVF9UWVBFX0NMT1VEO1xuICAgICAgICAgICAgY2FzZSBjb3JlLk1BUktVUF9UWVBFX0ZSRUVIQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLk1BUktVUF9FWFBPUlRfVFlQRV9GUkVFSEFORDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ1Vua25vd24oJyArIGlkICsgJyknO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAvLyBpc1RvdWNoRGV2aWNlIGlzIGFuIExNViBmdW5jdGlvbi4gSGFtbWVyIGlzIGluY2x1ZGVkIGJ5IExNViBhcyB3ZWxsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgbmFtZXNwYWNlLmlzVG91Y2hEZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaXNUb3VjaERldmljZSgpIGlzIGFuIExNViBmdW5jdGlvbi5cbiAgICAgICAgLy8gSGFtbWVyIChhIHRvdWNoIGRldGVjdGlvbiBsaWIpIGlzIHBhY2thZ2VkIHdpdGggTE1WIGFzIHdlbGxcbiAgICAgICAgaWYgKHR5cGVvZiBpc1RvdWNoRGV2aWNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIEhhbW1lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNUb3VjaERldmljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8vLyBTVkcgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIG5hbWVzcGFjZS5jcmVhdGVTdmdFbGVtZW50ID0gZnVuY3Rpb24odHlwZSkge1xuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlRWxlbWVudE5TXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgICAgICB2YXIgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ2luaGVyaXQnKTtcblxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gc3ZnIC0gYW4gU1ZHRWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fSBzdmcgcGFyYW0gaXMgcmV0dXJuZWQgYmFja1xuICAgICAqL1xuICAgIG5hbWVzcGFjZS5zZXRTdmdQYXJlbnRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oc3ZnKSB7XG5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvTmFtZXNwYWNlc19DcmFzaF9Db3Vyc2VcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTsgLy8gTm90aWNlIHRoYXQgdGhpcyBpcyB0aGUgU1ZHIHZlcnNpb24sIG5vdCB0aGUgXCJNQVJLVVAgREFUQSBWRVJTSU9OXCIhXG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2Jhc2VQcm9maWxlJywgJ2Z1bGwnKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW5qZWN0cyBtZXRhZGF0YSBmb3IgdGhlIHdob2xlIE1hcmt1cCBkb2N1bWVudC5cbiAgICAgKiBNZXRhZGF0YSBpbmNsdWRlczogdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHN2ZyAtIGFuIFNWR0VsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgLSBEaWN0aW9uYXJ5IHdpdGggYXR0cmlidXRlc1xuICAgICAqL1xuICAgIG5hbWVzcGFjZS5hZGRTdmdNZXRhZGF0YSA9IGZ1bmN0aW9uKHN2ZyAsbWV0YWRhdGEpIHtcblxuICAgICAgICB2YXIgbWV0YWRhdGFOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdtZXRhZGF0YScpO1xuICAgICAgICB2YXIgZGF0YVZlcnNpb25Ob2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWFya3VwX2RvY3VtZW50Jyk7XG5cbiAgICAgICAgbWV0YWRhdGFOb2RlLmFwcGVuZENoaWxkKGRhdGFWZXJzaW9uTm9kZSk7XG5cbiAgICAgICAgLy8gTk9URTogV2UgY291bGQgaXRlcmF0ZSBvdmVyIHRoZSBwcm9wZXJ0aWVzLCBidXQgd2UgZG9uJ3QgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIG9ubHkgb25lcyBzdXBwb3J0ZWRcbiAgICAgICAgZGF0YVZlcnNpb25Ob2RlLnNldEF0dHJpYnV0ZShcImRhdGEtbW9kZWwtdmVyc2lvblwiLCBtZXRhZGF0YVtcImRhdGEtbW9kZWwtdmVyc2lvblwiXSk7IC8vIFZlcnNpb24uIEZvciBleGFtcGxlOiBcIjFcIlxuXG4gICAgICAgIHN2Zy5pbnNlcnRCZWZvcmUobWV0YWRhdGFOb2RlLCBzdmcuZmlyc3RDaGlsZCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YU5vZGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGluamVjdHMgbWV0YWRhdGEgZm9yIHNwZWNpZmljIG1hcmt1cCBzdmcgbm9kZXMuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBtYXJrdXBOb2RlIC0gYW4gU1ZHRWxlbWVudCBmb3IgdGhlIG1hcmt1cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIERpY3Rpb25hcnkgd2hlcmUgYWxsIGtleS92YWx1ZSBwYWlycyBhcmUgYWRkZWQgYXMgbWV0YWRhdGEgZW50cmllcy5cbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBuYW1lc3BhY2UuYWRkTWFya3VwTWV0YWRhdGEgPSBmdW5jdGlvbihtYXJrdXBOb2RlLCBtZXRhZGF0YSkge1xuXG4gICAgICAgIHZhciBtZXRhZGF0YU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ21ldGFkYXRhJyk7XG4gICAgICAgIHZhciBkYXRhVmVyc2lvbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtYXJrdXBfZWxlbWVudCcpO1xuXG4gICAgICAgIG1ldGFkYXRhTm9kZS5hcHBlbmRDaGlsZChkYXRhVmVyc2lvbk5vZGUpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVZlcnNpb25Ob2RlLnNldEF0dHJpYnV0ZShrZXksIG1ldGFkYXRhW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWFya3VwTm9kZS5pbnNlcnRCZWZvcmUobWV0YWRhdGFOb2RlLCBtYXJrdXBOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGFOb2RlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsIG1ldGFkYXRhIG5vZGVzIGZyb20gYW4gU3ZnIG5vZGUgc3RydWN0dXJlLlxuICAgICAqIE1ldGhvZCB3aWxsIHJlbW92ZSBhbGwgbWV0YWRhdGEgbm9kZXMgZnJvbSBjaGlsZHJlbiBub2RlcyBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSBzdmdOb2RlXG4gICAgICovXG4gICAgbmFtZXNwYWNlLnJlbW92ZUFsbE1ldGFkYXRhID0gZnVuY3Rpb24oc3ZnTm9kZSkge1xuXG4gICAgICAgIHZhciBub2RlcyA9IHN2Z05vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtZXRhZGF0YVwiKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFOb2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBtZXRhZGF0YU5vZGUucGFyZW50Tm9kZSAmJiBtZXRhZGF0YU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtZXRhZGF0YU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhbnN2ZXJzZSBjaGlsZHJlbiBub2Rlc1xuICAgICAgICB2YXIgc3ZnQ2hpbGRyZW4gPSBzdmdOb2RlLmNoaWxkcmVuIHx8IHN2Z05vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChpPTA7IGk8c3ZnQ2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTWV0YWRhdGEoc3ZnQ2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCB0cmFuc2ZlcnMgY2hpbGRyZW4gZnJvbSBhbiBIdG1sL1N2ZyBub2RlIGludG8gYW5vdGhlciBvbmUuXG4gICAgICogQHBhcmFtIG5vZGVGcm9tIC0gVGhlIG5vZGUgaW5zdGFuY2UgZnJvbSB3aGVyZSBjaGlsZHJlbiB3aWxsIGJlIHRha2VuLlxuICAgICAqIEBwYXJhbSBub2RlSW50byAtIFRoZSBub2RlIHRoYXQncyBnb2luZyB0byBwYXJlbnQgdGhlIHRyYW5zZmVycmVkIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIG5hbWVzcGFjZS50cmFuc2ZlckNoaWxkTm9kZXMgPSBmdW5jdGlvbihub2RlRnJvbSwgbm9kZUludG8pIHtcbiAgICAgICAgdmFyIHN2Z0NoaWxkcmVuID0gbm9kZUZyb20uY2hpbGRyZW4gfHwgbm9kZUZyb20uY2hpbGROb2RlcztcbiAgICAgICAgdmFyIHRtcEFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxzdmdDaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0bXBBcnJheS5wdXNoKHN2Z0NoaWxkcmVuW2ldKTsgLy8gQXZvaWQgYXBwZW5kQ2hpbGRcbiAgICAgICAgfVxuICAgICAgICB0bXBBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgICAgbm9kZUludG8uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGFuIFNWRyBub2RlIGludG8gYSBTdHJpbmcuXG4gICAgICogQHBhcmFtIGRvbU5vZGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5zdmdOb2RlVG9TdHJpbmcgPSBmdW5jdGlvbihkb21Ob2RlKXtcblxuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0geG1sU2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhkb21Ob2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybignc3ZnTm9kZVRvU3RyaW5nIGZhaWxlZCB0byBnZW5lcmF0ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZG9tTm9kZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2Uuc3RyaW5nVG9TdmdOb2RlID0gZnVuY3Rpb24oc3RyaW5nTm9kZSl7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgIHZhciBkb2MgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZ05vZGUsIFwidGV4dC94bWxcIik7XG4gICAgICAgICAgICBub2RlID0gZG9jLmZpcnN0Q2hpbGQ7IC8vIFdlIHNob3VsZCBvbmx5IGJlIGdldHRpbmcgMSBjaGlsZCBhbnl3YXkuXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3N0cmluZ1RvU3ZnTm9kZSBmYWlsZWQgdG8gZ2VuZXJhdGUgYW4gSFRNTEVsZW1lbnQgZnJvbSBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIGZ1bmN0aW9ucyBhbmQgbWVtYmVycyB0byBhIGNsaWVudCBvYmplY3Qgd2hpY2ggd2lsbFxuICAgICAqIHJlY2VpdmUgdGhlIGFiaWxpdHkgdG8gZGlzcGF0Y2ggZXZlbnRzLlxuICAgICAqIE1lY2hhbmlzbSBpcyB0aGUgc2FtZSBhcyBpbiBBdXRvZGVzay5WaWV3aW5nLlZpZXdlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IEFsbCBvZiB0aGUgY29kZSBoZXJlIGNvbWVzIGZyb20gQXV0b2Rlc2suVmlld2luZy5WaWV3ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnQgLSBPYmplY3QgdGhhdCB3aWxsIGJlY29tZSBhbiBldmVudCBkaXNwYXRjaGVyLlxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5hZGRUcmFpdEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKGNsaWVudCkge1xuXG4gICAgICAgIC8vIEluamVjdCBtZW1iZXIgdmFyaWFibGVcbiAgICAgICAgY2xpZW50Lmxpc3RlbmVycyA9IHt9O1xuXG4gICAgICAgIC8vIEluamVjdCBmdW5jdGlvbnNcbiAgICAgICAgY2xpZW50LmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgICAgIGNsaWVudC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZihsaXN0ZW5lcikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIGNsaWVudC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1t0eXBlXSBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgICAgICAgICB2YXIgbGkgPSB0aGlzLmxpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTAsIGxlbj1saS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaVtpXSA9PT0gbGlzdGVuZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNsaWVudC5maXJlRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgICAgICBldmVudCA9IHsgdHlwZTogZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0KXtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnR5cGUpe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV2ZW50IHR5cGUgdW5rbm93bi5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVMaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudC50eXBlXS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHR5cGVMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZUxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIEV2ZW50RGlzcGF0Y2hlciB0cmFpdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaWVudFxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5yZW1vdmVUcmFpdEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uKGNsaWVudCkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgY2xpZW50Lmxpc3RlbmVycztcbiAgICAgICAgICAgIGRlbGV0ZSBjbGllbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIGRlbGV0ZSBjbGllbnQuaGFzRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIGRlbGV0ZSBjbGllbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIGRlbGV0ZSBjbGllbnQuZmlyZUV2ZW50O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLyBNYXRoICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBpeGVsIHBvc2l0aW9uIGluIGNsaWVudCBzcGFjZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGluIHdvcmxkIHNwYWNlLlxuICAgICAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gcG9pbnQgUG9pbnQgaW4gd29ybGQgc3BhY2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHZpZXdlclxuICAgICAqIEBwYXJhbSBzbmFwIFJvdW5kIHZhbHVlcyB0byBjbG9zZXN0IHBpeGVsIGNlbnRlci5cbiAgICAgKiBAcmV0dXJucyB7VEhSRUUuVmVjdG9yM30gUG9pbnQgdHJhbnNmb3JtZWQgYW5kIHByb2plY3RlZCBpbnRvIGNsaWVudCBzcGFjZSBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBuYW1lc3BhY2Uud29ybGRUb0NsaWVudCA9IGZ1bmN0aW9uKHBvaW50LCB2aWV3ZXIsIHNuYXApIHtcblxuICAgICAgICB2YXIgcCA9IG5hbWVzcGFjZS53b3JsZFRvVmlld3BvcnQocG9pbnQsIHZpZXdlcik7XG4gICAgICAgIHZhciByZXN1bHQgPSB2aWV3ZXIuaW1wbC52aWV3cG9ydFRvQ2xpZW50KHAueCwgcC55KTtcbiAgICAgICAgcmVzdWx0LnogPSAwO1xuXG4gICAgICAgIC8vIHNuYXAgdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICAgIHJlc3VsdC54ID0gTWF0aC5mbG9vcihyZXN1bHQueCkgKyAwLjU7XG4gICAgICAgICAgICByZXN1bHQueSA9IE1hdGguZmxvb3IocmVzdWx0LnkpICsgMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLmNsaWVudFRvV29ybGQgPSBmdW5jdGlvbihjbGllbnRYLCBjbGllbnRZLCBkZXB0aCwgdmlld2VyKSB7XG5cbiAgICAgICAgdmFyIHBvaW50ID0gdmlld2VyLmltcGwuY2xpZW50VG9WaWV3cG9ydChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgcG9pbnQueiA9IGRlcHRoO1xuXG4gICAgICAgIHBvaW50LnVucHJvamVjdCh2aWV3ZXIuaW1wbC5jYW1lcmEpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIGEgcG9pbnQgaW4gY2xpZW50IHNwYWNlIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIHsgeDpOdW1iZXIsIHk6TnVtYmVyLCB6Ok51bWJlciB9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZpZXdlciAtIExNViBpbnN0YW5jZVxuICAgICAqIEByZXR1cm5zIHtUSFJFRS5WZWN0b3IzfVxuICAgICAqL1xuICAgIG5hbWVzcGFjZS53b3JsZFRvVmlld3BvcnQgPSBmdW5jdGlvbihwb2ludCwgdmlld2VyKSB7XG5cbiAgICAgICAgdmFyIHAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICAgIHAueCA9IHBvaW50Lng7XG4gICAgICAgIHAueSA9IHBvaW50Lnk7XG4gICAgICAgIHAueiA9IHBvaW50Lno7XG5cbiAgICAgICAgcC5wcm9qZWN0KHZpZXdlci5pbXBsLmNhbWVyYSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UubWV0ZXJzVG9Nb2RlbCA9IGZ1bmN0aW9uKG1ldGVycywgdmlld2VyKSB7XG5cbiAgICAgICAgdmFyIG1vZGVsVG9NZXRlciA9IHZpZXdlci5tb2RlbC5nZXRVbml0U2NhbGUoKTtcbiAgICAgICAgdmFyIG1ldGVyVG9Nb2RlbCA9IDEgLyBtb2RlbFRvTWV0ZXI7XG5cbiAgICAgICAgcmV0dXJuIG1ldGVyVG9Nb2RlbCAqIG1ldGVycztcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLnJhZGlhbnNUb0RlZ3JlZXMgPSBmdW5jdGlvbiAocmFkaWFucykge1xuXG4gICAgICAgIHJldHVybiByYWRpYW5zICogKDE4MCAvIE1hdGguUEkpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuZGVncmVlc1RvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblxuICAgICAgICByZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5zaWduID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZSA+PSAwKSA/IDEgOiAtMTtcbiAgICB9O1xuXG4gICAgLy8vLyBMTVYgVmlld2VyIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgTE1WJ3MgY2FtZXJhIGlzIHNldCB0byBPcnRob2dyYXBoaWMuXG4gICAgICogT25seSB3b3JrcyB3aXRoIDNkIG1vZGVsczsgd2lsbCBkbyBub3RoaW5nIHdoZW4gYSAyZCBtb2RlbCBpcyBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZpZXdlciAtIExNViBpbnN0YW5jZVxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5mb3JjZU9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uKHZpZXdlcikge1xuXG4gICAgICAgIGlmKCF2aWV3ZXIgfHwgIXZpZXdlci5uYXZpZ2F0aW9uIHx8IHZpZXdlci5tb2RlbC5pczJkKCkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG5hdkFwaSA9IHZpZXdlci5uYXZpZ2F0aW9uO1xuICAgICAgICB2YXIgY2FtZXJhID0gbmF2QXBpLmdldENhbWVyYSgpO1xuXG4gICAgICAgIGlmIChjYW1lcmEuaXNQZXJzcGVjdGl2ZSkge1xuICAgICAgICAgICAgbmF2QXBpLnRvT3J0aG9ncmFwaGljKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLyBMTVYgdWkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIG5hbWVzcGFjZS5oaWRlTG12VWkgPSBmdW5jdGlvbih2aWV3ZXIpIHtcblxuICAgICAgICAvLyBFeGl0IG90aGVyIHRvb2xzIGFuZCBoaWRlIEh1ZE1lc3NhZ2VzLlxuICAgICAgICB2aWV3ZXIuc2V0QWN0aXZlTmF2aWdhdGlvblRvb2woKTtcblxuICAgICAgICBuYW1lc3BhY2UuZGlzbWlzc0xtdkh1ZE1lc3NhZ2UoKTtcbiAgICAgICAgbmFtZXNwYWNlLmhpZGVMbXZQYW5lbHModHJ1ZSwgdmlld2VyKTtcbiAgICAgICAgbmFtZXNwYWNlLmhpZGVMbXZUb29sc0FuZFBhbmVscyh2aWV3ZXIpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UucmVzdG9yZUxtdlVpID0gZnVuY3Rpb24odmlld2VyKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLmRpc21pc3NMbXZIdWRNZXNzYWdlKCk7XG4gICAgICAgIG5hbWVzcGFjZS5oaWRlTG12UGFuZWxzKGZhbHNlLCB2aWV3ZXIpO1xuICAgICAgICBuYW1lc3BhY2Uuc2hvd0xtdlRvb2xzQW5kUGFuZWxzKHZpZXdlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGhpZGVcbiAgICAgKiBAcGFyYW0gdmlld2VyXG4gICAgICovXG4gICAgbmFtZXNwYWNlLmhpZGVMbXZQYW5lbHMgPSBmdW5jdGlvbihoaWRlLCB2aWV3ZXIpIHtcblxuICAgICAgICB2YXIgZG9ja2luZ1BhbmVscyA9IHZpZXdlci5kb2NraW5nUGFuZWxzO1xuXG4gICAgICAgIC8vIFBhbmVscyBtYXkgbm90IGJlIHByZXNlbnQgd2hlbiBkZWFsaW5nIHdpdGggYW4gaW5zdGFuY2Ugb2YgVmlld2VyM0QuanNcbiAgICAgICAgLy8gKGFzIG9wcG9zZWQgdG8gYW4gaW5zdGFuY2Ugb2YgR3VpVmlld2VyM0QuanMpXG4gICAgICAgIGlmICghZG9ja2luZ1BhbmVscykgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9ja2luZ1BhbmVscy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICB2YXIgcGFuZWwgPSBkb2NraW5nUGFuZWxzW2ldO1xuICAgICAgICAgICAgdmFyIHBhbmVsQ29udGFpbmVyID0gcGFuZWwuY29udGFpbmVyO1xuXG4gICAgICAgICAgICBpZiAocGFuZWxDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZG9ja2luZ1BhbmVsVmlzaWJsZVwiKSkge1xuICAgICAgICAgICAgICAgIHBhbmVsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBoaWRlID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSB2aXNpYmlsaXR5IGNoYW5nZWQgbm90aWZpY2F0aW9uIGlmIGFueSBhZGRpdGlvbmFsXG4gICAgICAgICAgICAgICAgLy8gc3R1ZmYgbmVlZHMgdG8gYmUgZG9uZSAodXBkYXRlIHRoZSBkYXRlIGkuZS4gUHJvcGVydHlQYW5lbCwgZXRjKS5cbiAgICAgICAgICAgICAgICBwYW5lbC52aXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3dzIHBhbmVscyBhbmQgdG9vbHMgaW4gdGhlIHZpZXdlci5cbiAgICAgKiBAcGFyYW0gdmlld2VyXG4gICAgICovXG4gICAgbmFtZXNwYWNlLnNob3dMbXZUb29sc0FuZFBhbmVscyA9IGZ1bmN0aW9uKHZpZXdlcikge1xuXG4gICAgICAgIC8vIFJlc3RvcmUgdmlldyBjdWJlLlxuICAgICAgICBpZighdmlld2VyLm1vZGVsLmlzMmQoKSkge1xuICAgICAgICAgICAgdmlld2VyLmRpc3BsYXlWaWV3Q3ViZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBGaW5kIG9yIGFzayBmb3IgYSBiZXR0ZXIgd2F5IHRvIHJlc3RvcmUgdGhpcyBidXR0b25zLlxuICAgICAgICAvLyBIaWRlIGhvbWUgYW5kIGluZm8gYnV0dG9uLlxuICAgICAgICB2YXIgaG9tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hvbWVWaWV3V3JhcHBlcicpO1xuICAgICAgICB2YXIgaW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2luZm9CdXR0b24nKTtcbiAgICAgICAgdmFyIGFuaW0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0b29sYmFyLWFuaW1hdGlvblN1YnRvb2xiYXInKTtcblxuICAgICAgICBpZiAoaG9tZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBob21lWzBdLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmZvLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZm9bMF0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuaW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYW5pbVswXS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b29sYmFyIGlzIGFic2VudCB3aGVuIGRlYWxpbmcgd2l0aCBhbiBpbnN0YW5jZSBvZiBWaWV3ZXIzRCAoaW5zdGVhZCBvZiBHdWlWaWV3ZXIzRClcbiAgICAgICAgaWYgKHZpZXdlci50b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgdmlld2VyQ29udGFpbmVyID0gdmlld2VyLnRvb2xiYXIuY29udGFpbmVyO1xuICAgICAgICAgICAgdmFyIHZpZXdlckNvbnRhaW5lckNoaWxkcmVuQ291bnQgPSB2aWV3ZXJDb250YWluZXIuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZpZXdlckNvbnRhaW5lckNoaWxkcmVuQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdlckNvbnRhaW5lci5jaGlsZHJlbltpXS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyBwYW5lbHMgYW5kIHRvb2xzIGluIHRoZSB2aWV3ZXIuXG4gICAgICogQHBhcmFtIHZpZXdlclxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5oaWRlTG12VG9vbHNBbmRQYW5lbHMgPSBmdW5jdGlvbih2aWV3ZXIpIHtcblxuICAgICAgICAvLyBIaWRlIFBhbmVscyBhbmQgdG9vbHMuXG4gICAgICAgIGlmICh2aWV3ZXIgJiYgdmlld2VyLm1vZGVsICYmICF2aWV3ZXIubW9kZWwuaXMyZCgpKSB7XG4gICAgICAgICAgICB2aWV3ZXIuZGlzcGxheVZpZXdDdWJlKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBGaW5kIG9yIGFzayBmb3IgYSBiZXR0ZXIgd2F5IHRvIGhpZGUgdGhpcyBidXR0b25zLlxuICAgICAgICAvLyBIaWRlIGhvbWUgYW5kIGluZm8gYnV0dG9uLlxuICAgICAgICB2YXIgaG9tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hvbWVWaWV3V3JhcHBlcicpO1xuICAgICAgICB2YXIgaW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2luZm9CdXR0b24nKTtcbiAgICAgICAgdmFyIGFuaW0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0b29sYmFyLWFuaW1hdGlvblN1YnRvb2xiYXInKTtcblxuICAgICAgICBpZiAoaG9tZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBob21lWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmZvWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhbmltWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgIHZhciBhbmltYXRvciA9IHZpZXdlci5pbXBsLmtleUZyYW1lQW5pbWF0b3I7XG4gICAgICAgICAgICBpZiAoYW5pbWF0b3IgJiYgIWFuaW1hdG9yLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3IucGF1c2VDYW1lcmFBbmltYXRpb25zKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3IucGF1c2UoKTtcblxuICAgICAgICAgICAgICAgIHZhciBwbGF5QnV0dG9uID0gdmlld2VyLm1vZGVsVG9vbHMuZ2V0Q29udHJvbCgndG9vbGJhci1hbmltYXRpb25QbGF5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHBsYXlCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheUJ1dHRvbi5zZXRJY29uKCd0b29sYmFyLWFuaW1hdGlvblBhdXNlSWNvbicpO1xuICAgICAgICAgICAgICAgICAgICBwbGF5QnV0dG9uLnNldFRvb2xUaXAoJ1BhdXNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9vbGJhciBpcyBhYnNlbnQgd2hlbiBkZWFsaW5nIHdpdGggYW4gaW5zdGFuY2Ugb2YgVmlld2VyM0QgKGluc3RlYWQgb2YgR3VpVmlld2VyM0QpXG4gICAgICAgIGlmICh2aWV3ZXIudG9vbGJhcikge1xuICAgICAgICAgICAgdmFyIHZpZXdlckNvbnRhaW5lciA9IHZpZXdlci50b29sYmFyLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHZhciB2aWV3ZXJDb250YWluZXJDaGlsZHJlbkNvdW50ID0gdmlld2VyQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2aWV3ZXJDb250YWluZXJDaGlsZHJlbkNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2aWV3ZXJDb250YWluZXIuY2hpbGRyZW5baV0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc21pc3NlcyBhbGwgTE1WIEh1ZE1lc3NhZ2VzXG4gICAgICovXG4gICAgbmFtZXNwYWNlLmRpc21pc3NMbXZIdWRNZXNzYWdlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gVXNpbmcgdHJ5L2NhdGNoIGJsb2NrIHNpbmNlIHdlIGFyZSBhY2Nlc3NpbmcgdGhlIFByaXZhdGUgbmFtZXNwYWNlIG9mIExNVi5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBrZWVwRGlzbWlzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoa2VlcERpc21pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBrZWVwRGlzbWlzc2luZyA9IEF1dG9kZXNrLlZpZXdpbmcuUHJpdmF0ZS5IdWRNZXNzYWdlLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgICAgICAvLyBGYWlsaW5nIHRvIHNob3cgdGhlIG1lc3NhZ2UgaXMgYW4gb2theSBmYWxsYmFjayBzY2VuYXJpb1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0NPMl1GYWlsZWQgdG8gZGlzbWlzcyBMTVYgSHVkTWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLy8vIFN0eWxlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgbmFtZXNwYWNlLmNyZWF0ZVN0eWxlID0gZnVuY3Rpb24oYXR0cmlidXRlcywgdmlld2VyKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlID0ge307XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgc3R5bGVbYXR0cmlidXRlc1tpXV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzID0gbmFtZXNwYWNlLmdldFN0eWxlRGVmYXVsdFZhbHVlcyhzdHlsZSwgdmlld2VyKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgIHN0eWxlW2F0dHJpYnV0ZV0gPSBkZWZhdWx0c1thdHRyaWJ1dGVdLnZhbHVlc1tkZWZhdWx0c1thdHRyaWJ1dGVdLmRlZmF1bHRdLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBuYW1lc3BhY2UuY29weVN0eWxlID0gZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuXG4gICAgICAgIGZvcih2YXIgYXR0cmlidXRlIGluIGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblthdHRyaWJ1dGVdID0gc291cmNlW2F0dHJpYnV0ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICAgIG5hbWVzcGFjZS5jbG9uZVN0eWxlID0gZnVuY3Rpb24oc291cmNlKSB7XG5cbiAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgZm9yKHZhciBhdHRyaWJ1dGUgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBjbG9uZVthdHRyaWJ1dGVdID0gc291cmNlW2F0dHJpYnV0ZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0eWxlXG4gICAgICogQHBhcmFtIHZpZXdlclxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cbiAgICBuYW1lc3BhY2UuZ2V0U3R5bGVEZWZhdWx0VmFsdWVzID0gZnVuY3Rpb24oc3R5bGUsIHZpZXdlcikge1xuXG4gICAgICAgICBmdW5jdGlvbiBnZXRTdHJva2VXaWR0aCh2aWV3ZXIpIHtcblxuICAgICAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmlld2VyLm1vZGVsLmdldERhdGEoKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEuaXMyZCkge1xuICAgICAgICAgICAgICAgIHdpZHRoID0gbmFtZXNwYWNlLm1ldGVyc1RvTW9kZWwoMC4wMjU0LCB2aWV3ZXIpICogMjsgLy8gMC4wMjU0IG0gPT0gMSBpbmNoXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB2aWV3ZXIuaW1wbC52aWV3cG9ydFRvQ2xpZW50KDAuMDAsIDAuMDApO1xuICAgICAgICAgICAgICAgIHZhciBiID0gdmlld2VyLmltcGwudmlld3BvcnRUb0NsaWVudCgwLjAxLCAwLjAxKTtcblxuICAgICAgICAgICAgICAgIGEgPSBuYW1lc3BhY2UuY2xpZW50VG9Xb3JsZChhLngsIGEueSwgMCwgdmlld2VyKTtcbiAgICAgICAgICAgICAgICBiID0gbmFtZXNwYWNlLmNsaWVudFRvV29ybGQoYi54LCBiLnksIDAsIHZpZXdlcik7XG5cbiAgICAgICAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKGIueSAtIGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRXaWR0aHMoc21hbGxXaWR0aCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTonVGhpbicsIHZhbHVlOiBzbWFsbFdpZHRofSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J05vcm1hbCcsIHZhbHVlOiBzbWFsbFdpZHRoICogIDN9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonVGhpY2snLCB2YWx1ZTogc21hbGxXaWR0aCAqICA5fV0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZvbnRTaXplcyhzbWFsbFdpZHRoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidUaGluJywgdmFsdWU6IHNtYWxsV2lkdGggKiAgNX0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidOb3JtYWwnLCB2YWx1ZTogc21hbGxXaWR0aCAqICAxMH0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidUaGljaycsIHZhbHVlOiBzbWFsbFdpZHRoICogIDIwfV0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvbG9ycygpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J3JlZCcsIHZhbHVlOiAnI2ZmMDAwMCd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonZ3JlZW4nLCB2YWx1ZTogJyMwMGZmMDAnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J2JsdWUnLCB2YWx1ZTogJyMwMDAwZmYnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J3doaXRlJywgdmFsdWU6ICcjZmZmZmZmJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidibGFjaycsIHZhbHVlOiAnIzAwMDAwMCd9XSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T3BhY2l0aWVzKGRlZmF1bHRUcmFuc3BhcmVudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTonMTAwJScsIHZhbHVlOiAxLjAwfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6Jzc1JScsIHZhbHVlOiAgMC43NX0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOic1MCUnLCB2YWx1ZTogMC41MH0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOicyNSUnLCB2YWx1ZTogMC4yNX0sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOicwJScsIHZhbHVlOiAwLjAwfV0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogKGRlZmF1bHRUcmFuc3BhcmVudCA/IDQgOiAwKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZvbnRGYW1pbGllcygpIHtcblxuICAgICAgICAgICAgLy8gVE9ETzogTG9jYWxpemU/XG4gICAgICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSBmb250cyB3aXRoIGRlc2lnblxuICAgICAgICAgICAgLy8gU291cmNlOiBodHRwOi8vd3d3LndlYmRlc2lnbmRldi5jb20vd2ViLWRldmVsb3BtZW50LzE2LWdvcmdlb3VzLXdlYi1zYWZlLWZvbnRzLXRvLXVzZS13aXRoLWNzc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6W1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTonQXJpYWwnLCB2YWx1ZTogJ0FyaWFsJ30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidBcmlhbCBCbGFjaycsIHZhbHVlOiAnQXJpYWwgQmxhY2snfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J0FyaWFsIE5hcnJvdycsIHZhbHVlOiAnQXJpYWwgTmFycm93J30sXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidDZW50dXJ5IEdvdGhpYycsIHZhbHVlOiAnQ2VudHVyeSBHb3RoaWMnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J0NvdXJpZXIgTmV3JywgdmFsdWU6ICdDb3VyaWVyIE5ldyd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonR2VvcmdpYScsIHZhbHVlOiAnR2VvcmdpYSd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonSW1wYWN0JywgdmFsdWU6ICdJbXBhY3QnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J0x1Y2lkYSBDb25zb2xlJywgdmFsdWU6ICdMdWNpZGEgQ29uc29sZSd9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonVGFob21hJywgdmFsdWU6ICdUYWhvbWEnfSxcbiAgICAgICAgICAgICAgICAgICAge25hbWU6J1ZlcmRhbmEnLCB2YWx1ZTogJ1ZlcmRhbmEnfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldEZvbnRTdHlsZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlczpbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidOb3JtYWwnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonSXRhbGljJywgdmFsdWU6IHRydWV9XSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0Rm9udFdlaWdodHMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlczpbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOidOb3JtYWwnLCB2YWx1ZTogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgICB7bmFtZTonQm9sZCcsIHZhbHVlOiB0cnVlfV0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVzID0gbmFtZXNwYWNlLmNsb25lU3R5bGUoc3R5bGUpO1xuICAgICAgICB2YXIgc21hbGxXaWR0aCA9IGdldFN0cm9rZVdpZHRoKHZpZXdlcik7XG5cbiAgICAgICAgZm9yKHZhciBhdHRyaWJ1dGUgaW4gdmFsdWVzKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJva2Utd2lkdGgnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IGdldFdpZHRocyhzbWFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmb250LXNpemUnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IGdldEZvbnRTaXplcyhzbWFsbFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdmb250LWZhbWlseSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gZ2V0Rm9udEZhbWlsaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udC1zdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gZ2V0Rm9udFN0eWxlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvbnQtd2VpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2F0dHJpYnV0ZV0gPSBnZXRGb250V2VpZ2h0cygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1jb2xvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbC1jb2xvcic6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gZ2V0Q29sb3JzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1vcGFjaXR5JzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IGdldE9wYWNpdGllcyhkZWZhdWx0VHJhbnNwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGwtb3BhY2l0eSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IGdldE9wYWNpdGllcyhkZWZhdWx0VHJhbnNwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLmNvbXBvc2VSR0JBU3RyaW5nID0gZnVuY3Rpb24oaGV4UkdCU3RyaW5nLCBvcGFjaXR5KSB7XG5cbiAgICAgICAgaWYgKG9wYWNpdHkgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZ2JhID0gWydyZ2JhKCcgK1xuICAgICAgICAgICAgcGFyc2VJbnQoJzB4JyArIGhleFJHQlN0cmluZy5zdWJzdHIoMSwyKSksICcsJyxcbiAgICAgICAgICAgIHBhcnNlSW50KCcweCcgKyBoZXhSR0JTdHJpbmcuc3Vic3RyKDMsMikpLCAnLCcsXG4gICAgICAgICAgICBwYXJzZUludCgnMHgnICsgaGV4UkdCU3RyaW5nLnN1YnN0cig1LDIpKSwgJywnLCBvcGFjaXR5LCAnKSddLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgQXV0b2Rlc2tOYW1lc3BhY2UoJ0F1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUnKTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEJhc2UgY2xhc3MgZm9yIGFsbCBFZGl0QWN0aW9ucy48YnI+XG4gICAgICogRWRpdEFjdGlvbnMgZW5jYXBzdWxhdGUge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwICBNYXJrdXB9XG4gICAgICogb3BlcmF0aW9ucyAoc3VjaCBhcyBjcmVhdGlvbiwgZWRpdGlvbiBhbmQgZGVsZXRpb24pIHRoYXQgaG9vayBpbnRvIHRoZSB1bmRvL3JlZG8gc3lzdGVtLlxuICAgICAqXG4gICAgICogVGhlIG1pbmltdW0gc2V0IG9mIG1ldGhvZHMgdG8gaW1wbGVtZW50IG9uIGFuIEVkaXRBY3Rpb24gZXh0ZW5zaW9uIGFyZTpcbiAgICAgKiAtIGV4ZWN1dGUoKVxuICAgICAqIC0gdW5kbygpXG4gICAgICogLSByZWRvKClcbiAgICAgKlxuICAgICAqIEEgZ29vZCBzZXQgb2YgY2xhc3NlcyB0byBjaGVjayB0aGVpciBpbXBsZW1lbnRhdGlvbiBhcmU6XG4gICAgICogLSBbQ3JlYXRlQ2lyY2xlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkNyZWF0ZUNpcmNsZX0uXG4gICAgICogLSBbRGVsZXRlQ2lyY2xlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkRlbGV0ZUNpcmNsZX0uXG4gICAgICogLSBbU2V0Q2lyY2xlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlNldENpcmNsZX0uXG4gICAgICpcbiAgICAgKiBAdHV0b3JpYWwgZmVhdHVyZV9tYXJrdXBcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlfSBlZGl0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIEFuIGlkZW50aWZpZXIgZm9yIHRoZSBFZGl0QWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRJZCAtIFRoZSBpZCBvZiB0aGUgbWFya3VwIGJlaW5nIGFmZmVjdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVkaXRBY3Rpb24oZWRpdG9yLCB0eXBlLCB0YXJnZXRJZCkge1xuXG4gICAgICAgIHRoaXMudHlwZSA9ICB0eXBlO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xuICAgICAgICB0aGlzLmFkZFRvSGlzdG9yeSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0T25FeGVjdXRpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuRWRpdEFjdGlvbiA9IEVkaXRBY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgYWN0aW9uLlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuRWRpdEFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZWRpdG9yLmFjdGlvbk1hbmFnZXIuZXhlY3V0ZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9uLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9uLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gbWVyZ2UgY29uc2VjdXRpdmUgYWN0aW9ucyBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9ufSBhY3Rpb24gLSBBY3Rpb24gdG8gY2hlY2sgaWYgaXQgY2FuIGJlIG1lcmdlZCB3aXRoICd0aGlzJy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1lcmdlIGhhcyBiZWVuIGFwcGxpZWQuIFBhcmFtZXRlciB3aWxsIGJlIGRpc2NhcmRlZC5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRBY3Rpb24ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIG1lY2hhbmlzbSB0byBjaGVjayB3aGV0aGVyIHRoZSBhY3Rpb24geWllbGRzIG5vIHJlc3VsdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBubyBjaGFuZ2VzIGhhcHBlbiB3aXRoIHRoaXMgYWN0aW9uLlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuRWRpdEFjdGlvbi5wcm90b3R5cGUuaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG59KSgpO1xyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGhpc3RvcnlTaXplXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWRpdEFjdGlvbk1hbmFnZXIoaGlzdG9yeVNpemUpIHtcblxuICAgICAgICB0aGlzLmhpc3RvcnlTaXplID0gaGlzdG9yeVNpemU7XG5cbiAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBuZXcgQXJyYXkoaGlzdG9yeVNpemUpO1xuICAgICAgICB0aGlzLnJlZG9TdGFjayA9IG5ldyBBcnJheShoaXN0b3J5U2l6ZSk7XG5cbiAgICAgICAgbmFtZXNwYWNlVXRpbHMuYWRkVHJhaXRFdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBFdmVudCB0eXBlc1xuICAgICAqL1xuICAgIG5hbWVzcGFjZS5FVkVOVF9ISVNUT1JZX0NIQU5HRUQgPSBcIkVWRU5UX0hJU1RPUllfQ0hBTkdFRFwiO1xuXG4gICAgdmFyIHByb3RvID0gRWRpdEFjdGlvbk1hbmFnZXIucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uXG4gICAgICovXG4gICAgcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgICAgIHZhciByZWRvU3RhY2sgPSB0aGlzLnJlZG9TdGFjaztcbiAgICAgICAgdmFyIHVuZG9TdGFjayA9IHRoaXMudW5kb1N0YWNrO1xuXG4gICAgICAgIHJlZG9TdGFjay5zcGxpY2UoMCwgcmVkb1N0YWNrLmxlbmd0aCk7XG5cbiAgICAgICAgYWN0aW9uLnJlZG8oKTtcblxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldEVkaXRBY3Rpb25Hcm91cCgpO1xuICAgICAgICBpZiAoZ3JvdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAgIGdyb3VwLmFkZEFjdGlvbihhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXAub3BlbigpO1xuICAgICAgICAgICAgZ3JvdXAuYWRkQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICBncm91cC5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZG9TdGFjay5sZW5ndGggPiB0aGlzLmhpc3RvcnlTaXplKSB7XG4gICAgICAgICAgICB1bmRvU3RhY2suc3BsaWNlKDAsMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0SWQgPSBhY3Rpb24uc2VsZWN0T25FeGVjdXRpb24gPyBhY3Rpb24udGFyZ2V0SWQgOiAtMTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoXG4gICAgICAgICAgICB7dHlwZTogbmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgZGF0YToge2FjdGlvbjogJ2V4ZWN1dGUnLCB0YXJnZXRJZDogdGFyZ2V0SWR9fSk7XG4gICAgfTtcblxuICAgIHByb3RvLmJlZ2luQWN0aW9uR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdW5kb1N0YWNrID0gdGhpcy51bmRvU3RhY2s7XG4gICAgICAgIHZhciB1bmRvU3RhY2tDb3VudCA9IHVuZG9TdGFjay5sZW5ndGg7XG4gICAgICAgIHZhciBncm91cCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHVuZG9TdGFja0NvdW50ID09PSAwIHx8IHVuZG9TdGFja1t1bmRvU3RhY2tDb3VudC0xXS5pc0Nsb3NlZCgpKSB7XG5cbiAgICAgICAgICAgIGdyb3VwID0gdGhpcy5nZXRFZGl0QWN0aW9uR3JvdXAoKTtcbiAgICAgICAgICAgIGdyb3VwLm9wZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFya3VwcyAtIFVuZG8vUmVkbyAtIEFjdGlvbiBlZGl0IGdyb3VwIGFscmVhZHkgb3Blbi4nKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5jbG9zZUFjdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHVuZG9TdGFjayA9IHRoaXMudW5kb1N0YWNrO1xuICAgICAgICB2YXIgdW5kb1N0YWNrQ291bnQgPSB1bmRvU3RhY2subGVuZ3RoO1xuXG4gICAgICAgIGlmICh1bmRvU3RhY2tDb3VudCA9PT0gMCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01hcmt1cHMgLSBVbmRvL1JlZG8gLSBUaGVyZSBpcyBubyBhY3Rpb24gZWRpdCBncm91cCB0byBjbG9zZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cCA9IHVuZG9TdGFja1t1bmRvU3RhY2tDb3VudC0xXTtcbiAgICAgICAgaWYoIWdyb3VwLmNsb3NlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFya3VwcyAtIFVuZG8vUmVkbyAtIEFjdGlvbiBlZGl0IGdyb3VwIGFscmVhZHkgY2xvc2VkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyb3VwLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdW5kb1N0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RvLmNhbmNlbEFjdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHVuZG9TdGFjayA9IHRoaXMudW5kb1N0YWNrO1xuICAgICAgICB2YXIgdW5kb1N0YWNrQ291bnQgPSB1bmRvU3RhY2subGVuZ3RoO1xuXG4gICAgICAgIGlmICh1bmRvU3RhY2tDb3VudCA9PT0gMCkge1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01hcmt1cHMgLSBVbmRvL1JlZG8gLSBUaGVyZSBpcyBubyBhY3Rpb24gZWRpdCBncm91cCB0byBjbG9zZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cCA9IHVuZG9TdGFja1t1bmRvU3RhY2tDb3VudC0xXTtcbiAgICAgICAgaWYoIWdyb3VwLmNsb3NlKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTWFya3VwcyAtIFVuZG8vUmVkbyAtIEFjdGlvbiBlZGl0IGdyb3VwIGFscmVhZHkgY2xvc2VkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXAudW5kbygpO1xuICAgICAgICB1bmRvU3RhY2sucG9wKCk7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoXG4gICAgICAgICAgICB7dHlwZTogbmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgZGF0YToge2FjdGlvbjogJ2NhbmNlbCcsIHRhcmdldElkOiAtMX19KTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB1bmRvU3RhY2sgPSB0aGlzLnVuZG9TdGFjaztcbiAgICAgICAgdmFyIHJlZG9TdGFjayA9IHRoaXMucmVkb1N0YWNrO1xuXG4gICAgICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXAgPSB1bmRvU3RhY2sucG9wKCk7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9IGdyb3VwLnVuZG8oKTtcblxuICAgICAgICByZWRvU3RhY2sucHVzaChncm91cCk7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoXG4gICAgICAgICAgICB7dHlwZTogbmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgZGF0YToge2FjdGlvbjondW5kbycsIHRhcmdldElkOiB0YXJnZXRJZH19KTtcbiAgICB9O1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB1bmRvU3RhY2sgPSB0aGlzLnVuZG9TdGFjaztcbiAgICAgICAgdmFyIHJlZG9TdGFjayA9IHRoaXMucmVkb1N0YWNrO1xuXG4gICAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXAgPSByZWRvU3RhY2sucG9wKCk7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9IGdyb3VwLnJlZG8oKTtcblxuICAgICAgICB1bmRvU3RhY2sucHVzaChncm91cCk7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoXG4gICAgICAgICAgICB7dHlwZTogbmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgZGF0YToge2FjdGlvbjoncmVkbycsIHRhcmdldElkOiB0YXJnZXRJZH19KTtcbiAgICB9O1xuXG4gICAgcHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnVuZG9TdGFjay5zcGxpY2UoMCwgdGhpcy51bmRvU3RhY2subGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWRvU3RhY2suc3BsaWNlKDAsIHRoaXMucmVkb1N0YWNrLmxlbmd0aCk7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoXG4gICAgICAgICAgICB7dHlwZTogbmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgZGF0YToge2FjdGlvbjonY2xlYXInLCB0YXJnZXRJZDogLTF9fSk7XG4gICAgfTtcblxuICAgIHByb3RvLmlzVW5kb1N0YWNrRW1wdHkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy51bmRvU3RhY2subGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBwcm90by5pc1JlZG9TdGFja0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVkb1N0YWNrLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uZ2V0RWRpdEFjdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHVuZG9TdGFjayA9IHRoaXMudW5kb1N0YWNrO1xuICAgICAgICB2YXIgdW5kb1N0YWNrQ291bnQgPSB0aGlzLnVuZG9TdGFjay5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbnVsbDtcblxuICAgICAgICBpZiAodW5kb1N0YWNrQ291bnQgPT09IDAgfHwgdW5kb1N0YWNrW3VuZG9TdGFja0NvdW50LTFdLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIGdyb3VwID0gbmV3IG5hbWVzcGFjZS5FZGl0QWN0aW9uR3JvdXAoKTtcbiAgICAgICAgICAgIHVuZG9TdGFjay5wdXNoKGdyb3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwID0gdW5kb1N0YWNrW3VuZG9TdGFja0NvdW50LTFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbk1hbmFnZXIgPSBFZGl0QWN0aW9uTWFuYWdlcjtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyaW5nIG9iamVjdCB3aGljaCBnZW5lcmF0ZSBhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICogYXMgYSBEb20gZWxlbWVudCdzICdzdHlsZScgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEb21FbGVtZW50U3R5bGUoKSB7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29uc3RhbnRzXG4gICAgICovXG4gICAgdmFyIEJST1dTRVJfUFJFRklYRVMgPSBbJy1tcy0nLCAnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJ107XG5cbiAgICB2YXIgcHJvdG8gPSBEb21FbGVtZW50U3R5bGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVzZXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0eWxlU3RyaW5nID0gJyc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxCcm93c2Vyc10gLSBXaGV0aGVyIHRvIGFkZCBicm93c2VyIHByZWZpeCB0byBrZXlcbiAgICAgKiBAcmV0dXJucyB7QXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscy5Eb21lRWxlbVN0eWxlfVxuICAgICAqL1xuICAgIHByb3RvLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsQnJvd3NlcnMpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIEJST1dTRVJfUFJFRklYRVMuZm9yRWFjaChmdW5jdGlvbihwcmVmaXgpe1xuICAgICAgICAgICAgICAgIHRoYXQuYXR0cmlidXRlc1socHJlZml4K2tleSldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTsgLy8gQ291bGQgYmUgb3B0aW1pemVkXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5IC0gS2V5IG9yIEtleXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEByZXR1cm5zIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzLkRvbUVsZW1TdHlsZX0gdGhpc1xuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGtleSkge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAga2V5LmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgaWYgKGsgaW4gc2VsZi5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuYXR0cmlidXRlc1trXTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzdHlsZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHByb3RvLmdldFN0eWxlU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVTdHJpbmcgPSBnZW5lcmF0ZVN0eWxlKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVTdHJpbmc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgY3VycmVudCBPYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzLkRvbUVsZW1TdHlsZX1cbiAgICAgKi9cbiAgICBwcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbG9uZSA9IG5ldyBuYW1lc3BhY2UuRG9tRWxlbWVudFN0eWxlKCk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBzdHlsZSB2YWx1ZSBzdHJpbmcuIE5vbiBtdXRhYmxlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3R5bGUoYXR0cmlidXRlcykge1xuXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJzonKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godmFsKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goJzsgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIG5hbWVzcGFjZS5Eb21FbGVtZW50U3R5bGUgPSBEb21FbGVtZW50U3R5bGU7XG5cbn0pKCk7XG5cclxuIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqIEEgY29tcG9uZW50IHRvIGhhbmRsZSB0aGUgc2VsZWN0aW9uIG9mIG1hcmt1cHMuXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICAgU2FtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIHZhciBjb250YWluaW5nRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5pbmdEaXYzZC1hcHAtd3JhcHBlcicpO1xuICAgICAqICAgICAgdmFyIHNlbGVjdGlvbkNvbXBvbmVudCA9IG5ldyBFZGl0RnJhbWUoY29udGFpbmluZ0Rpdik7XG4gICAgICogICAgICBzZWxlY3Rpb25Db21wb25lbnQuc2V0U2VsZWN0aW9uKDEwMCwgMTAwLCAzMDAsIDE1MCwgMCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluaW5nRGl2IFRoZSBjb250YWluZXIgd2hlcmUgdGhlIHNlbGVjdGlvbiBsYXllciB3aWxsIGxpdmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVkaXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVkaXRGcmFtZShjb250YWluaW5nRGl2LCBlZGl0b3IpIHtcblxuICAgICAgICB0aGlzLmNvbnRhaW5pbmdEaXYgPSBjb250YWluaW5nRGl2O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllciA9IGNyZWF0ZVNlbGVjdGlvbkxheWVyKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgcm90YXRpb246IDAsXG4gICAgICAgICAgICBlbGVtZW50OiBudWxsLFxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIC8vYSBkaWN0aW9uYXJ5IG9mIGFsbCB0aGUgZHJhZyBwb2ludHNcbiAgICAgICAgICAgIC8vdGhlIGtleSBmb3IgZWFjaCBkcmFnIHBvaW50IHdpbGwgYmUgaXRzIGNhcmRpbmFsL29yZGluYWwgZGlyZWN0aW9uXG4gICAgICAgICAgICBoYW5kbGU6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgY3JlYXRlU2VsZWN0b3JCb3guYmluZCh0aGlzKSgpO1xuXG4gICAgICAgIGlmIChuYW1lc3BhY2VVdGlscy5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMub25IYW1tZXJEcmFnQmluZGVkID0gdGhpcy5vbkhhbW1lckRyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKHRoaXMuc2VsZWN0aW9uTGF5ZXIsIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyczogW1xuICAgICAgICAgICAgICAgICAgICBbSGFtbWVyLlBhbiwgeyBldmVudDogJ2RyYWcnLCBwb2ludGVyczogMSB9IF1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGlucHV0Q2xhc3M6IEhhbW1lci5Ub3VjaElucHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVTZWxlY3Rpb25Cb3hEcmFnZ2luZy5iaW5kKHRoaXMpKCk7XG4gICAgICAgIGhhbmRsZVNlbGVjdGlvbkJveFJlc2l6aW5nLmJpbmQodGhpcykoKTtcbiAgICAgICAgaGFuZGxlU2VsZWN0aW9uRG91YmxlQ2xpY2suYmluZCh0aGlzKSgpO1xuICAgICAgICBoYW5kbGVTZWxlY3Rpb25Cb3hSb3RhdGluZy5iaW5kKHRoaXMpKCk7XG5cbiAgICAgICAgLy9hZGQgdGhlIHNlbGVjdGlvbiBpbnRvIHRoZSBjb250YWluZXIgZ2l2ZW4gdG8gdXNcbiAgICAgICAgdGhpcy5jb250YWluaW5nRGl2LmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uTGF5ZXIpO1xuXG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLmFkZFRyYWl0RXZlbnREaXNwYXRjaGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIENvbnN0YW50cyAvL1xuICAgIG5hbWVzcGFjZS5FVkVOVF9FRElURlJBTUVfRURJVElPTl9TVEFSVCA9IFwiRVZFTlRfRURJVEZSQU1FX0VESVRJT05fU1RBUlRcIjtcbiAgICBuYW1lc3BhY2UuRVZFTlRfRURJVEZSQU1FX0VESVRJT05fRU5EID0gXCJFVkVOVF9FRElURlJBTUVfRURJVElPTl9FTkRcIjtcblxuICAgIHZhciBwcm90byA9IEVkaXRGcmFtZS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHNlbGVjdGlvbiBib3ggd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHNlbGVjdGlvbiBib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBUaGUgYW1vdW50IG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICovXG4gICAgcHJvdG8uc2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJvdGF0aW9uKSB7XG5cbiAgICAgICAgdXBkYXRlU2VsZWN0b3JCb3hEaW1lbnNpb25zLmJpbmQodGhpcykod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHVwZGF0ZVNlbGVjdG9yQm94UG9zaXRpb24uYmluZCh0aGlzKSh4LCB5LCByb3RhdGlvbik7XG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbkJveFN0YXRlLmJpbmQodGhpcykodHJ1ZSk7IC8vYWN0aXZhdGUgdGhlIHNlbGVjdGlvbiBib3hcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgc2VsZWN0aW9uIGJveCBiYXNlZCBvbiB0aGUgcG9zaXRpb24sIGRpbWVuc2lvbiwgYW5kIHJvdGF0aW9uIG9mIGEgZ2l2ZW4gbWFya3VwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwfSBtYXJrdXAgLSB0aGUgbWFya3VwIHRoYXQgc2hvdWxkIGFwcGVhciBhcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIHByb3RvLnNldE1hcmt1cCA9IGZ1bmN0aW9uIChtYXJrdXApIHtcblxuICAgICAgICBpZighbWFya3VwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmt1cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFtbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFtbWVyLm9mZihcImRyYWdzdGFydCBkcmFnbW92ZSBkcmFnZW5kXCIsIHRoaXMub25IYW1tZXJEcmFnQmluZGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uQm94U3RhdGUuYmluZCh0aGlzKShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubWFya3VwICYmIHRoaXMuaGFtbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmhhbW1lci5vbihcImRyYWdzdGFydCBkcmFnbW92ZSBkcmFnZW5kXCIsIHRoaXMub25IYW1tZXJEcmFnQmluZGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gbWFya3VwLmdldENsaWVudFNpemUoKSxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gbWFya3VwLmdldENsaWVudFBvc2l0aW9uKCksXG4gICAgICAgICAgICB3aWR0aCA9IHNpemUueCxcbiAgICAgICAgICAgIGhlaWdodCA9IHNpemUueSxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gbWFya3VwLmdldFJvdGF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5tYXJrdXAgPSBtYXJrdXA7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvc2l0aW9uLnggLSAod2lkdGggLyAyKSwgcG9zaXRpb24ueSAtIChoZWlnaHQgLyAyKSwgd2lkdGgsIGhlaWdodCwgcm90YXRpb24pO1xuXG4gICAgICAgIHRoaXMuZW5hYmxlUmVzaXplSGFuZGxlcygpO1xuICAgICAgICB0aGlzLmVuYWJsZVJvdGF0aW9uSGFuZGxlKCk7XG5cbiAgICB9O1xuXG4gICAgcHJvdG8uc3RhcnREcmFnID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHRoaXMuX29uUmVwb3NpdGlvbk1vdXNlRG93bihudWxsLCB0aGlzLmVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCkpO1xuICAgIH07XG5cbiAgICAgcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmFnZ2luZygpIHx8IHRoaXMuaXNSZXNpemluZygpIHx8IHRoaXMuaXNSb3RhdGluZygpO1xuICAgICB9O1xuXG4gICAgcHJvdG8uaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmc7XG4gICAgfTtcblxuICAgIHByb3RvLmlzUmVzaXppbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnJlc2l6aW5nO1xuICAgIH07XG5cbiAgICBwcm90by5pc1JvdGF0aW5nID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5yb3RhdGluZztcbiAgICB9O1xuXG4gICAgcHJvdG8ub25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAvL2R1bW15IGZuXG4gICAgfTtcblxuICAgIHByb3RvLm9uTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvL2R1bW15IGZuXG4gICAgfTtcblxuICAgICBwcm90by5vbkhhbW1lckRyYWcgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgICBmdW5jdGlvbiB1cGRhdGVFZGl0b3JJbnB1dChpbnB1dCwgcGFyZW50LCBldmVudCkge1xuXG4gICAgICAgICAgICAgLy9UT0RPOiBDaGFuZ2UgdGhpcyB3aGVuIHJlZmFjdG9yaW5nIGlucHV0IGluIGVkaXQgZnJhbWUuXG4gICAgICAgICAgICAgdmFyIHJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgaW5wdXQubW91c2VQb3NpdGlvbi54ID0gZXZlbnQucGFnZVggLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgaW5wdXQubW91c2VQb3NpdGlvbi55ID0gZXZlbnQucGFnZVkgLSByZWN0LnRvcDtcbiAgICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdFZGl0RnJhbWUgZHJhZyAnICsgZXZlbnQudHlwZSk7XG4gICAgICAgICBjb252ZXJ0RXZlbnRIYW1tZXJUb01vdXNlKGV2ZW50KTtcbiAgICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgICAgICAgICAgICAgIHVwZGF0ZUVkaXRvcklucHV0KHRoaXMuZWRpdG9yLmlucHV0LCB0aGlzLmVkaXRvci5zdmcsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byB0cmFuc2xhdGUsIHJvdGF0ZSBvciByZXNpemVcbiAgICAgICAgICAgICAgICAgaWYgKGlzUm90YXRlUG9pbnQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblJvdGF0aW9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RyYWdQb2ludChldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAvLyBSZXNpemVcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVzaXplTW91c2VEb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREcmFnKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgY2FzZSAnZHJhZ21vdmUnOlxuICAgICAgICAgICAgICAgICB1cGRhdGVFZGl0b3JJbnB1dCh0aGlzLmVkaXRvci5pbnB1dCwgdGhpcy5lZGl0b3Iuc3ZnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgIHRoaXMub25Nb3VzZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgICAgICAgICAgdXBkYXRlRWRpdG9ySW5wdXQodGhpcy5lZGl0b3IuaW5wdXQsIHRoaXMuZWRpdG9yLnN2ZywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgfVxuICAgICB9O1xuXG4gICAgcHJvdG8uZW5hYmxlUmVzaXplSGFuZGxlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5tYXJrdXA7XG4gICAgICAgIHZhciBoYW5kbGU7XG5cbiAgICAgICAgaWYgKG1hcmt1cC5pc0hlaWdodENvbnN0cmFpbmVkKCkgfHwgbWFya3VwLmlzV2lkdGhDb25zdHJhaW5lZCgpKSB7XG4gICAgICAgICAgICAvL2hpZGUgYWxsIHRoZSBoYW5kbGVzXG4gICAgICAgICAgICBmb3IgKHZhciBkaXJlY3Rpb24gaW4gdGhpcy5zZWxlY3Rpb24uaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zZWxlY3Rpb24uaGFuZGxlW2RpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlKSBoYW5kbGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zaG93IG9ubHkgdGhlIHJlc2l6ZSBwb2ludHMgdGhhdCBhcmUgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKG1hcmt1cC5pc0hlaWdodENvbnN0cmFpbmVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5oYW5kbGVbJ3cnXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5oYW5kbGVbJ2UnXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXJrdXAuaXNXaWR0aENvbnN0cmFpbmVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5oYW5kbGVbJ24nXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5oYW5kbGVbJ3MnXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm8gY29uc3RyYWludHMsIHNob3cgYWxsIHJlc2l6ZSBoYW5kbGVzXG4gICAgICAgICAgICBmb3IgKHZhciBkaXJlY3Rpb24gaW4gdGhpcy5zZWxlY3Rpb24uaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zZWxlY3Rpb24uaGFuZGxlW2RpcmVjdGlvbl07XG4gICAgICAgICAgICAgICAgaWYoaGFuZGxlKSBoYW5kbGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdG8uZW5hYmxlUm90YXRpb25IYW5kbGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMubWFya3VwO1xuICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5zZWxlY3Rpb24ucm90YXRpb25IYW5kbGU7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gbWFya3VwLmlzUm90YXRpb25Db25zdHJhaW5lZCgpID8gJ25vbmUnIDogJ2Jsb2NrJztcbiAgICAgICAgaGFuZGxlLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuICAgIH07XG5cbiAgICAgZnVuY3Rpb24gY29udmVydEV2ZW50SGFtbWVyVG9Nb3VzZShldmVudCkge1xuICAgICAgICAgLy8gQ29udmVydCBIYW1tZXIgdG91Y2gtZXZlbnQgWCxZIGludG8gbW91c2UtZXZlbnQgWCxZLlxuICAgICAgICAgZXZlbnQucGFnZVggPSBldmVudC5wb2ludGVyc1swXS5jbGllbnRYO1xuICAgICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5wb2ludGVyc1swXS5jbGllbnRZO1xuICAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVsZW1lbnQgc3Bhbm5pbmcgdGhlIGZ1bGwgaGVpZ2h0IGFuZCB3aWR0aCBvZiBpdHMgcGFyZW50LlxuICAgICAqIEl0IHNlcnZlcyBhcyBvdXIgc3VyZmFjZSB0byBkcmF3IHRoZSBzZWxlY3Rpb24gYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uTGF5ZXIoKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbkxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNlbGVjdGlvbkxheWVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIuc3R5bGUudG9wID0gMDtcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIuc3R5bGUuYm90dG9tID0gMDtcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIHNlbGVjdGlvbkxheWVyLnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgLy9kb24ndCBsZXQgdGhlIHNlbGVjdGlvbiBib3ggYmUgdmlzaWJsZSBvdXRzaWRlIHRoZSBzZWxlY3Rpb24gbGF5ZXJcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB0b2dnbGVQb2ludGVyRXZlbnRzKHNlbGVjdGlvbkxheWVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25MYXllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIGRyYWcgcG9pbnQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWFtZXRlciAtIFRoZSBzaXplIG9mIHRoZSBkcmFnIHBvaW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIGNhcmRpbmFsKG4sIHMsIHcsIGUpIG9yIG9yZGluYWwobncsIG53LCBzdywgc2UpIGRpcmVjdGlvbiBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFnUG9pbnQoZGlhbWV0ZXIsIHBvc2l0aW9uKSB7XG5cbiAgICAgICAgdmFyIHBvaW50Qm9yZGVyV2lkdGggPSAyO1xuICAgICAgICB2YXIgcG9pbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcG9pbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBwb2ludC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgxNTEsIDE1MSwgMTUxLCAxKSc7XG4gICAgICAgIHBvaW50LnN0eWxlLmJvcmRlciA9IHBvaW50Qm9yZGVyV2lkdGggKyAncHggc29saWQgcmdiKDk1LCA5OCwgMTAwKSc7XG4gICAgICAgIHBvaW50LnN0eWxlLmhlaWdodCA9IGRpYW1ldGVyICsgJ3B4JztcbiAgICAgICAgcG9pbnQuc3R5bGUud2lkdGggPSBkaWFtZXRlciArICdweCc7XG4gICAgICAgIHBvaW50LnN0eWxlLmJvcmRlclJhZGl1cyA9IChkaWFtZXRlciAvIDIpICsgcG9pbnRCb3JkZXJXaWR0aCArICdweCc7XG4gICAgICAgIHBvaW50LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAgICAgc2V0UmVzaXplQ3Vyc29yKHBvaW50LCBwb3NpdGlvbik7XG4gICAgICAgIHBvaW50LmNsYXNzTmFtZSA9ICdzZWxlY3Rvci1kcmFnLXBvaW50IHNkcC1oYW5kbGUtJyArIHBvc2l0aW9uO1xuICAgICAgICBwb2ludC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2RwLWhhbmRsZScsIHBvc2l0aW9uKTtcblxuICAgICAgICB2YXIgcGxhY2VtZW50T2Zmc2V0ID0gLTEgKiAoKGRpYW1ldGVyICsgcG9pbnRCb3JkZXJXaWR0aCkgLyAyKTtcbiAgICAgICAgLy9zZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcmFnIHBvaW50cyBiYXNlZCBvbiB0aGUgcG9zaXRpb25cbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgLy93cmFwIHRoZSBwb2ludCBpbnNpZGUgYSB3cmFwcGVyIHNvIHdlIGNhbiBjZW50ZXIgaXRcbiAgICAgICAgICAgICAgICAvL3VzaW5nIG1hcmdpbjogMCBhdXRvXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gZGlhbWV0ZXIgKyAncHgnO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUudG9wID0gcGxhY2VtZW50T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS5tYXJnaW4gPSAnMCBhdXRvJztcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChwb2ludCk7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB3cmFwcGVyO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5oZWlnaHQgPSBkaWFtZXRlciArICdweCc7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5ib3R0b20gPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLm1hcmdpbiA9ICcwIGF1dG8nO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLnBvc2l0aW9uID0gJyc7XG5cbiAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHBvaW50KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHdyYXBwZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS5sZWZ0ID0gcGxhY2VtZW50T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS50b3AgPSAnNTAlJztcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwgLTUwJSwgMCknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgcG9pbnQuc3R5bGUucmlnaHQgPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLnRvcCA9ICc1MCUnO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLCAtNTAlLCAwKSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdudyc6XG4gICAgICAgICAgICAgICAgcG9pbnQuc3R5bGUudG9wID0gcGxhY2VtZW50T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS5sZWZ0ID0gcGxhY2VtZW50T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25lJzpcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS50b3AgPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLnJpZ2h0ID0gcGxhY2VtZW50T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N3JzpcbiAgICAgICAgICAgICAgICBwb2ludC5zdHlsZS5ib3R0b20gPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLmxlZnQgPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2UnOlxuICAgICAgICAgICAgICAgIHBvaW50LnN0eWxlLmJvdHRvbSA9IHBsYWNlbWVudE9mZnNldCArICdweCc7XG4gICAgICAgICAgICAgICAgcG9pbnQuc3R5bGUucmlnaHQgPSBwbGFjZW1lbnRPZmZzZXQgKyAncHgnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3RhdGVQb2ludCAoZGlhbWV0ZXIpIHtcblxuICAgICAgICB2YXIgcG9pbnRCb3JkZXJXaWR0aCA9IDI7XG4gICAgICAgIHZhciBwb2ludCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwb2ludC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHBvaW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdhcXVhJztcbiAgICAgICAgcG9pbnQuc3R5bGUuYm9yZGVyID0gcG9pbnRCb3JkZXJXaWR0aCArICdweCBzb2xpZCByZ2IoOTUsIDk4LCAxMDApJztcbiAgICAgICAgcG9pbnQuc3R5bGUuaGVpZ2h0ID0gZGlhbWV0ZXIgKyAncHgnO1xuICAgICAgICBwb2ludC5zdHlsZS53aWR0aCA9IGRpYW1ldGVyICsgJ3B4JztcbiAgICAgICAgcG9pbnQuc3R5bGUuYm9yZGVyUmFkaXVzID0gKGRpYW1ldGVyIC8gMikgKyBwb2ludEJvcmRlcldpZHRoICsgJ3B4JztcbiAgICAgICAgcG9pbnQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICBwb2ludC5jbGFzc0xpc3QuYWRkKCdzZWxlY3Rvci1yb3RhdGUtcG9pbnQnKTtcbiAgICAgICAgcG9pbnQuc3R5bGUubGVmdCA9ICc1MCUnO1xuICAgICAgICBwb2ludC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoLTUwJSwgMHB4LCAwcHgpJztcbiAgICAgICAgcG9pbnQuc3R5bGUudG9wID0gJy0yNXB4JztcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFJlc2l6ZUN1cnNvciAoZWxlbWVudCwgZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgdmFyIGN1cnNvcjtcbiAgICAgICAgc3dpdGNoKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSAnbnMtcmVzaXplJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gJ2V3LXJlc2l6ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICBjYXNlICdzdyc6XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gJ25lc3ctcmVzaXplJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ253JzpcbiAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgICAgICBjdXJzb3IgPSAnbndzZS1yZXNpemUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIDggZHJhZyBwb2ludHMgb2YgdGhlIHNlbGVjdGlvbiBib3guXG4gICAgICpcbiAgICAgKiBAdGhpcyBFZGl0RnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFnUG9pbnRzKHNlbGVjdG9yKSB7XG5cbiAgICAgICAgdmFyIHBvaW50RGlhbWV0ZXIgPSAxMjtcblxuICAgICAgICBbJ24nLCAncycsICd3JywgJ2UnLCAnbncnLCAnbmUnLCAnc3cnLCAnc2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vc3RvcmUgdGhlIGRyYWcgcG9pbnQgYW5kIHB1dCBpdCBpbiB0aGUgRE9NXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5oYW5kbGVbZGlyZWN0aW9uXSA9IGNyZWF0ZURyYWdQb2ludChwb2ludERpYW1ldGVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb24uaGFuZGxlW2RpcmVjdGlvbl0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBpcyBhIGRyYWcgcG9pbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEcmFnUG9pbnQoZWxlbWVudCkge1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3JBdXgoZWxlbWVudCwgJy5zZWxlY3Rvci1kcmFnLXBvaW50Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IGlzIGEgcm90YXRlIHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUm90YXRlUG9pbnQoZWxlbWVudCkge1xuXG4gICAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3JBdXgoZWxlbWVudCwgJy5zZWxlY3Rvci1yb3RhdGUtcG9pbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBzZWxlY3Rpb24gYm94LiBJdCBhbHNvXG4gICAgICogdGFrZXMgY2FyZSBvZiBhZGRpbmcgdGhlIGRyYWcgaGFuZGxlc1xuICAgICAqXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IC0gdGhlIHNlbGVjdGlvbiBib3hcbiAgICAgKiBAdGhpcyBFZGl0RnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckJveCgpIHtcblxuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAxO1xuICAgICAgICB2YXIgYm9yZGVyQ29sb3IgPSAncmdiKDAsIDAsIDI1NSknO1xuICAgICAgICB2YXIgc2VsZWN0b3JCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2VsZWN0b3JCb3guc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzZWxlY3RvckJveC5zdHlsZS5ib3JkZXIgPSBib3JkZXJXaWR0aCArICdweCBzb2xpZCAnICsgYm9yZGVyQ29sb3I7XG4gICAgICAgIHNlbGVjdG9yQm94LnN0eWxlLnpJbmRleCA9IDE7XG4gICAgICAgIHNlbGVjdG9yQm94LnN0eWxlLmN1cnNvciA9ICdtb3ZlJztcbiAgICAgICAgc2VsZWN0b3JCb3guc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICB0b2dnbGVQb2ludGVyRXZlbnRzKHNlbGVjdG9yQm94LCB0cnVlKTtcbiAgICAgICAgc2VsZWN0b3JCb3guY2xhc3NMaXN0LmFkZCgnc2VsZWN0b3ItYm94Jyk7XG4gICAgICAgIGNyZWF0ZURyYWdQb2ludHMuYmluZCh0aGlzKShzZWxlY3RvckJveCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJvdGF0aW9uSGFuZGxlID0gY3JlYXRlUm90YXRlUG9pbnQoMTIpO1xuICAgICAgICBzZWxlY3RvckJveC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbi5yb3RhdGlvbkhhbmRsZSk7XG4gICAgICAgIC8vc3RvcmUgdGhlIHNlbGVjdG9yIGJveFxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50ID0gc2VsZWN0b3JCb3g7XG5cbiAgICAgICAgLy9hZGQgdGhlIHNlbGVjdGlvbiBib3ggdG8gdGhlIHNlbGVjdGlvbiBsYXllclxuICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQpO1xuXG4gICAgICAgIC8vd2UgYXJlIGp1c3QgY3JlYXRpbmcgdGhlIGJveCwgc3RhcnQgaXQgb3V0IGhpZGRlblxuICAgICAgICB1cGRhdGVTZWxlY3Rpb25Cb3hTdGF0ZS5iaW5kKHRoaXMpKGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0b3JCb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSB0byBjcmVhdGUgdGhlIENTUyB0cmFuc2xhdGUzZCB2YWx1ZSBmcm9tIGEgZ2l2ZW4gMmQgcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1RyYW5zbGF0ZTNkKHgsIHkpIHtcblxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCcgKyB5ICsgJ3B4LDApJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXkgc3RhdGUgb2YgdGhlIHNlbGVjdGlvbiBib3hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIC0gVGhlIG5ldyBzdGF0ZSBvZiB0aGUgdGhlIHNlbGVjdGlvbiBib3hcbiAgICAgKiBAdGhpcyBFZGl0RnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb25Cb3hTdGF0ZShhY3RpdmUpIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbi5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGFjdGl2ZSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIG9mIHRoZSBzZWxlY3Rpb24gYm94LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBzZWxlY3Rpb24gYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gVGhlIGFtb3VudCBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgc2VsZWN0aW9uIGJveFxuICAgICAqIEB0aGlzIEVkaXRGcmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdG9yQm94UG9zaXRpb24oeCwgeSwgcm90YXRpb24pIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ueSA9IHk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5tYXJrdXAuZ2V0Q2xpZW50U2l6ZSgpO1xuICAgICAgICAvL1RPRE86IGNvbnNpZGVyIERvbUVsZW1lbnRTdHlsZVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm0gPSB0b1RyYW5zbGF0ZTNkKHgsIHkpICsgJyByb3RhdGUoJyArIHJvdGF0aW9uICsgJ3JhZCknO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gKHNpemUueCAvIDIpICsgJ3B4ICcgKyAoc2l6ZS55IC8gMikgKyAncHgnO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRvVHJhbnNsYXRlM2QoeCwgeSkgKyAnIHJvdGF0ZSgnICsgcm90YXRpb24gKyAncmFkKSc7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gKHNpemUueCAvIDIpICsgJ3B4ICcgKyAoc2l6ZS55IC8gMikgKyAncHgnO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRvVHJhbnNsYXRlM2QoeCwgeSkgKyAnIHJvdGF0ZSgnICsgcm90YXRpb24gKyAncmFkKSc7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKHNpemUueCAvIDIpICsgJ3B4ICcgKyAoc2l6ZS55IC8gMikgKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNlbGVjdGlvbiBib3ggKHdpZHRoIGFuZCBoZWlnaHQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgc2VsZWN0aW9uIGJveFxuICAgICAqIEB0aGlzIEVkaXRGcmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdG9yQm94RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYWxsIHRoZSBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIGhhbmRsZSBhIGRyYWcgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHRoaXMgRWRpdEZyYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFuZGxlU2VsZWN0aW9uQm94RHJhZ2dpbmcgKCkge1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25SZXBvc2l0aW9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHByb3RvLl9vblJlcG9zaXRpb25Nb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIGN1cnNvcikge1xuXG4gICAgICAgIC8vYSBzeW50aGV0aWMgc3RhcnQgbWVhbnMgdGhhdCB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZCBtYW51YWxseSBhbmQgbm90IGFzIGFcbiAgICAgICAgLy9yZXN1bHQgb2YgYSBtb3VzZWRvd24gb24gdGhlIGVkaXQgZnJhbWVcbiAgICAgICAgdmFyIHN5bnRoZXRpY1N0YXJ0ID0gIShldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpO1xuXG4gICAgICAgIC8vZHVyaW5nIGEgcmVhbCBtb3VzZWRvd24sIGlnbm9yZSBldmVudHMgb3JpZ2luYXRpbmcgZnJvbSBhIHJlc2l6aW5nIGhhbmRsZVxuICAgICAgICBpZiAoIXN5bnRoZXRpY1N0YXJ0ICYmIChpc0RyYWdQb2ludChldmVudC50YXJnZXQpIHx8IGlzUm90YXRlUG9pbnQoZXZlbnQudGFyZ2V0KSkpIHJldHVybjtcblxuICAgICAgICB0aGlzLmVkaXRvci5iZWdpbkFjdGlvbkdyb3VwKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvL2dldCB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIGN1cnNvciA9IHN5bnRoZXRpY1N0YXJ0ID8gIGN1cnNvciA6IHRoaXMuZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcblxuICAgICAgICAvL3N0b3JlIHRoZSBpbml0aWFsIGN1cnNvciBhbmQgYXhpcyBjb25zdHJhaW5zXG4gICAgICAgIHRoaXMuaW5pdGlhbEN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSB0aGlzLm1hcmt1cC5nZXRDbGllbnRQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmFyZUF4aXNDb25zdHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF4aXNDb25zdHJhaW5zID0gbmV3IFRIUkVFLlZlY3RvcjIoMSwxKTtcblxuICAgICAgICAvL3VwZGF0ZSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSB0aGUgbW91c2Vtb3ZlIGFuZCBtb3VzZXVwIGV2ZW50c1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gdGhpcy5fb25SZXBvc2l0aW9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5fb25SZXBvc2l0aW9uTW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vaWYgYWx0IGRvd24gSSBkcm9wIGEgY2xvbmUuXG4gICAgICAgIGlmIChldmVudCAmJiBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgICAgIHZhciBjbG9uZU1hcmt1cCA9IG5ldyBuYW1lc3BhY2UuQ2xvbmVNYXJrdXAoZWRpdG9yLCBlZGl0b3IuZ2V0SWQoKSwgdGhpcy5tYXJrdXAsIHRoaXMubWFya3VwLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNsb25lTWFya3VwLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHsgdHlwZTogbmFtZXNwYWNlLkVWRU5UX0VESVRGUkFNRV9FRElUSU9OX1NUQVJUIH0pOyAvLyBNb3ZpbmcgYXJvdW5kXG4gICAgfTtcblxuICAgIHByb3RvLl9vblJlcG9zaXRpb25Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICAvL2lnbm9yZSBtb3VzZW1vdmUgZXZlbnRzIGlmIHRoZSBkcmFnZ2luZyBzdGF0ZSBoYXNuJ3QgYmVlbiBhY3RpdmF0ZWRcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5kcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgICAgIC8vZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIHJlbGF0aXZlIHRvIHNlbGVjdGlvbiBsYXllclxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0TW91c2VQb3NpdGlvbigpO1xuXG5cbiAgICAgICAgLy9jb25zdHJhaW4gYXhpcyBpZiBzaGlmdCBrZXkgaXMgZG93bi5cbiAgICAgICAgdmFyIGNvbnN0cmFpbkF4aXMgPSB0aGlzLmVkaXRvci5pbnB1dC5jb25zdHJhaW5BeGlzO1xuICAgICAgICBpZiAodGhpcy5hcmVBeGlzQ29uc3RyYWluZWQgIT09IGNvbnN0cmFpbkF4aXMpIHtcbiAgICAgICAgICAgIHRoaXMuYXJlQXhpc0NvbnN0cmFpbmVkID0gY29uc3RyYWluQXhpcztcbiAgICAgICAgICAgIHRoaXMuYXhpc0NvbnN0cmFpbnMgPSBjb25zdHJhaW5BeGlzID8gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCkgOiBuZXcgVEhSRUUuVmVjdG9yMigxLDEpO1xuXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbi54ICs9IGN1cnNvci54IC0gdGhpcy5pbml0aWFsQ3Vyc29yLng7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxQb3NpdGlvbi55ICs9IGN1cnNvci55IC0gdGhpcy5pbml0aWFsQ3Vyc29yLnk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbEN1cnNvci54ID0gY3Vyc29yLng7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxDdXJzb3IueSA9IGN1cnNvci55O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kZXRlcm1pbmUgaG93IG1hbnkgcGl4ZWwgd2UgaGF2ZSB0byBzaGlmdCB0aGVcbiAgICAgICAgLy9zZWxlY3Rpb24gYm94IHRvIGtlZXAgdGhlIGN1cnNvciBvbiB0aGUgZHJhZyBwb2ludFxuICAgICAgICB2YXIgbW92ZW1lbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJzb3IueCAtIHRoaXMuaW5pdGlhbEN1cnNvci54LFxuICAgICAgICAgICAgeTogY3Vyc29yLnkgLSB0aGlzLmluaXRpYWxDdXJzb3IueVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkZWFkWm9uZSA9IDE1O1xuICAgICAgICBpZiAodGhpcy5heGlzQ29uc3RyYWlucy54ID09PSAwICYmIHRoaXMuYXhpc0NvbnN0cmFpbnMueSA9PT0gMCkge1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobW92ZW1lbnQueCkgPiBkZWFkWm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0NvbnN0cmFpbnMueCA9IDE7XG4gICAgICAgICAgICAgICAgbW92ZW1lbnQueCArPSBtb3ZlbWVudC54IDwgMCA/ICBkZWFkWm9uZSA6IC1kZWFkWm9uZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG1vdmVtZW50LnkpID4gZGVhZFpvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNDb25zdHJhaW5zLnkgPSAxO1xuICAgICAgICAgICAgICAgIG1vdmVtZW50LnkgKz0gbW92ZW1lbnQueSA8IDAgPyAgZGVhZFpvbmUgOiAtZGVhZFpvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uLnggKyBtb3ZlbWVudC54ICogdGhpcy5heGlzQ29uc3RyYWlucy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMuaW5pdGlhbFBvc2l0aW9uLnkgKyBtb3ZlbWVudC55ICogdGhpcy5heGlzQ29uc3RyYWlucy55O1xuXG4gICAgICAgIHVwZGF0ZVNlbGVjdG9yQm94UG9zaXRpb24uYmluZCh0aGlzKSh4LCB5LCB0aGlzLnNlbGVjdGlvbi5yb3RhdGlvbik7XG5cbiAgICAgICAgLy90ZWxsIHRoZSBtYXJrdXAgdG8gc3RhcnQgdHJhbnNmb3JtaW5nXG4gICAgICAgIC8vdGhlIG1hcmt1cCBleHBlY3RzIGFuICh4LCB5KSBjb29yZGluYXRlIHRoYXRcbiAgICAgICAgLy91c2VzIGFuIG9yaWdpbiBhdCB0aGUgY2VudGVyLCBhZGp1c3Qgb3VyIHgsIHkgYmVjYXVzZVxuICAgICAgICAvL291ciBvcmlnaW4gc3RhcnRzIGF0IHRoZSB0b3AgbGVmdFxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmVkaXRvci5wb3NpdGlvbkZyb21DbGllbnRUb01hcmt1cHMoeCwgeSk7XG4gICAgICAgIHZhciBzZXRQb3NpdGlvbiA9IG5ldyBuYW1lc3BhY2UuU2V0UG9zaXRpb24odGhpcy5lZGl0b3IsIHRoaXMubWFya3VwLCBwb3NpdGlvbik7XG4gICAgICAgIHNldFBvc2l0aW9uLmV4ZWN1dGUoKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uX29uUmVwb3NpdGlvbk1vdXNlVXAgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcblxuICAgICAgICAvL3RoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZCBhZnRlciB0aGUgbW91c2UgdXAgYmVjYXVzZSB3ZSBhcmUgbm8gbG9uZ2VyIHJlcG9zaXRpb25pbmdcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uICgpIHsvKmRvIG5vdGhpbmcqL307XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gZnVuY3Rpb24gKCkgey8qZG8gbm90aGluZyovfTtcblxuICAgICAgICBpZighdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWRpdG9yLmNsb3NlQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoeyB0eXBlOiBuYW1lc3BhY2UuRVZFTlRfRURJVEZSQU1FX0VESVRJT05fRU5EIH0pOyAvLyBNb3ZpbmcgYXJvdW5kXG4gICAgfTtcblxuICAgIHByb3RvLl9vblJlc2l6ZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIC8vaXMgdGhlIHRhcmdldCB3aGVyZSB0aGUgbW91c2Vkb3duIG9jY3VycmVkIGEgZHJhZyBwb2ludFxuICAgICAgICBpZiAoIWlzRHJhZ1BvaW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgLy9rZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBwb2ludCB3aGVyZSB0aGUgZHJhZyBzdGFydGVkXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLmhhbmRsZS5yZXNpemluZyA9IHRhcmdldDtcbiAgICAgICAgLy9maWd1cmUgb3V0IHdoaWNoIGRpcmVjdGlvbiB0aGlzIHBvaW50IHNob3VsZCByZXNpemVcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLmhhbmRsZS5yZXNpemluZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2RwLWhhbmRsZScpO1xuICAgICAgICAvL3NldCB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB0aGUgZW50aXJlIGxheWVyXG4gICAgICAgIHRoaXMuY29udGFpbmluZ0Rpdi5zdHlsZS5jdXJzb3IgPSBkaXJlY3Rpb24gKyAnLXJlc2l6ZSc7XG5cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLm1hcmt1cC5nZXRDbGllbnRQb3NpdGlvbigpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMubWFya3VwLmdldENsaWVudFNpemUoKTtcblxuICAgICAgICAvL3N0b3JlIHRoZSBjZW50ZXJcbiAgICAgICAgdGhpcy5pbml0aWFsID0ge1xuICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnksXG4gICAgICAgICAgICB3aWR0aDogc2l6ZS54LFxuICAgICAgICAgICAgaGVpZ2h0OiBzaXplLnksXG4gICAgICAgICAgICBtb3VzZVg6IGN1cnNvci54LFxuICAgICAgICAgICAgbW91c2VZOiBjdXJzb3IueVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLl9vblJlc2l6ZU1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IHRoaXMuX29uUmVzaXplTW91c2VVcC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vbm90aWZ5IHRoZSBtYXJrdXAgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZFxuICAgICAgICB0aGlzLmVkaXRvci5iZWdpbkFjdGlvbkdyb3VwKCk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHsgdHlwZTogbmFtZXNwYWNlLkVWRU5UX0VESVRGUkFNRV9FRElUSU9OX1NUQVJUIH0pOyAvLyBSZXNpemluZ1xuICAgIH07XG5cbiAgICBwcm90by5fb25SZXNpemVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLnJlc2l6aW5nKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGN1cnNvciA9IHRoaXMuZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGluaXRpYWwgPSB0aGlzLmluaXRpYWw7XG5cbiAgICAgICAgdmFyIG1vdmVtZW50ID0ge1xuICAgICAgICAgICAgeDogY3Vyc29yLnggLSBpbml0aWFsLm1vdXNlWCxcbiAgICAgICAgICAgIHk6IGN1cnNvci55IC0gaW5pdGlhbC5tb3VzZVlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMobW92ZW1lbnQueCwgbW92ZW1lbnQueSwgMCk7XG4gICAgICAgIHZhciB1bmRvUm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblooLXRoaXMuc2VsZWN0aW9uLnJvdGF0aW9uKTtcbiAgICAgICAgbW92ZW1lbnQgPSB2ZWN0b3IuYXBwbHlNYXRyaXg0KHVuZG9Sb3RhdGlvbik7XG5cbiAgICAgICAgdmFyIHggPSBpbml0aWFsLngsXG4gICAgICAgICAgICB5ID0gaW5pdGlhbC55LFxuICAgICAgICAgICAgd2lkdGggPSBpbml0aWFsLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW5pdGlhbC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxvY2FsU3BhY2VEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgICAgLy9nZXQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgYXJyb3cgYmVpbmcgZHJhZ2dlZFxuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5zZWxlY3Rpb24uaGFuZGxlLnJlc2l6aW5nLmdldEF0dHJpYnV0ZSgnZGF0YS1zZHAtaGFuZGxlJyk7XG5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBhIG1lY2hhbmlzbSB0byBjb25maWd1cmUgYW5kIHVzZSB0aGlzIGZlYXR1cmUgZnJvbSBNYXJrdXBzIENvcmUuXG4gICAgICAgIC8vIElmIHNoaWZ0IGlzIHByZXNzZWQsIGZpZ3VyZSBhc3BlY3QgcmF0aW8gaXMgbWFpbnRhaW5lZC5cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlucHV0LmtlZXBBc3BlY3RSYXRpbyAmJiBbJ253JywgJ25lJywgJ3N3JywgJ3NlJ10uaW5kZXhPZihkaXJlY3Rpb24pICE9PSAtMSkge1xuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBuZXcgVEhSRUUuVmVjdG9yMyhtb3ZlbWVudC54LCBtb3ZlbWVudC55LCAwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKXtcbiAgICAgICAgICAgICAgICBjYXNlICdudyc6IG1vdmVtZW50LnNldCgtaW5pdGlhbC53aWR0aCwtaW5pdGlhbC5oZWlnaHQsIDApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduZSc6IG1vdmVtZW50LnNldCggaW5pdGlhbC53aWR0aCwtaW5pdGlhbC5oZWlnaHQsIDApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdyc6IG1vdmVtZW50LnNldCggaW5pdGlhbC53aWR0aCwtaW5pdGlhbC5oZWlnaHQsIDApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzZSc6IG1vdmVtZW50LnNldCggaW5pdGlhbC53aWR0aCwgaW5pdGlhbC5oZWlnaHQsIDApOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdmVtZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbW92ZW1lbnQgPSBkZWx0YS5wcm9qZWN0T25WZWN0b3IobW92ZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IHtcbiAgICAgICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gbW92ZW1lbnQueTtcbiAgICAgICAgICAgICAgICBsb2NhbFNwYWNlRGVsdGEueSA9IG1vdmVtZW50Lnk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCArPSBtb3ZlbWVudC55O1xuICAgICAgICAgICAgICAgIGxvY2FsU3BhY2VEZWx0YS55ID0gbW92ZW1lbnQueTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgd2lkdGggLT0gbW92ZW1lbnQueDtcbiAgICAgICAgICAgICAgICBsb2NhbFNwYWNlRGVsdGEueCA9IG1vdmVtZW50Lng7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHdpZHRoICs9IG1vdmVtZW50Lng7XG4gICAgICAgICAgICAgICAgbG9jYWxTcGFjZURlbHRhLnggPSBtb3ZlbWVudC54O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG53OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy53KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucygpO1xuICAgICAgICAgICAgICAgIHRoaXMudygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJhbnNsYXRpb25zW2RpcmVjdGlvbl0oKTtcblxuICAgICAgICB2YXIgcmVkb1JvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25aKHRoaXMuc2VsZWN0aW9uLnJvdGF0aW9uKTtcbiAgICAgICAgdmFyIGFjdHVhbERlbHRhID0gbG9jYWxTcGFjZURlbHRhLmFwcGx5TWF0cml4NChyZWRvUm90YXRpb24pO1xuXG4gICAgICAgIHZhciBuZXdQb3MgPSB0aGlzLmVkaXRvci5wb3NpdGlvbkZyb21DbGllbnRUb01hcmt1cHMoXG4gICAgICAgICAgICB4ICsgKGFjdHVhbERlbHRhLnggKiAwLjUpLFxuICAgICAgICAgICAgeSArIChhY3R1YWxEZWx0YS55ICogMC41KSk7XG5cbiAgICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLmVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3Vwcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHNldFNpemUgPSBuZXcgbmFtZXNwYWNlLlNldFNpemUodGhpcy5lZGl0b3IsIHRoaXMubWFya3VwLCBuZXdQb3MsIG5ld1NpemUueCwgbmV3U2l6ZS55KTtcbiAgICAgICAgc2V0U2l6ZS5leGVjdXRlKCk7XG4gICAgfTtcblxuICAgIHByb3RvLl9vblJlc2l6ZU1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uaGFuZGxlLnJlc2l6aW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250YWluaW5nRGl2LnN0eWxlLmN1cnNvciA9ICcnO1xuXG4gICAgICAgIHRoaXMuZWRpdG9yLmNsb3NlQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoeyB0eXBlOiBuYW1lc3BhY2UuRVZFTlRfRURJVEZSQU1FX0VESVRJT05fRU5EIH0pOyAvLyBSZXNpemluZ1xuXG4gICAgICAgIC8vdGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGFmdGVyIHRoZSBtb3VzZSB1cCBiZWNhdXNlIHdlIGFyZSBubyBsb25nZXIgcmVzaXppbmdcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uICgpIHsvKmRvIG5vdGhpbmcqL1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uTW91c2VVcCA9IGZ1bmN0aW9uICgpIHsvKmRvIG5vdGhpbmcqL1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFsbCB0aGUgbmVjZXNzYXJ5IGxpc3RlbmVycyB0byBoYW5kbGUgYSByZXNpemluZyBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdGhpcyBFZGl0RnJhbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVTZWxlY3Rpb25Cb3hSZXNpemluZygpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblJlc2l6ZU1vdXNlRG93bi5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTZWxlY3Rpb25Cb3hSb3RhdGluZyAoKSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblJvdGF0aW9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsUm90YXRpb247XG4gICAgdmFyIGluaXRpYWxIYW5kbGVQb3NpdGlvbjtcblxuICAgIHByb3RvLl9vblJvdGF0aW9uTW91c2VEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgLy9pZ25vcmUgYW55dGhpbmcgbm90IGNvbWluZyBmcm9tIHRoZSByb3RhdGlvbiBwb2ludFxuICAgICAgICBpZiAoIWlzUm90YXRlUG9pbnQoZXZlbnQudGFyZ2V0KSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZWRpdG9yLmJlZ2luQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucm90YXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIC8vc3RvcmUgdGhlIGluaXRpYWwgY3Vyc29yXG4gICAgICAgIGluaXRpYWxIYW5kbGVQb3NpdGlvbiA9IHRoaXMuZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcblxuICAgICAgICBpbml0aWFsUm90YXRpb24gPSB0aGlzLnNlbGVjdGlvbi5yb3RhdGlvbiB8fCAwO1xuXG4gICAgICAgIC8vdXBkYXRlIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgaGFuZGxlIHRoZSBtb3VzZW1vdmUgYW5kIG1vdXNldXAgZXZlbnRzXG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLl9vblJvdGF0aW9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZVVwID0gdGhpcy5fb25Sb3RhdGlvbk1vdXNlVXAuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLmZpcmVFdmVudCh7IHR5cGU6IG5hbWVzcGFjZS5FVkVOVF9FRElURlJBTUVfRURJVElPTl9TVEFSVCB9KTsgLy8gUm90YXRpbmdcbiAgICB9O1xuXG4gICAgIHByb3RvLl9vblJvdGF0aW9uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgLy9pZ25vcmUgbW91c2Vtb3ZlIGV2ZW50cyBpZiB0aGUgZHJhZ2dpbmcgc3RhdGUgaGFzbid0IGJlZW4gYWN0aXZhdGVkXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ucm90YXRpbmcpIHJldHVybjtcblxuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0TW91c2VQb3NpdGlvbigpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLm1hcmt1cC5nZXRDbGllbnRQb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciByID0gZ2V0QW5nbGVCZXR3ZWVuUG9pbnRzKHBvc2l0aW9uLCBjdXJzb3IpO1xuICAgICAgICB2YXIgcjIgPSBnZXRBbmdsZUJldHdlZW5Qb2ludHMocG9zaXRpb24sIGluaXRpYWxIYW5kbGVQb3NpdGlvbik7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHIgLSByMiArIGluaXRpYWxSb3RhdGlvbjtcblxuICAgICAgICAvLyBUT0RPOiBNYWtlIGEgbWVjaGFuaXNtIHRvIGNvbmZpZ3VyZSBhbmQgdXNlIHRoaXMgZmVhdHVyZSBmcm9tIE1hcmt1cHMgQ29yZS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLmlucHV0LnNuYXBSb3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzbmFwID0gbmFtZXNwYWNlVXRpbHMuZGVncmVlc1RvUmFkaWFucygyMi41KTtcbiAgICAgICAgICAgIHJvdGF0aW9uID0gTWF0aC5jZWlsKHJvdGF0aW9uIC8gc25hcCkgKiBzbmFwO1xuICAgICAgICB9XG5cbiAgICAgICAgIC8vcGFzcyByb3RhdGlvbiBhcyBkZWdyZWVzXG4gICAgICAgICB1cGRhdGVTZWxlY3RvckJveFBvc2l0aW9uLmJpbmQodGhpcykodGhpcy5zZWxlY3Rpb24ueCwgdGhpcy5zZWxlY3Rpb24ueSwgcm90YXRpb24pO1xuXG4gICAgICAgIC8vY29udmVydCB0byByYWRpYW5zXG4gICAgICAgIHZhciBzZXRSb3RhdGlvbiA9IG5ldyBuYW1lc3BhY2UuU2V0Um90YXRpb24odGhpcy5lZGl0b3IsIHRoaXMubWFya3VwLCByb3RhdGlvbik7XG4gICAgICAgIHNldFJvdGF0aW9uLmV4ZWN1dGUoKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uX29uUm90YXRpb25Nb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucm90YXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5pdGlhbFJvdGF0aW9uID0gbnVsbDtcbiAgICAgICAgaW5pdGlhbEhhbmRsZVBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5lZGl0b3IuY2xvc2VBY3Rpb25Hcm91cCgpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCh7IHR5cGU6IG5hbWVzcGFjZS5FVkVOVF9FRElURlJBTUVfRURJVElPTl9FTkQgfSk7IC8vIFJvdGF0aW5nXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGRvdWJsZSBjbGljayBsaXN0ZW5lciBhbmQgcGFzcyBldmVudHMgdG8gbWFya3VwLCBtYXJrdXBzIHN1Y2ggYXMgdGV4dCB1c2UgaXQgdG8gZW50ZXIgdGV4dCBlZGl0XG4gICAgICogbW9kZS5cbiAgICAgKlxuICAgICAqIEB0aGlzIEVkaXRGcmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhbmRsZVNlbGVjdGlvbkRvdWJsZUNsaWNrKCkge1xuXG4gICAgICAgIHZhciBkb3VibGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24uZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlZGl0TW9kZSA9IHRoaXMuZWRpdG9yLmVkaXRNb2RlO1xuICAgICAgICAgICAgZWRpdE1vZGUgJiYgZWRpdE1vZGUub25Eb3VibGVDbGljayh0aGlzLm1hcmt1cCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICB2YXIgc2VsZWN0b3JCb3hXcmFwcGVyID0gdGhpcy5zZWxlY3Rpb25MYXllcjtcbiAgICAgICAgc2VsZWN0b3JCb3hXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZG91YmxlQ2xpY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVBvaW50ZXJFdmVudHMoZWxlbWVudCwgc3RhdGUpIHtcblxuICAgICAgICBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBzdGF0ZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBbmdsZUJldHdlZW5Qb2ludHMgKHAxLCBwMikge1xuXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHAyLnkgLSBwMS55LCBwMi54IC0gcDEueCk7XG4gICAgfVxuXG4gICAgIGZ1bmN0aW9uIG1hdGNoZXNTZWxlY3RvckF1eChkb21FbGVtLCBzZWxlY3Rvcikge1xuICAgICAgICAgaWYgKGRvbUVsZW0ubWF0Y2hlcykgcmV0dXJuIGRvbUVsZW0ubWF0Y2hlcyhzZWxlY3Rvcik7IC8vVW4tcHJlZml4ZWRcbiAgICAgICAgIGlmIChkb21FbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gZG9tRWxlbS5tc01hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7ICAvL0lFXG4gICAgICAgICBpZiAoZG9tRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IpIHJldHVybiBkb21FbGVtLm1vek1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7IC8vRmlyZWZveCAoR2Vja28pXG4gICAgICAgICBpZiAoZG9tRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHJldHVybiBkb21FbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7IC8vIE9wZXJhLCBTYWZhcmksIENocm9tZVxuICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICB9XG5cbiAgICAgbmFtZXNwYWNlLkVkaXRGcmFtZSA9IEVkaXRGcmFtZTtcblxuIH0pKCk7XG5cclxuQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscy5Mb2NhbGl6YXRpb24gPSB7XG5cbiAgICBNQVJLVVBfVEVYVF9ERUZBVUxUX1RFWFQ6ICdXcml0ZSBzb21ldGhpbmcuLi4nXG59O1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYWxsIE1hcmt1cHMuPGJyPlxuICAgICAqIEEgTWFya3VwIGlzIGEgY2xhc3MgdGhhdCBpcyBjYXBhYmxlIG9mIHJlbmRlcmluZyBpdHNlbGYgYXMgYW4gU3ZnIG5vZGUuPGJyPlxuICAgICAqIEl0IGNhbiBhbHNvIHJlbmRlciBpdHNlbGYgaW50byBhIGNhbnZhcy0yZCBjb250ZXh0LlxuICAgICAqIENvbXBvbmVudCB3aXRoaW4ge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUgTWFya3Vwc0NvcmV9IGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEFueSBjbGFzcyBleHRlbmRpbmcgTWFya3VwIHNob3VsZCBjb250YWluIGF0IGxlYXN0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICAgKiAtIGdldEVkaXRNb2RlKClcbiAgICAgKiAtIHNldCgpXG4gICAgICogLSB1cGRhdGVTdHlsZSgpXG4gICAgICogLSBzZXRQYXJlbnQoKVxuICAgICAqIC0gc2V0Um90YXRpb24oKVxuICAgICAqIC0gc2V0U2l6ZSgpXG4gICAgICogLSBzZXRQb3NpdGlvbigpXG4gICAgICogLSByZW5kZXJUb0NhbnZhcygpXG4gICAgICogLSBzZXRNZXRhZGF0YSgpXG4gICAgICpcbiAgICAgKiBBIGdvb2QgcmVmZXJlbmNlIGlzIHRoZSByZWN0YW5nbGUgbWFya3VwIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBpblxuICAgICAqIFtNYXJrdXBSZWN0YW5nbGUuanNde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwUmVjdGFuZ2xlfS5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBJZGVudGlmaWVyLCBwb3B1bGF0ZWQgd2l0aCByZXR1cm4gdmFsdWUgb2Yge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZ2V0SWQgZ2V0SWQoKX0uXG4gICAgICogQHBhcmFtIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlfSBlZGl0b3IgLSBNYXJrdXBzIGV4dGVuc2lvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlQXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgZm9yIGN1c3RvbWl6YXRpb24uIFJlbGF0ZWQgdG8ge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjc2V0U3R5bGUgc2V0U3R5bGUoKX0uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFya3VwKGlkLCBlZGl0b3IsIHN0eWxlQXR0cmlidXRlcykge1xuXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50eXBlID0gMDtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMudmlld2VyID0gZWRpdG9yLnZpZXdlcjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt4OiAwLCB5OiAwfTtcbiAgICAgICAgdGhpcy5zaXplID0ge3g6MCwgeTowfTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBuYW1lc3BhY2VVdGlscy5jcmVhdGVTdHlsZShzdHlsZUF0dHJpYnV0ZXMsIHRoaXMudmlld2VyKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb2xvciA9ICcjRkFGRjNDJztcbiAgICAgICAgdGhpcy5jb25zdHJhaW50V2lkdGggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50SGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uc3RyYWludFJvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLmFkZFRyYWl0RXZlbnREaXNwYXRjaGVyKHRoaXMpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQ29uc3RhbnRzXG4gICAgICovXG4gICAgbmFtZXNwYWNlLk1BUktVUF9UWVBFX0FSUk9XID0gMTtcbiAgICBuYW1lc3BhY2UuTUFSS1VQX1RZUEVfVEVYVCA9IDI7XG4gICAgbmFtZXNwYWNlLk1BUktVUF9UWVBFX1JFQ1RBTkdMRSA9IDM7XG4gICAgbmFtZXNwYWNlLk1BUktVUF9UWVBFX0NJUkNMRSA9IDQ7XG4gICAgbmFtZXNwYWNlLk1BUktVUF9UWVBFX0NMT1VEID0gNTtcbiAgICBuYW1lc3BhY2UuTUFSS1VQX1RZUEVfRlJFRUhBTkQgPSA2O1xuXG4gICAgbmFtZXNwYWNlLk1BUktVUF9FWFBPUlRfVFlQRV9MQUJFTCA9ICdMYWJlbCc7XG4gICAgbmFtZXNwYWNlLk1BUktVUF9FWFBPUlRfVFlQRV9BUlJPVyA9ICdBcnJvdyc7XG4gICAgbmFtZXNwYWNlLk1BUktVUF9FWFBPUlRfVFlQRV9SRUNUQU5HTEUgPSAnUmVjdGFuZ2xlJztcbiAgICBuYW1lc3BhY2UuTUFSS1VQX0VYUE9SVF9UWVBFX0NJUkNMRSA9ICdDaXJjbGUnO1xuICAgIG5hbWVzcGFjZS5NQVJLVVBfRVhQT1JUX1RZUEVfQ0xPVUQgPSAnQ2xvdWQnO1xuICAgIG5hbWVzcGFjZS5NQVJLVVBfRVhQT1JUX1RZUEVfRlJFRUhBTkQgPSAnRnJlZWhhbmQnO1xuXG4gICAgLypcbiAgICAgKiBFdmVudCB0eXBlc1xuICAgICAqL1xuICAgIG5hbWVzcGFjZS5FVkVOVF9FRElUTU9ERV9DSEFOR0VEID0gXCJFVkVOVF9FRElUTU9ERV9DSEFOR0VEXCI7XG5cbiAgICBuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX1NFTEVDVEVEID0gXCJFVkVOVF9NQVJLVVBfU0VMRUNURURcIjtcbiAgICBuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX0RSQUdHSU5HID0gXCJFVkVOVF9NQVJLVVBfRFJBR0dJTkdcIjtcbiAgICBuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX0VOVEVSX0VESVRJT04gPSBcIkVWRU5UX01BUktVUF9FTlRFUl9FRElUSU9OXCI7XG4gICAgbmFtZXNwYWNlLkVWRU5UX01BUktVUF9DQU5DRUxfRURJVElPTiA9IFwiRVZFTlRfTUFSS1VQX0NBTkNFTF9FRElUSU9OXCI7XG4gICAgbmFtZXNwYWNlLkVWRU5UX01BUktVUF9ERUxFVEVfRURJVElPTiA9IFwiRVZFTlRfTUFSS1VQX0RFTEVURV9FRElUSU9OXCI7XG5cbiAgICB2YXIgcHJvdG8gPSBNYXJrdXAucHJvdG90eXBlO1xuICAgIG5hbWVzcGFjZS5NYXJrdXAgPSBNYXJrdXA7XG5cbiAgICBwcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIChkZWVwLWNvcHkpIHRoZSBtYXJrdXAuIFVzZWQgaW50ZXJuYWxseSBieSB0aGUgY29weS9jdXQvcGFzdGUgbWVjaGFuaXNtIGluXG4gICAgICoge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUgTWFya3Vwc0NvcmV9LlxuICAgICAqXG4gICAgICogQHJldHVybnMge0F1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwfSBjbG9uZSBvZiB0aGUgY3VycmVudCBtYXJrdXBcbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMuX19wcm90b19fKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlcyA9IHRoaXMuZ2V0Q2xvbmVPdmVycmlkZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcblxuICAgICAgICAgICAgaWYoIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1lbWJlciA9IHRoaXNbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIElzIHRoZXJlIGFuIG92ZXJyaWRlIGZvciB0aGlzIG1lbWJlcj9cbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWVtYmVyIGhhcyBhIGNsb25lIGZ1bmN0aW9uP1xuICAgICAgICAgICAgaWYgKG1lbWJlclsnY2xvbmUnXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVbbmFtZV0gPSBtZW1iZXIuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSXMgaXQgYSBmdW5jdGlvbj9cbiAgICAgICAgICAgIGlmIChtZW1iZXIgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGNsb25lW25hbWVdID0gbWVtYmVyLmJpbmQoY2xvbmUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJcyBpdCBhbiBodG1sIG5vZGU/XG4gICAgICAgICAgICBpZiAobWVtYmVyLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVbbmFtZV0gPSBtZW1iZXIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdXN0IGEgcGxhaW4gb2JqZWN0P1xuICAgICAgICAgICAgaWYgKG1lbWJlciBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNsb25lW25hbWVdID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZW1iZXIpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT2ssIGl0IHNlZW1zIGl0J3MganVzdCBhIHByaW1pdGl2ZSB0eXBlLlxuICAgICAgICAgICAgY2xvbmVbbmFtZV0gPSBtZW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZS5iaW5kRG9tRXZlbnRzKCk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IGJ5XG4gICAgICoge0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwI2Nsb25lIGNsb25lKCl9LFxuICAgICAqIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGF2b2lkIGNsb25pbmcgc3BlY2lmaWMgYXR0cmlidXRlcy48YnI+XG4gICAgICogRGV2ZWxvcGVycyBvbmx5IG5lZWQgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2Qgd2hlbiBjcmVhdGluZyBuZXcgTWFya3VwIHR5cGVzLlxuICAgICAqIFdoZW4gb3ZlcnJpZGluZywgZmlyc3QgY2FsbCB0aGUgc3VwZXIoKSBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlbiBpbmNsdWRlIGFkZGl0aW9uYWwgYXR0cmlidXRlL3ZhbHVlIHBhaXJzIHRvIGl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbnRhaW5pbmcgYXR0cmlidXRlcyB0aGF0IG5lZWQgbm90IHRvIGJlIGNsb25lZC5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuZ2V0Q2xvbmVPdmVycmlkZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlld2VyOiB0aGlzLnZpZXdlcixcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBoYW1tZXI6IG51bGwsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHt9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IHRvIHNlbGVjdCBhIG1hcmt1cC48YnI+XG4gICAgICogRmlyZXMgZXZlbnQgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FVkVOVF9NQVJLVVBfU0VMRUNURUQuXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXAucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgICAgICB0aGlzLmZpcmVFdmVudCh7dHlwZTogbmFtZXNwYWNlLkVWRU5UX01BUktVUF9TRUxFQ1RFRCwgbWFya3VwOiB0aGlzfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBzaWduYWwgdGhhdCB0aGUgY3VycmVudCBtYXJrdXAgaGFzIGJlZW4gdW5zZWxlY3RlZC48YnI+XG4gICAgICogTm8gZXZlbnQgaXMgZmlyZWQuXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXAucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBwcm90by5oaWdobGlnaHQgPSBmdW5jdGlvbihoaWdobGlnaHQpIHtcblxuICAgICAgICBpZiAodGhpcy5pbnRlcmFjdGlvbnNEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IGhpZ2hsaWdodDtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFya3VwJ3Mgc3R5bGUuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZSh0aGlzLnN0eWxlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBpbnRlcm5hbGx5IHRvIHNldCB0aGUgc3R5bGUgb2JqZWN0LiBUcmlnZ2VycyBhIHJlLXJlbmRlciBvZiB0aGUgbWFya3VwIChTdmcpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIC0gRGljdGlvbmFyeSB3aXRoIGtleS92YWx1ZSBwYWlyc1xuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlVXRpbHMuY29weVN0eWxlKHN0eWxlLCB0aGlzLnN0eWxlKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYW5kIGltcGxlbWVudGVkIGJ5IHNwZWNpZmljIE1hcmt1cCB0eXBlcyB0byByZW5kZXIgdGhlbXNlbHZlcyBhcyBTdmcuXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXAucHJvdG90eXBlLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBub3RpZnkgdGhlIG1hcmt1cCB0aGF0IGl0IGlzIG5vIGxvbmdlciBiZWluZyBkcmFnZ2VkIChtb3ZlZCkuPGJyPlxuICAgICAqIEZpcmVzIGV2ZW50IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuRVZFTlRfTUFSS1VQX0RSQUdHSU5HLlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwLnByb3RvdHlwZS5maW5pc2hEcmFnZ2luZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHt0eXBlOiBuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX0RSQUdHSU5HLCBtYXJrdXA6IHRoaXMsIGRyYWdnaW5nOiBmYWxzZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gbm90aWZ5IHRoZSBtYXJrdXAgdGhhdCBpdCBpcyBub3cgYmVpbmcgZWRpdGVkLjxicj5cbiAgICAgKiBGaXJlcyBldmVudCBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVWRU5UX01BUktVUF9FTlRFUl9FRElUSU9OLlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoe3R5cGU6IG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfRU5URVJfRURJVElPTiwgbWFya3VwOiB0aGlzfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBzaWduYWwgdGhhdCBpdCBpcyBubyBsb25nZXIgYmVpbmcgZWRpdGVkLjxicj5cbiAgICAgKiBGaXJlcyBldmVudCBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVWRU5UX01BUktVUF9DQU5DRUxfRURJVElPTi5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoe3R5cGU6IG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfQ0FOQ0VMX0VESVRJT04sIG1hcmt1cDogdGhpc30pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gc2lnbmFsIHRoYXQgdGhlIG1hcmt1cCBpcyBiZWluZyBkZWxldGVkLjxicj5cbiAgICAgKiBGaXJlcyBldmVudCBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVWRU5UX01BUktVUF9ERUxFVEVfRURJVElPTi5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuZGVsZXRlTWFya3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5maXJlRXZlbnQoe3R5cGU6IG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfREVMRVRFX0VESVRJT04sIG1hcmt1cDogdGhpc30pO1xuICAgIH07XG5cbiAgICBwcm90by5zZXRQYXJlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICB9O1xuXG4gICAgcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSB0byBnZXQgdGhlIHtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRNb2RlIEVkaXRNb2RlfVxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBNYXJrdXAuPGJyPlxuICAgICAqIEltcGxlbWVudGVkIGJ5IGNsYXNzZXMgZXh0ZW5kaW5nIHRoaXMgb25lLlxuICAgICAqIEByZXR1cm5zIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRNb2RlfVxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwLnByb3RvdHlwZS5nZXRFZGl0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignRWRpdE1vZGUgb2YgbWFya3VwIHR5cGUnICsgbmFtZXNwYWNlVXRpbHMuZ2V0VHlwZVN0cmluZyh0aGlzLnR5cGUpICsgJyBub3QgZGVmaW5lZC4nICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gZ2V0IHRoZSBtYXJrdXAncyBwb3NpdGlvbiBpbiBicm93c2VyIHBpeGVsIHNwYWNlLjxicj5cbiAgICAgKiBOb3RpY2UgdGhhdCAoMCwwKSBpcyB0b3AgbGVmdC48YnI+XG4gICAgICogU2VlIGFsc29cbiAgICAgKiBbZ2V0Q2xpZW50U2l6ZSgpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cCNnZXRDbGllbnRTaXplfS5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuZ2V0Q2xpZW50UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IucG9zaXRpb25Gcm9tTWFya3Vwc1RvQ2xpZW50KHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gZ2V0IHRoZSBtYXJrdXAncyBib3VuZGluZyByZWN0IGluIGJyb3dzZXIgcGl4ZWwgc3BhY2UuPGJyPlxuICAgICAqIFNlZSBhbHNvXG4gICAgICogW2dldENsaWVudFBvc2l0aW9uKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwI2dldENsaWVudFBvc2l0aW9ufS5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cC5wcm90b3R5cGUuZ2V0Q2xpZW50U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnNpemVGcm9tTWFya3Vwc1RvQ2xpZW50KHNpemUueCwgc2l6ZS55KTtcbiAgICB9O1xuXG4gICAgcHJvdG8uc2V0Um90YXRpb24gPSBmdW5jdGlvbihhbmdsZSkge1xuXG4gICAgfTtcblxuICAgIHByb3RvLmdldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0aW9uO1xuICAgIH07XG5cbiAgICBwcm90by5zZXRTaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHNpemUpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5pc1dpZHRoQ29uc3RyYWluZWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50V2lkdGg7XG4gICAgfTtcblxuICAgIHByb3RvLmlzSGVpZ2h0Q29uc3RyYWluZWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50SGVpZ2h0O1xuICAgIH07XG5cbiAgICBwcm90by5pc1JvdGF0aW9uQ29uc3RyYWluZWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50Um90YXRpb247XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGlzYWJsZSBoaWdobGlnaHQgb24gYW5ub3RhdGlvbnMgd2hpbGUgYSBuZXcgYW5ub3RhdGlvbiBpcyBiZWluZyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZSAtIFdoZXRoZXIgKG1vdXNlKSBpbnRlcmFjdGlvbnMgYXJlIGVuYWJsZS5cbiAgICAgKi9cbiAgICBwcm90by5kaXNhYmxlSW50ZXJhY3Rpb25zID0gZnVuY3Rpb24oZGlzYWJsZSkge1xuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25zRGlzYWJsZWQgPSBkaXNhYmxlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqL1xuICAgIHByb3RvLnNldFN0cm9rZVdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5jb25zdHJhaW5zVG9Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuZWRpdEZyYW1lLnN0YXJ0RHJhZygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBieSBleHRlbmRpbmcgY2xhc3Nlcy48YnI+XG4gICAgICogR2V0cyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuXG4gICAgICogW2dlbmVyYXRlRGF0YSgpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2dlbmVyYXRlRGF0YX1cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxFbGVtZW50fSAtIEVpdGhlciBudWxsIChkZWZhdWx0KSBvciB0aGUgbWV0YWRhdGEgU3ZnIG5vZGVcbiAgICAgKi9cbiAgICBwcm90by5zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsOyAvLyBObyBtZXRhZGF0YSBpcyBpbmplY3RlZCBieSBkZWZhdWx0LlxuICAgIH07XG5cbiAgICBwcm90by5iaW5kVG91Y2hFdmVudHMgPSBmdW5jdGlvbihkb21FbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKGRvbUVsZW1lbnQsIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXJzOiBbXG4gICAgICAgICAgICAgICAgW0hhbW1lci5UYXAsIHsgZXZlbnQ6ICdzaW5nbGV0YXAnLCBwb2ludGVyczogMSwgdGhyZXNob2xkOiAyIH0gXVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0Q2xhc3M6IEhhbW1lci5Ub3VjaElucHV0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25TaW5nbGVUYXBCaW5kZWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bihldmVudCk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW1tZXIub24oXCJzaW5nbGV0YXBcIiwgdGhpcy5vblNpbmdsZVRhcEJpbmRlZCk7XG4gICAgfTtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcmt1cEFycm93KGlkLCBlZGl0b3IpIHtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5NYXJrdXAuY2FsbCh0aGlzLCBpZCwgZWRpdG9yLCBzdHlsZUF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9BUlJPVztcbiAgICAgICAgdGhpcy5jb25zdHJhaW50SGVpZ2h0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBDcmVhdGUgaGVhZCBhbmQgdGFpbC5cbiAgICAgICAgdGhpcy5oZWFkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy50YWlsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5zaXplLnkgPSB0aGlzLnN0eWxlWydzdHJva2Utd2lkdGgnXSAqIDI7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVTVkcoKTtcbiAgICAgICAgdGhpcy5iaW5kRG9tRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgTWFya3VwQXJyb3cucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuTWFya3VwLnByb3RvdHlwZSk7XG4gICAgTWFya3VwQXJyb3cucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFya3VwQXJyb3c7XG5cbiAgICB2YXIgcHJvdG8gPSBNYXJrdXBBcnJvdy5wcm90b3R5cGU7XG5cbiAgICBwcm90by5nZXRFZGl0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgbmFtZXNwYWNlLkVkaXRNb2RlQXJyb3codGhpcy5lZGl0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBET00gZWxlbWVudHMgdXNlciB3aWxsIHNlZSBhbmQgaW50ZXJhY3Qgd2l0aC5cbiAgICAgKi9cbiAgICBwcm90by5jcmVhdGVTVkcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy5zaGFwZSA9IG5hbWVzcGFjZVV0aWxzLmNyZWF0ZVN2Z0VsZW1lbnQoJ3BvbHlnb24nKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uYmluZERvbUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobmFtZXNwYWNlVXRpbHMuaXNUb3VjaERldmljZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRUb3VjaEV2ZW50cyh0aGlzLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKCkgeyB0aGlzLmhpZ2hsaWdodChmYWxzZSk7IH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7IHRoaXMuaGlnaGxpZ2h0KHRydWUpOyB9LmJpbmQodGhpcykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgdmFsdWVzIGluIGNsaWVudCBzcGFjZSBjb29yZGluYXRlcyAoMmQpLlxuICAgICAqIE5vdGljZSB0aGF0IGZvciB0aGUgYXJyb3csIHRoZSB0b3AgbGVmdCBpcyB0aGUgXCJ0YWlsXCIgb2YgdGhlIGFycm93IGFuZFxuICAgICAqIHRoZSBib3R0b20gcmlnaHQgaXMgdGhlIFwiaGVhZFwiIG9mIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhPIC0gdGFpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5TyAtIHRhaWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geEYgLSBoZWFkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlGIC0gaGVhZFxuICAgICAqL1xuICAgIHByb3RvLnNldCA9IGZ1bmN0aW9uICh4TywgeU8sIHhGLCB5Rikge1xuXG4gICAgICAgIHZhciB2TyA9IG5ldyBUSFJFRS5WZWN0b3IyKHhPLCB5Tyk7XG4gICAgICAgIHZhciB2RiA9IG5ldyBUSFJFRS5WZWN0b3IyKHhGLCB5Rik7XG4gICAgICAgIHZhciB2RGlyID0gdkYuY2xvbmUoKS5zdWIodk8pLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMuc2l6ZS54ID0gdk8uZGlzdGFuY2VUbyh2Rik7IC8vIFRPRE86IENsYW1wIG1pbiBsZW5ndGhcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IE1hdGguYWNvcyh2RGlyLmRvdChuZXcgVEhSRUUuVmVjdG9yMigxLDApKSk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSB5RiA+IHlPID8gKE1hdGguUEkqMiktdGhpcy5yb3RhdGlvbiA6IHRoaXMucm90YXRpb247XG5cbiAgICAgICAgdGhpcy5oZWFkLnNldCh4TywgeU8sIDApO1xuICAgICAgICB0aGlzLnRhaWwuc2V0KHhGLCB5RiwgMCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFya3VwIHRvIHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBUaGlzIGdldHMgY2FsbGVkIGJ5IHRoZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlNldFJvdGF0aW9uIGVkaXQgYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBwcm90by5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGFuZ2xlO1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBtYXJrdXAuXG4gICAgICogVGhpcyBnZXRzIGNhbGxlZCBieSB0aGUgbmFtZXNwYWNlLlNldFNpemUgZWRpdCBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvc2l0aW9uIC0gYXJyb3cncyBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBBcnJvdydzIGxlbmd0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBXZSBpZ25vcmUgdGhpcyBvbmUgYmVjYXVzZSB3ZSB1c2UgdGhlIGFycm93J3Mgc3Ryb2tlIHdpZHRoIGluc3RlYWRcbiAgICAgKi9cbiAgICBwcm90by5zZXRTaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgeEYgPSBNYXRoLmNvcyh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHlGID0gTWF0aC5zaW4odGhpcy5yb3RhdGlvbik7XG4gICAgICAgIHZhciB2RkRpciA9IG5ldyBUSFJFRS5WZWN0b3IyKHhGLCB5Rik7IC8vIGFscmVhZHkgbm9ybWFsaXplZFxuICAgICAgICB2RkRpci5tdWx0aXBseVNjYWxhcih3aWR0aCowLjUpO1xuXG4gICAgICAgIHZhciB2Q2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIHZhciB2TyA9IHZDZW50ZXIuY2xvbmUoKS5hZGQodkZEaXIpO1xuICAgICAgICB2YXIgdkYgPSB2Q2VudGVyLmNsb25lKCkuc3ViKHZGRGlyKTtcblxuICAgICAgICB0aGlzLmhlYWQuc2V0KHZGLngsIHZGLnksIDApO1xuICAgICAgICB0aGlzLnRhaWwuc2V0KHZPLngsIHZPLnksIDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLnNpemUueCA9IHdpZHRoO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIDNkIHBvc2l0aW9ucyBmb3IgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCwgaXQgcmVjYWxjdWxhdGVzXG4gICAgICogYWxsIHRoZSAyZCB2YWx1ZXMgaW4gY2xpZW50IHNwYWNlLlxuICAgICAqL1xuICAgIHByb3RvLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICAgICAgICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcbiAgICAgICAgdmFyIG1pZF94ID0gdGhpcy5zaXplLnggKiAwLjU7XG4gICAgICAgIHZhciBtaWRfeSA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgcG9zX3ggPSAoaGVhZC54ICsgdGFpbC54KSAqIDAuNTtcbiAgICAgICAgdmFyIHBvc195ID0gKGhlYWQueSArIHRhaWwueSkgKiAwLjU7XG5cbiAgICAgICAgLy8gVXNlZCBieSB1cGRhdGVTdHlsZSgpXG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3ZnID0gW1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnLCBwb3NfeCwgJywnLCBwb3NfeSwgJykgJyxcbiAgICAgICAgICAgICdyb3RhdGUoJywgbmFtZXNwYWNlVXRpbHMucmFkaWFuc1RvRGVncmVlcygtdGhpcy5yb3RhdGlvbiksICcpICcsXG4gICAgICAgICAgICAndHJhbnNsYXRlKCcsIC1taWRfeCwgJywnLCAtbWlkX3ksICcpICdcbiAgICAgICAgXS5qb2luKCcnKTtcblxuICAgICAgICAvLyBVcGRhdGUgdmFsdWVzIHVzZWQgYnkgRWRpdEZyYW1lIGFuZCBVbmRvL1JlZG8gc3lzdGVtIC8vXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHRhaWwueCArIChoZWFkLnggLSB0YWlsLngpICogMC41O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB0YWlsLnkgKyAoaGVhZC55IC0gdGFpbC55KSAqIDAuNTtcbiAgICB9O1xuXG4gICAgcHJvdG8udXBkYXRlU3R5bGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBVcGRhdGUgc2l6ZSBhbmQgdHJhbnNmb3JtLFxuICAgICAgICB0aGlzLnNpemUueSA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddICogMjtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcblxuICAgICAgICAvLyBVcGRhdGUgc3R5bGUuXG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuaGlnaGxpZ2h0ZWQgPyB0aGlzLmhpZ2hsaWdodENvbG9yIDogdGhpcy5zdHlsZVsnc3Ryb2tlLWNvbG9yJ107XG5cbiAgICAgICAgdmFyIHBvbHlnb25Qb2ludHMgPSB0aGlzLmdldFBvbHlnb25Qb2ludHMoKTtcbiAgICAgICAgLy8gVHJhbnNmb3JtIHBvaW50cyBpbnRvIFNWRyBjb21wbGlhbnQgZm9ybWF0XG4gICAgICAgIC8vIE1lYW5pbmc6ICd4MSx5MSB4Mix5MiAuLi4geDgseTggeDkseTknXG4gICAgICAgIHZhciBtYXBwZWRQb2ludHMgPSBwb2x5Z29uUG9pbnRzLm1hcChmdW5jdGlvbihwb2ludCl7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRbMF0rJywnK3BvaW50WzFdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBvbHlnb25TdHIgPSBtYXBwZWRQb2ludHMuam9pbignICcpOyAvLyBMZWF2ZSBhIHNwYWNlIGJldHdlZW4gcG9pbnRzXG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKCdwb2ludHMnLCBwb2x5Z29uU3RyKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGhpcy50cmFuc2Zvcm1TdmcpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHN0cm9rZUNvbG9yKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLnN0eWxlWydzdHJva2Utb3BhY2l0eSddKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbGlzdCBvZiBwb2ludHMgdGhhdCBjb21wb3NlIHRoZSBhcnJvdydzIHZpc3VhbHNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gV2hlcmUgZWFjaCBlbGVtZW50IGlzIGFuIGFycmF5IHdpdGggMiB2YWx1ZXM6IFt4LCB5XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uZ2V0UG9seWdvblBvaW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRvIGJ1aWxkIHRoZSBhcnJvdyB3ZSBuZWVkIDcgcG9pbnRzIGluIHRvdGFsXG4gICAgICAgIC8vIFRoZSAnZGVmYXVsdCcgYXJyb3cgYnVpbHQgaGVyZSBoYXMgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJpc3RpY3M6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIEl0IGlzIGJ1aWx0IGhvcml6b250YWxseSBmYWNpbmcgcmlnaHRcbiAgICAgICAgLy8gMi4gSXQncyBib3VuZGluZyByZWN0YW5nbGUgaGFzIGxlbmd0aDogdGhpcy5zaXplLnhcbiAgICAgICAgLy8gMy4gSXQncyBib3VuZGluZyByZWN0YW5nbGUgaGFzIGhlaWdodDogMiAqIHRoaXMuc3Ryb2tlV2lkdGhcbiAgICAgICAgLy8gNC4gVGhlIGFycm93IHRhaWwncyB0aGlja25lc3MgaXM6IHRoaXMuc3Ryb2tlV2lkdGhcbiAgICAgICAgLy8gNS4gVGhlIGFycm93IGhlYWQncyBsZW5ndGggaXM6IDIvMyBvZiAocG9pbnQgMylcbiAgICAgICAgLy8gNi4gVGhlIGFycm93IGhlYWQncyB0aGlja25lc3MgaXM6IChwb2ludCAzKVxuICAgICAgICAvLyA3LiBUaGUgYXJyb3cgZ2VuZXJhdGVkIGlzIGNlbnRlcmVkIGluIGl0cyBsb2NhbCAoMCwwKSwgbWVhbmluZyB0aGF0XG4gICAgICAgIC8vICAgIHR3byBwb2ludHMgYXJlIHBsYWNlZCB3aXRoIG5lZ2F0aXZlIHggdmFsdWVzLCBhbmQgYWxsIG90aGVyIGhhdmVcbiAgICAgICAgLy8gICAgcG9zaXRpdmUgeCB2YWx1ZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMylcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBcXFxuICAgICAgICAvLyAgICAgICAgICAgICAoMSktLS0tLS0tLS0tLS0tKDIpICAgXFxcbiAgICAgICAgLy8gICAgICAgICAgICAgIHwgICAgICAgICAoMCkgICAgICAgICg0KVxuICAgICAgICAvLyAgICAgICAgICAgICAoNyktLS0tLS0tLS0tLS0tKDYpICAgL1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIC9cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICg1KVxuICAgICAgICAvL1xuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgaGFsZl9sZW4gPSB0aGlzLnNpemUueCAqIDAuNTtcbiAgICAgICAgdmFyIHRoaWNrbmVzcyA9IHN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgaGFsZl90aGlja25lc3MgPSBzdHJva2VXaWR0aCAqIDAuNTtcbiAgICAgICAgdmFyIGhlYWRfbGVuID0gaGFsZl9sZW4gLSAoMS4yICogdGhpY2tuZXNzKTtcblxuICAgICAgICAvLyBMZWZ0IHNpZGUgcG9pbnRzXG4gICAgICAgIHZhciBwMSA9IFsgLWhhbGZfbGVuLCAtaGFsZl90aGlja25lc3MgXTtcbiAgICAgICAgdmFyIHA3ID0gWyAtaGFsZl9sZW4sICBoYWxmX3RoaWNrbmVzcyBdO1xuXG4gICAgICAgIC8vIFRoZSB0aXBcbiAgICAgICAgdmFyIHA0ID0gWyBoYWxmX2xlbiwgMF07XG5cbiAgICAgICAgLy8gUmlnaHQgc2lkZSBwb2ludHMgKGZyb20gdG9wIHRvIGJvdHRvbSlcbiAgICAgICAgdmFyIHAzID0gWyBoZWFkX2xlbiwgLXRoaWNrbmVzcyBdO1xuICAgICAgICB2YXIgcDIgPSBbIGhlYWRfbGVuLCAtaGFsZl90aGlja25lc3MgXTtcbiAgICAgICAgdmFyIHA2ID0gWyBoZWFkX2xlbiwgIGhhbGZfdGhpY2tuZXNzIF07XG4gICAgICAgIHZhciBwNSA9IFsgaGVhZF9sZW4sICB0aGlja25lc3MgXTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW3AxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3XTtcblxuICAgICAgICAvLyBUT0RPOiBUaGUgY3JlYXRlZCBhcnJvdyBzaG91bGQgaGF2ZSBpdHMgKDAsMCkgb24gdGhlIHRvcCBsZWZ0XG4gICAgICAgIC8vIFRPRE86IFRoaXMgd2FzIGFuIG92ZXJzaWdodCwgYW5kIGZvciBub3cgd2UgZml4IGl0IGJ5IG9mZnNldHRpbmcgYmVmb3JlIHJldHVybmluZy5cbiAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHBvaW50WzBdICs9IGhhbGZfbGVuO1xuICAgICAgICAgICAgcG9pbnRbMV0gKz0gdGhpY2tuZXNzO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHBhcmVudCBsYXllciB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIG1hcmt1cC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgKi9cbiAgICBwcm90by5zZXRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG5cbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGRpdi5wYXJlbnROb2RlICYmIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgRWRpdEZyYW1lIHRvIG1vdmUgdGhlIG1hcmt1cCBpbiBDbGllbnQgU3BhY2UgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIE5ldyBYIGxvY2F0aW9uIGZvciB0aGUgbWFya3VwLiBOb3RpY2UgdGhhdCBtYXJrdXBzIGFyZSBjZW50ZXJlZCBvbiB0aGlzIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gTmV3IFkgbG9jYXRpb24gZm9yIHRoZSBtYXJrdXAuIE5vdGljZSB0aGF0IG1hcmt1cHMgYXJlIGNlbnRlcmVkIG9uIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuXG4gICAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICAgICAgICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcblxuICAgICAgICB2YXIgZHggPSBoZWFkLnggLSB0YWlsLng7XG4gICAgICAgIHZhciBkeSA9IGhlYWQueSAtIHRhaWwueTtcblxuICAgICAgICB2YXIgeG8gPSB4IC0gZHggKiAwLjU7XG4gICAgICAgIHZhciB5byA9IHkgLSBkeSAqIDAuNTtcblxuICAgICAgICBoZWFkLnggPSB4bztcbiAgICAgICAgaGVhZC55ID0geW87XG5cbiAgICAgICAgdGFpbC54ID0geG8gKyBkeDtcbiAgICAgICAgdGFpbC55ID0geW8gKyBkeTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIHByb3RvLmNyZWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcblxuICAgIHByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLnNldFBhcmVudChudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYm91bmRzXG4gICAgICovXG4gICAgcHJvdG8uY29uc3RyYWluc1RvQm91bmRzID0gZnVuY3Rpb24gKGJvdW5kcykge1xuXG4gICAgfTtcblxuICAgIHByb3RvLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBtZXRhZGF0YS50eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBtZXRhZGF0YS5oZWFkID0gW3RoaXMuaGVhZC54LCB0aGlzLmhlYWQueV0uam9pbihcIiBcIik7XG4gICAgICAgIG1ldGFkYXRhLnRhaWwgPSBbdGhpcy50YWlsLngsIHRoaXMudGFpbC55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEucm90YXRpb24gPSBTdHJpbmcodGhpcy5yb3RhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZVV0aWxzLmFkZE1hcmt1cE1ldGFkYXRhKHRoaXMuc2hhcGUsIG1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgcHJvdG8ucmVuZGVyVG9DYW52YXMgPSBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLnN0eWxlWydzdHJva2Utd2lkdGgnXTtcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gdGhpcy5zdHlsZVsnc3Ryb2tlLWNvbG9yJ107XG4gICAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHlsZVsnc3Ryb2tlLW9wYWNpdHknXTtcblxuICAgICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZDtcbiAgICAgICAgdmFyIHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgICAgIHZhciBtaWRfeCA9IHRoaXMuc2l6ZS54ICogMC41O1xuICAgICAgICB2YXIgbWlkX3kgPSBzdHJva2VXaWR0aDtcbiAgICAgICAgdmFyIHBvc194ID0gKGhlYWQueCArIHRhaWwueCkgKiAwLjU7XG4gICAgICAgIHZhciBwb3NfeSA9IChoZWFkLnkgKyB0YWlsLnkpICogMC41O1xuICAgICAgICB2YXIgY2xpZW50TWlkID0gdGhpcy5lZGl0b3IucG9zaXRpb25Gcm9tTWFya3Vwc1RvQ2xpZW50KG1pZF94LCBtaWRfeSk7XG4gICAgICAgIHZhciBjbGllbnRQb3MgPSB0aGlzLmVkaXRvci5wb3NpdGlvbkZyb21NYXJrdXBzVG9DbGllbnQocG9zX3gsIHBvc195KTtcbiAgICAgICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oLWNsaWVudE1pZC54LCAtY2xpZW50TWlkLnksIDApO1xuICAgICAgICB2YXIgbTIgPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvbloodGhpcy5yb3RhdGlvbik7XG4gICAgICAgIHZhciBtMyA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKGNsaWVudFBvcy54LCBjbGllbnRQb3MueSwgMCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtMy5tdWx0aXBseShtMikubXVsdGlwbHkobTEpO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvbHlnb25Qb2ludHMoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KXtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRbMF0sIHkgPSBwb2ludFsxXTtcbiAgICAgICAgICAgIHZhciBjbGllbnQgPSB0aGF0LmVkaXRvci5wb3NpdGlvbkZyb21NYXJrdXBzVG9DbGllbnQoeCwgeSk7XG4gICAgICAgICAgICBjbGllbnQgPSBjbGllbnQuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNsaWVudC54LCBjbGllbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuTWFya3VwQXJyb3cgPSBNYXJrdXBBcnJvdztcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcmt1cENpcmNsZShpZCwgZWRpdG9yKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZS1jb2xvcicsICdzdHJva2Utb3BhY2l0eScsICdmaWxsLWNvbG9yJywgJ2ZpbGwtb3BhY2l0eSddO1xuICAgICAgICBuYW1lc3BhY2UuTWFya3VwLmNhbGwodGhpcywgaWQsIGVkaXRvciwgc3R5bGVBdHRyaWJ1dGVzKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBuYW1lc3BhY2UuTUFSS1VQX1RZUEVfQ0lSQ0xFO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHKCk7XG4gICAgICAgIHRoaXMuYmluZERvbUV2ZW50cygpO1xuICAgIH1cblxuICAgIE1hcmt1cENpcmNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5NYXJrdXAucHJvdG90eXBlKTtcbiAgICBNYXJrdXBDaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFya3VwQ2lyY2xlO1xuXG4gICAgdmFyIHByb3RvID0gTWFya3VwQ2lyY2xlLnByb3RvdHlwZTtcblxuICAgIHByb3RvLmdldEVkaXRNb2RlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBuYW1lc3BhY2UuRWRpdE1vZGVDaXJjbGUodGhpcy5lZGl0b3IpO1xuICAgIH07XG5cbiAgICBwcm90by5jcmVhdGVTVkcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5hbWVzcGFjZVV0aWxzLmNyZWF0ZVN2Z0VsZW1lbnQoJ2VsbGlwc2UnKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uYmluZERvbUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobmFtZXNwYWNlVXRpbHMuaXNUb3VjaERldmljZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRUb3VjaEV2ZW50cyh0aGlzLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKXsgdGhpcy5oaWdobGlnaHQoZmFsc2UpOyB9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXsgdGhpcy5oaWdobGlnaHQodHJ1ZSk7IH0uYmluZCh0aGlzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCB2YWx1ZXMgaW4gY2xpZW50IHNwYWNlIGNvb3JkaW5hdGVzICgyZCkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICAgKi9cbiAgICBwcm90by5zZXQgPSBmdW5jdGlvbihwb3NpdGlvbiwgc2l6ZSkge1xuXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwOyAvLyBSZXNldCBhbmdsZSAvL1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuc2l6ZS54ID0gc2l6ZS54O1xuICAgICAgICB0aGlzLnNpemUueSA9IHNpemUueTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSAzZCBwb3NpdGlvbnMgZm9yIHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQsIGl0IHJlY2FsY3VsYXRlc1xuICAgICAqIGFsbCB0aGUgMmQgdmFsdWVzIGluIGNsaWVudCBzcGFjZS5cbiAgICAgKi9cbiAgICBwcm90by51cGRhdGVUcmFuc2Zvcm1NYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG5cbiAgICAgICAgdmFyIG9yaWdpblggPSBNYXRoLm1heCh0aGlzLnNpemUueCAtIHN0cm9rZVdpZHRoLCAwKSAqIDAuNTtcbiAgICAgICAgdmFyIG9yaWdpblkgPSBNYXRoLm1heCh0aGlzLnNpemUueSAtIHN0cm9rZVdpZHRoLCAwKSAqIDAuNTtcblxuICAgICAgICB0aGlzLnRyYW5zZm9ybVN2ZyA9IFtcbiAgICAgICAgICAgICd0cmFuc2xhdGUoJywgdGhpcy5wb3NpdGlvbi54LCAnLCcsIHRoaXMucG9zaXRpb24ueSwgJykgJyxcbiAgICAgICAgICAgICdyb3RhdGUoJywgbmFtZXNwYWNlVXRpbHMucmFkaWFuc1RvRGVncmVlcygtdGhpcy5yb3RhdGlvbiksICcpICcsXG4gICAgICAgICAgICAndHJhbnNsYXRlKCcsIC1vcmlnaW5YLCAnLCcsIC1vcmlnaW5ZLCAnKSAnXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZGF0YSB2YWx1ZXMgaW50byBET00gZWxlbWVudCBzdHlsZS9hdHRyaWJ1dGUocylcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RvLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLnN0eWxlWydzdHJva2Utd2lkdGgnXTtcbiAgICAgICAgdmFyIHN0cm9rZUNvbG9yID0gdGhpcy5oaWdobGlnaHRlZCA/IHRoaXMuaGlnaGxpZ2h0Q29sb3IgOiB0aGlzLnN0eWxlWydzdHJva2UtY29sb3InXTtcbiAgICAgICAgdmFyIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0eWxlWydzdHJva2Utb3BhY2l0eSddO1xuICAgICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5zdHlsZVsnZmlsbC1jb2xvciddO1xuICAgICAgICB2YXIgZmlsbE9wYWNpdHkgPSB0aGlzLnN0eWxlWydmaWxsLW9wYWNpdHknXTtcblxuICAgICAgICB2YXIgcmFkX3ggPSBNYXRoLm1heCh0aGlzLnNpemUueCAtIHN0cm9rZVdpZHRoLCAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHJhZF95ID0gTWF0aC5tYXgodGhpcy5zaXplLnkgLSBzdHJva2VXaWR0aCwgMCkgKiAwLjU7XG5cbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGhpcy50cmFuc2Zvcm1TdmcpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBzdHJva2VXaWR0aCk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KSk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKCdmaWxsJywgbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoZmlsbENvbG9yLCBmaWxsT3BhY2l0eSkpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnY3gnLCByYWRfeCk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKCdjeScsIHJhZF95KTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ3J4JywgcmFkX3gpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgncnknLCByYWRfeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgcGFyZW50IGxheWVyIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgbWFya3VwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgICAqL1xuICAgIHByb3RvLnNldFBhcmVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICAgIHZhciBkaXYgPSB0aGlzLnNoYXBlO1xuICAgICAgICBkaXYucGFyZW50Tm9kZSAmJiBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHJvdGF0aW9uIG9mIHRoZSBtYXJrdXAgdG8gdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIFRoaXMgZ2V0cyBjYWxsZWQgYnkgdGhlIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuU2V0Um90YXRpb24gZWRpdCBhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHByb3RvLnNldFJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUpIHtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gYW5nbGU7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIG1hcmt1cC5cbiAgICAgKiBUaGlzIGdldHMgY2FsbGVkIGJ5IHRoZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlNldFNpemUgZWRpdCBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHByb3RvLnNldFNpemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLnNpemUueCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemUueSA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgdGhlIEVkaXRGcmFtZSB0byBtb3ZlIHRoZSBtYXJrdXAgaW4gQ2xpZW50IFNwYWNlIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBOZXcgWCBsb2NhdGlvbiBmb3IgdGhlIG1hcmt1cC4gTm90aWNlIHRoYXQgbWFya3VwcyBhcmUgY2VudGVyZWQgb24gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIE5ldyBZIGxvY2F0aW9uIGZvciB0aGUgbWFya3VwLiBOb3RpY2UgdGhhdCBtYXJrdXBzIGFyZSBjZW50ZXJlZCBvbiB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCx5KSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgdGhhdCB0aGUgbWFya3VwIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBwcm90by5jcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgLy9cbiAgICB9O1xuXG4gICAgcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQobnVsbCk7XG4gICAgfTtcblxuICAgIHByb3RvLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBtZXRhZGF0YS50eXBlID0gXCJlbGxpcHNlXCI7XG4gICAgICAgIG1ldGFkYXRhLnBvc2l0aW9uID0gW3RoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEuc2l6ZSA9IFt0aGlzLnNpemUueCwgdGhpcy5zaXplLnldLmpvaW4oXCIgXCIpO1xuICAgICAgICBtZXRhZGF0YS5yb3RhdGlvbiA9IFN0cmluZyh0aGlzLnJvdGF0aW9uKTtcblxuICAgICAgICByZXR1cm4gbmFtZXNwYWNlVXRpbHMuYWRkTWFya3VwTWV0YWRhdGEodGhpcy5zaGFwZSwgbWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdHhcbiAgICAgKi9cbiAgICBwcm90by5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIC8vIGVsbGlwc2UgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzLCB0b29rIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbVxuICAgICAgICAvLyBTdGFjayBPdmVyZmxvdzogaHR0cDovL2dvby5nbC82NGVzbm1cbiAgICAgICAgZnVuY3Rpb24gZWxsaXBzZShjdHgsIGN4LCBjeSwgdywgaCkge1xuXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICB2YXIgbHggPSBjeCAtIHcvMixcbiAgICAgICAgICAgICAgICByeCA9IGN4ICsgdy8yLFxuICAgICAgICAgICAgICAgIHR5ID0gY3kgLSBoLzIsXG4gICAgICAgICAgICAgICAgYnkgPSBjeSArIGgvMjtcblxuICAgICAgICAgICAgdmFyIG1hZ2ljID0gMC41NTE3ODQ7XG4gICAgICAgICAgICB2YXIgeG1hZ2ljID0gbWFnaWMqdy8yO1xuICAgICAgICAgICAgdmFyIHltYWdpYyA9IG1hZ2ljKmgvMjtcblxuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjeCx0eSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCt4bWFnaWMsdHkscngsY3kteW1hZ2ljLHJ4LGN5KTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHJ4LGN5K3ltYWdpYyxjeCt4bWFnaWMsYnksY3gsYnkpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3gteG1hZ2ljLGJ5LGx4LGN5K3ltYWdpYyxseCxjeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhseCxjeS15bWFnaWMsY3gteG1hZ2ljLHR5LGN4LHR5KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0eWxlWydzdHJva2UtY29sb3InXTtcbiAgICAgICAgdmFyIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0eWxlWydzdHJva2Utb3BhY2l0eSddO1xuICAgICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5zdHlsZVsnZmlsbC1jb2xvciddO1xuICAgICAgICB2YXIgZmlsbE9wYWNpdHkgPSB0aGlzLnN0eWxlWydmaWxsLW9wYWNpdHknXTtcblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnNpemUueCAtIHN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5zaXplLnkgLSBzdHJva2VXaWR0aDtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmVkaXRvci5zaXplRnJvbU1hcmt1cHNUb0NsaWVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZWRpdG9yLnBvc2l0aW9uRnJvbU1hcmt1cHNUb0NsaWVudCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoc3Ryb2tlQ29sb3IsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoZmlsbENvbG9yLCBmaWxsT3BhY2l0eSk7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmVkaXRvci5zaXplRnJvbU1hcmt1cHNUb0NsaWVudChzdHJva2VXaWR0aCwgMCkueDtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGVsbGlwc2UoY3R4LCAwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICAgIGZpbGxPcGFjaXR5ICE9PSAwICYmIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLk1hcmt1cENpcmNsZSA9IE1hcmt1cENpcmNsZTtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcmt1cENsb3VkKGlkLCBlZGl0b3IpIHtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5JywgJ2ZpbGwtY29sb3InLCAnZmlsbC1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5NYXJrdXAuY2FsbCh0aGlzLCBpZCwgZWRpdG9yLCBzdHlsZUF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9DTE9VRDtcbiAgICAgICAgdGhpcy5saW5lSm9pbnQgPSAncm91bmQnO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHKCk7XG4gICAgICAgIHRoaXMuYmluZERvbUV2ZW50cygpO1xuICAgIH1cblxuICAgIE1hcmt1cENsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLk1hcmt1cC5wcm90b3R5cGUpO1xuICAgIE1hcmt1cENsb3VkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcmt1cENsb3VkO1xuXG4gICAgdmFyIHByb3RvID0gTWFya3VwQ2xvdWQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZ2V0RWRpdE1vZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IG5hbWVzcGFjZS5FZGl0TW9kZUNsb3VkKHRoaXMuZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uY3JlYXRlU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBuYW1lc3BhY2VVdGlscy5jcmVhdGVTdmdFbGVtZW50KCdwYXRoJyk7XG4gICAgfTtcblxuICAgIHByb3RvLmJpbmREb21FdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVV0aWxzLmlzVG91Y2hEZXZpY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kVG91Y2hFdmVudHModGhpcy5zaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKSwgdHJ1ZSApO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpe3RoaXMuaGlnaGxpZ2h0KGZhbHNlKTt9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXt0aGlzLmhpZ2hsaWdodCh0cnVlKTt9LmJpbmQodGhpcykpO1xuICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgcG9zaXRpb24gYW5kIHNpemUgaW4gbWFya3VwIHNwYWNlIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzaXplXG4gICAgICovXG4gICAgcHJvdG8uc2V0ID0gZnVuY3Rpb24ocG9zaXRpb24sIHNpemUpIHtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDsgLy8gUmVzZXQgYW5nbGUgLy9cblxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLnNpemUueCA9IHNpemUueDtcbiAgICAgICAgdGhpcy5zaXplLnkgPSBzaXplLnk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgM2QgcG9zaXRpb25zIGZvciB0b3AtbGVmdCBhbmQgYm90dG9tLXJpZ2h0LCBpdCByZWNhbGN1bGF0ZXNcbiAgICAgKiBhbGwgdGhlIDJkIHZhbHVlcyBpbiBjbGllbnQgc3BhY2UuXG4gICAgICovXG4gICAgcHJvdG8udXBkYXRlVHJhbnNmb3JtTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBvcmlnaW5YID0gKHRoaXMuc2l6ZS54KSAqIDAuNTtcbiAgICAgICAgdmFyIG9yaWdpblkgPSAodGhpcy5zaXplLnkpICogMC41O1xuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3ZnID0gW1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnLCB0aGlzLnBvc2l0aW9uLngsICcsJywgdGhpcy5wb3NpdGlvbi55LCAnKSAnLFxuICAgICAgICAgICAgJ3JvdGF0ZSgnLCBuYW1lc3BhY2VVdGlscy5yYWRpYW5zVG9EZWdyZWVzKC10aGlzLnJvdGF0aW9uKSwgJykgJyxcbiAgICAgICAgICAgICd0cmFuc2xhdGUoJywgLW9yaWdpblgsICcsJywgLW9yaWdpblksICcpICdcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBkYXRhIHZhbHVlcyBpbnRvIERPTSBlbGVtZW50IHN0eWxlL2F0dHJpYnV0ZShzKVxuICAgICAqXG4gICAgICovXG4gICAgcHJvdG8udXBkYXRlU3R5bGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLmhpZ2hsaWdodGVkID8gdGhpcy5oaWdobGlnaHRDb2xvciA6IHRoaXMuc3R5bGVbJ3N0cm9rZS1jb2xvciddO1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLnN0eWxlWydmaWxsLWNvbG9yJ107XG4gICAgICAgIHZhciBmaWxsT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ2ZpbGwtb3BhY2l0eSddO1xuXG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRoaXMudHJhbnNmb3JtU3ZnKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBuYW1lc3BhY2VVdGlscy5jb21wb3NlUkdCQVN0cmluZyhzdHJva2VDb2xvciwgc3Ryb2tlT3BhY2l0eSkpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIHRoaXMubGluZUpvaW50KTtcblxuICAgICAgICB2YXIgcGF0aE1vdmVtZW50cyA9IHRoaXMuZ2V0UGF0aE1vdmVtZW50cygpO1xuICAgICAgICB2YXIgbWFwcGVkTW92ZW1lbnRzID0gcGF0aE1vdmVtZW50cy5tYXAoZnVuY3Rpb24obW92ZXMsIGluZGV4KXtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vc3RhcnRcbiAgICAgICAgICAgICAgICAvL21vdmVzID0gW3gsIHldXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTSddLmNvbmNhdChtb3Zlcy5qb2luKCcsJykpLmpvaW4oJyAnKTsgLy9NIHgseVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2N1cnZlXG4gICAgICAgICAgICAgICAgLy9tb3ZlcyA9IFtbeCwgeV0sIFt4LCB5XSwgW3gsIHldXVxuICAgICAgICAgICAgICAgIHZhciBiZXppZXIgPSBtb3Zlcy5tYXAoZnVuY3Rpb24obW92ZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3ZlLmpvaW4oJywnKTsgLy8gXCJ4LHlcIlxuICAgICAgICAgICAgICAgIH0pOyAvLyBbXCJ4LHlcIiwgXCJ4LHlcIiwgXCJ4LHlcIl1cbiAgICAgICAgICAgICAgICByZXR1cm4gWydDJ10uY29uY2F0KGJlemllcikuam9pbignICcpOyAvLyBcIkMgeCx5IHgseSB4LHlcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWFwcGVkTW92ZW1lbnRzLnB1c2goJ1onKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ2QnLCBtYXBwZWRNb3ZlbWVudHMuam9pbignICcpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBpbnRlcm1lZGlhdGUgcG9pbnRzIGdpdmVuIHRoZVxuICAgICAqIGN1cnJlbnQgcG9zaXRpb24gYW5kIHNpemUuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHByb3RvLmdldFBhdGhNb3ZlbWVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLnN0eWxlWydzdHJva2Utd2lkdGgnXTtcblxuICAgICAgICB2YXIgdldpZHRoID0gdGhpcy5zaXplLnggPT09IDAgPyAxIDogdGhpcy5zaXplLng7XG4gICAgICAgIHZhciB2SGVpZ2h0ID0gdGhpcy5zaXplLnkgPT09IDAgPyAxIDogdGhpcy5zaXplLnk7XG5cbiAgICAgICAgdmFyIGFyY1dpZHRoID0gc3Ryb2tlV2lkdGggKiA0OyAgLy8gTWFya3VwQ2xvdWQgY29vcmQgc3BhY2UgdmFsdWVcbiAgICAgICAgdmFyIGFyY0hlaWdodCA9IHN0cm9rZVdpZHRoICogMzsgLy8gTWFya3VwQ2xvdWQgY29vcmQgc3BhY2UgdmFsdWVcblxuICAgICAgICB2YXIgb2Zmc2V0RnJvbVZlcnRleCA9IChhcmNIZWlnaHQgKyAoc3Ryb2tlV2lkdGggLyAyKSk7XG4gICAgICAgIHZhciBjbG91ZFdpZHRoID0gdldpZHRoIC0gKG9mZnNldEZyb21WZXJ0ZXggKiAyKTsgLy9yZW1vdmUgMnggdG8gYWNjb3VudCBmb3IgdGhlIGxlZnQgYW5kIHJpZ2h0IG9mZnNldHNcbiAgICAgICAgdmFyIGNsb3VkSGVpZ2h0ID0gdkhlaWdodCAtIChvZmZzZXRGcm9tVmVydGV4ICogMik7IC8vcmVtb3ZlIDJ4IHRvIGFjY291bnQgZm9yIHRoZSB0b3AgYW5kIGJvdHRvbSBvZmZzZXRzXG5cbiAgICAgICAgLy9kZXRlcm1pbmUgaG93IG1hbnkgYXJjcyB0byBkcmF3IGhvcml6b250YWxseVxuICAgICAgICB2YXIgbnVtT2ZIb3Jpem9udGFsQXJjcyA9IGNsb3VkV2lkdGggLyBhcmNXaWR0aDtcbiAgICAgICAgLy9hbmQgdmVydGljYWxseVxuICAgICAgICB2YXIgbnVtT2ZWZXJ0aWNhbEFyY3MgPSBjbG91ZEhlaWdodCAvIGFyY1dpZHRoO1xuXG4gICAgICAgIC8vdGhlICMgb2YgYXJjcyBtYXkgYmUgYSBkZWNpbWFsLiBJbiB0aGF0IGNhc2UsIGRyYXcgYSBzbWFsbGVyIGFyYyB0byBjb21wbGV0ZS9maWxsIHRoZSBnaXZlbiB3aWR0aC9oZWlnaHRcbiAgICAgICAgdmFyIHBhcnRpYWxIb3Jpem9udGFsQXJjID0gbnVtT2ZIb3Jpem9udGFsQXJjcyAlIDE7IC8vZ2V0IHRoZSBkZWNpbWFsIHBvcnRpb24gb25seVxuICAgICAgICB2YXIgcGFydGlhbFZlcnRpY2FsQXJjID0gbnVtT2ZWZXJ0aWNhbEFyY3MgJSAxOyAvLy8vZ2V0IHRoZSBkZWNpbWFsIHBvcnRpb24gb25seVxuXG4gICAgICAgIC8vZHJvcCB0aGUgZGVjaW1hbFxuICAgICAgICBudW1PZkhvcml6b250YWxBcmNzID0gcGFyc2VJbnQobnVtT2ZIb3Jpem9udGFsQXJjcywgMTApO1xuICAgICAgICBudW1PZlZlcnRpY2FsQXJjcyA9IHBhcnNlSW50KG51bU9mVmVydGljYWxBcmNzLCAxMCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRYID0gb2Zmc2V0RnJvbVZlcnRleCxcbiAgICAgICAgICAgIGN1cnJlbnRZID0gb2Zmc2V0RnJvbVZlcnRleDtcblxuICAgICAgICBmdW5jdGlvbiBiZXppZXJDdXJ2ZSh3aWR0aCwgaGVpZ2h0LCBzaWRlKSB7XG4gICAgICAgICAgICAvL2xlZnQgY29udHJvbCBwb2ludCBvZmZzZXRcbiAgICAgICAgICAgIHZhciBsY3BPZmZzZXQgPSAod2lkdGggKiAwLjI1KTtcbiAgICAgICAgICAgIC8vcmlnaHQgY29udHJvbCBwb2ludCBvZmZzZXRcbiAgICAgICAgICAgIHZhciByY3BPZmZzZXQgPSAod2lkdGggKiAwLjc1KTtcblxuICAgICAgICAgICAgc3dpdGNoKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBsY3BPZmZzZXQsIGN1cnJlbnRZIC0gaGVpZ2h0XSwgIC8vY29udHJvbCBwb2ludCAxXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyByY3BPZmZzZXQsIGN1cnJlbnRZIC0gaGVpZ2h0XSwgIC8vY29udHJvbCBwb2ludCAyXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKz0gd2lkdGgsIGN1cnJlbnRZXSAgICAgICAgICAgICAgIC8vZW5kIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBoZWlnaHQsIGN1cnJlbnRZICsgbGNwT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGhlaWdodCwgY3VycmVudFkgKyByY3BPZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArPSB3aWR0aF1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggLSBsY3BPZmZzZXQsIGN1cnJlbnRZICsgaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCAtIHJjcE9mZnNldCwgY3VycmVudFkgKyBoZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYIC09IHdpZHRoLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYIC0gaGVpZ2h0LCBjdXJyZW50WSAtIGxjcE9mZnNldF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggLSBoZWlnaHQsIGN1cnJlbnRZIC0gcmNwT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgLT0gd2lkdGhdXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL2NyZWF0ZSBhIG1vdmVtZW50cyBhcnJheSB3aXRoIHRoZSBmaXJzdCBtb3ZlbWVudFxuICAgICAgICB2YXIgbW92ZW1lbnRzID0gW1xuICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0gLy9NXG4gICAgICAgIF07XG5cbiAgICAgICAgLy9jcmVhdGUgdGhlIGJlemllciBjdXJ2ZSBmb3IgZWFjaCBzaWRlXG4gICAgICAgIFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uZm9yRWFjaChmdW5jdGlvbihzaWRlKXtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsID0gaXNIb3Jpem9udGFsKHNpZGUpO1xuICAgICAgICAgICAgdmFyIG51bU9mQXJjcyA9IGhvcml6b250YWwgPyBudW1PZkhvcml6b250YWxBcmNzIDogbnVtT2ZWZXJ0aWNhbEFyY3M7XG4gICAgICAgICAgICB2YXIgcGFydGlhbEFyYyA9IGhvcml6b250YWwgPyBwYXJ0aWFsSG9yaXpvbnRhbEFyYyA6IHBhcnRpYWxWZXJ0aWNhbEFyYztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1PZkFyY3M7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVtZW50cy5wdXNoKGJlemllckN1cnZlKGFyY1dpZHRoLCBhcmNIZWlnaHQsIHNpZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0aWFsQXJjICE9PSAwKVxuICAgICAgICAgICAgICAgIG1vdmVtZW50cy5wdXNoKGJlemllckN1cnZlKHBhcnRpYWxBcmMgKiBhcmNXaWR0aCwgYXJjSGVpZ2h0LCBzaWRlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBtb3ZlbWVudHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgcGFyZW50IGxheWVyIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgbWFya3VwLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgICAqL1xuICAgIHByb3RvLnNldFBhcmVudCA9IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICAgIHZhciBkaXYgPSB0aGlzLnNoYXBlO1xuICAgICAgICBkaXYucGFyZW50Tm9kZSAmJiBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHJvdGF0aW9uIG9mIHRoZSBtYXJrdXAgdG8gdGhlIGdpdmVuIGFuZ2xlLlxuICAgICAqIFRoaXMgZ2V0cyBjYWxsZWQgYnkgdGhlIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuU2V0Um90YXRpb24gZWRpdCBhY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAqL1xuICAgIHByb3RvLnNldFJvdGF0aW9uID0gZnVuY3Rpb24gKGFuZ2xlKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGFuZ2xlO1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBtYXJrdXAuXG4gICAgICogVGhpcyBnZXRzIGNhbGxlZCBieSB0aGUgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5TZXRTaXplIGVkaXQgYWN0aW9uXG4gICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBwcm90by5zZXRTaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5zaXplLnggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zaXplLnkgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRoZSBFZGl0RnJhbWUgdG8gbW92ZSB0aGUgbWFya3VwIGluIENsaWVudCBTcGFjZSBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gTmV3IFggbG9jYXRpb24gZm9yIHRoZSBtYXJrdXAuIE5vdGljZSB0aGF0IG1hcmt1cHMgYXJlIGNlbnRlcmVkIG9uIHRoaXMgdmFsdWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBOZXcgWSBsb2NhdGlvbiBmb3IgdGhlIG1hcmt1cC4gTm90aWNlIHRoYXQgbWFya3VwcyBhcmUgY2VudGVyZWQgb24gdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBwcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgseSkge1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGF0IHRoZSBtYXJrdXAgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAqL1xuICAgIHByb3RvLmNyZWF0ZWQgPSBmdW5jdGlvbigpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLnNldFBhcmVudChudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYm91bmRzXG4gICAgICovXG4gICAgcHJvdG8uY29uc3RyYWluc1RvQm91bmRzID0gZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChzaWRlKSB7XG5cbiAgICAgICAgcmV0dXJuIHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICAgIH1cblxuICAgIHByb3RvLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBtZXRhZGF0YS50eXBlID0gXCJjbG91ZFwiO1xuICAgICAgICBtZXRhZGF0YS5wb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueV0uam9pbihcIiBcIik7XG4gICAgICAgIG1ldGFkYXRhLnNpemUgPSBbdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEucm90YXRpb24gPSBTdHJpbmcodGhpcy5yb3RhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZVV0aWxzLmFkZE1hcmt1cE1ldGFkYXRhKHRoaXMuc2hhcGUsIG1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgTWFya3VwIG9udG8gYW4gSFRNTC01IGNhbnZhcyBzdXJmYWNlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdHggLSBDYW52YXMgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKi9cbiAgICBwcm90by5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHZhciBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKC10aGlzLnNpemUueCAqIDAuNSwgLXRoaXMuc2l6ZS55ICogMC41LCAwKTtcbiAgICAgICAgdmFyIG0yID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25aKC10aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdmFyIG0zID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24odGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIDApO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gbTMubXVsdGlwbHkobTIpLm11bHRpcGx5KG0xKTtcblxuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLmhpZ2hsaWdodGVkID8gdGhpcy5oaWdobGlnaHRDb2xvciA6IHRoaXMuc3R5bGVbJ3N0cm9rZS1jb2xvciddO1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLnN0eWxlWydmaWxsLWNvbG9yJ107XG4gICAgICAgIHZhciBmaWxsT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ2ZpbGwtb3BhY2l0eSddO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpO1xuICAgICAgICBjdHgubGluZUpvaW4gPSB0aGlzLmxpbmVKb2ludDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZWRpdG9yLnNpemVGcm9tTWFya3Vwc1RvQ2xpZW50KHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddLCAwKS54O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIHZlY3RvcjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgICB2YXIgbWFwcGluZ0ZuID0gdGhpcy5lZGl0b3IucG9zaXRpb25Gcm9tTWFya3Vwc1RvQ2xpZW50LmJpbmQodGhpcy5lZGl0b3IpO1xuICAgICAgICB2YXIgcGF0aE1vdmVtZW50cyA9IHRoaXMuZ2V0UGF0aE1vdmVtZW50cygpO1xuICAgICAgICBwYXRoTW92ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24obW92ZXMsIGluZGV4KXtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vc3RhcnQgb3Igc3ZnIE1cbiAgICAgICAgICAgICAgICAvL21vdmVzID0gW3gsIHldXG4gICAgICAgICAgICAgICAgdmVjdG9yMy54ID0gbW92ZXNbMF07XG4gICAgICAgICAgICAgICAgdmVjdG9yMy55ID0gbW92ZXNbMV07XG4gICAgICAgICAgICAgICAgdmVjdG9yMy56ID0gMDtcbiAgICAgICAgICAgICAgICB2ZWN0b3IzID0gdmVjdG9yMy5hcHBseU1hdHJpeDQodHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gbWFwcGluZ0ZuKHZlY3RvcjMueCwgdmVjdG9yMy55KTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvcy54LCBwb3MueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY3VydmUgb3Igc3ZnIENcbiAgICAgICAgICAgICAgICAvL21vdmVzID0gW1t4LCB5XSwgW3gsIHldLCBbeCwgeV1dXG4gICAgICAgICAgICAgICAgdmVjdG9yMy54ID0gbW92ZXNbMF1bMF07XG4gICAgICAgICAgICAgICAgdmVjdG9yMy55ID0gbW92ZXNbMF1bMV07XG4gICAgICAgICAgICAgICAgdmVjdG9yMy56ID0gMDtcbiAgICAgICAgICAgICAgICB2ZWN0b3IzID0gdmVjdG9yMy5hcHBseU1hdHJpeDQodHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgY3AxID0gbWFwcGluZ0ZuKHZlY3RvcjMueCwgdmVjdG9yMy55KTtcblxuICAgICAgICAgICAgICAgIHZlY3RvcjMueCA9IG1vdmVzWzFdWzBdO1xuICAgICAgICAgICAgICAgIHZlY3RvcjMueSA9IG1vdmVzWzFdWzFdO1xuICAgICAgICAgICAgICAgIHZlY3RvcjMueiA9IDA7XG4gICAgICAgICAgICAgICAgdmVjdG9yMyA9IHZlY3RvcjMuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIGNwMiA9IG1hcHBpbmdGbih2ZWN0b3IzLngsIHZlY3RvcjMueSk7XG5cbiAgICAgICAgICAgICAgICB2ZWN0b3IzLnggPSBtb3Zlc1syXVswXTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IzLnkgPSBtb3Zlc1syXVsxXTtcbiAgICAgICAgICAgICAgICB2ZWN0b3IzLnogPSAwO1xuICAgICAgICAgICAgICAgIHZlY3RvcjMgPSB2ZWN0b3IzLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBtYXBwaW5nRm4odmVjdG9yMy54LCB2ZWN0b3IzLnkpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3AxLngsIGNwMS55LCBjcDIueCwgY3AyLnksIGVuZC54LCBlbmQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGZpbGxPcGFjaXR5ICE9PSAwICYmIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLk1hcmt1cENsb3VkID0gTWFya3VwQ2xvdWQ7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXJrdXBGcmVlaGFuZChpZCwgZWRpdG9yKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZS1jb2xvcicsJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5NYXJrdXAuY2FsbCh0aGlzLCBpZCwgZWRpdG9yLCBzdHlsZUF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9GUkVFSEFORDtcblxuICAgICAgICAvLyBQb3NpdGlvbiByZXByZXNlbnRzIHRvcC1sZWZ0IChpbnN0ZWFkIG9mIGNlbnRlciBhcyBpbiBtb3N0IG90aGVyIG1hcmt1cHMpLlxuICAgICAgICB0aGlzLmluaVNpemUgPSB7eDogMSwgeTogMX07XG5cbiAgICAgICAgdGhpcy5jcmVhdGVTVkcoKTtcbiAgICAgICAgdGhpcy5iaW5kRG9tRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgTWFya3VwRnJlZWhhbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuTWFya3VwLnByb3RvdHlwZSk7XG4gICAgTWFya3VwRnJlZWhhbmQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFya3VwRnJlZWhhbmQ7XG5cbiAgICB2YXIgcHJvdG8gPSBNYXJrdXBGcmVlaGFuZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5nZXRFZGl0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgbmFtZXNwYWNlLkVkaXRNb2RlRnJlZWhhbmQodGhpcy5lZGl0b3IpO1xuICAgIH07XG5cbiAgICBwcm90by5jcmVhdGVTVkcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5hbWVzcGFjZVV0aWxzLmNyZWF0ZVN2Z0VsZW1lbnQoJ3BhdGgnKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uYmluZERvbUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobmFtZXNwYWNlVXRpbHMuaXNUb3VjaERldmljZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRUb3VjaEV2ZW50cyh0aGlzLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKXsgdGhpcy5oaWdobGlnaHQoZmFsc2UpOyB9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXsgdGhpcy5oaWdobGlnaHQodHJ1ZSk7IH0uYmluZCh0aGlzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCB2YWx1ZXMgaW4gY2xpZW50IHNwYWNlIGNvb3JkaW5hdGVzICgyZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gc2l6ZVxuICAgICAqIEBwYXJhbSBsb2NhdGlvbnNcbiAgICAgKi9cbiAgICBwcm90by5zZXQgPSBmdW5jdGlvbihwb3NpdGlvbiwgc2l6ZSwgbG9jYXRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7IC8vIFJlc2V0IGFuZ2xlIC8vXG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5zaXplLnggPSBzaXplLng7XG4gICAgICAgIHRoaXMuc2l6ZS55ID0gc2l6ZS55O1xuICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IGxvY2F0aW9ucy5jb25jYXQoKTtcblxuICAgICAgICB0aGlzLmluaVNpemUueCA9IChzaXplLnggPT09IDApID8gMSA6IHNpemUueDtcbiAgICAgICAgdGhpcy5pbmlTaXplLnkgPSAoc2l6ZS55ID09PSAwKSA/IDEgOiBzaXplLnk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgM2QgcG9zaXRpb25zIGZvciB0b3AtbGVmdCBhbmQgYm90dG9tLXJpZ2h0LCBpdCByZWNhbGN1bGF0ZXNcbiAgICAgKiBhbGwgdGhlIDJkIHZhbHVlcyBpbiBjbGllbnQgc3BhY2UuXG4gICAgICovXG4gICAgcHJvdG8udXBkYXRlVHJhbnNmb3JtTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBzY2FsZVggPSB0aGlzLnNpemUueCAvIHRoaXMuaW5pU2l6ZS54O1xuICAgICAgICB2YXIgc2NhbGVZID0gdGhpcy5zaXplLnkgLyB0aGlzLmluaVNpemUueTtcblxuICAgICAgICB0aGlzLnRyYW5zZm9ybVN2ZyA9IFtcbiAgICAgICAgICAgICd0cmFuc2xhdGUoJywgdGhpcy5wb3NpdGlvbi54LCAnLCcsIHRoaXMucG9zaXRpb24ueSwgJykgJyxcbiAgICAgICAgICAgICdyb3RhdGUoJywgbmFtZXNwYWNlVXRpbHMucmFkaWFuc1RvRGVncmVlcygtdGhpcy5yb3RhdGlvbiksICcpICcsXG4gICAgICAgICAgICAnc2NhbGUoJywgc2NhbGVYLCAnLCcsIHNjYWxlWSwgJykgJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRhdGEgdmFsdWVzIGludG8gRE9NIGVsZW1lbnQgc3R5bGUvYXR0cmlidXRlKHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90by51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuaGlnaGxpZ2h0ZWQgPyB0aGlzLmhpZ2hsaWdodENvbG9yIDogdGhpcy5zdHlsZVsnc3Ryb2tlLWNvbG9yJ107XG4gICAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHlsZVsnc3Ryb2tlLW9wYWNpdHknXTtcblxuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0aGlzLnRyYW5zZm9ybVN2Zyk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIHN0cm9rZVdpZHRoKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoc3Ryb2tlQ29sb3IsIHN0cm9rZU9wYWNpdHkpKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KSk7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhID0gdGhpcy5sb2NhdGlvbnMubWFwKGZ1bmN0aW9uKHBvaW50LCBpKXtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTSddLmNvbmNhdChbcG9pbnQueCwgcG9pbnQueV0pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnTCddLmNvbmNhdChbcG9pbnQueCwgcG9pbnQueV0pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGhEYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBwYXJlbnQgbGF5ZXIgd2hpY2ggd2lsbCBjb250YWluIHRoZSBtYXJrdXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAgICovXG4gICAgcHJvdG8uc2V0UGFyZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuc2hhcGU7XG4gICAgICAgIGRpdi5wYXJlbnROb2RlICYmIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIHBhcmVudCAmJiBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcm90YXRpb24gb2YgdGhlIG1hcmt1cCB0byB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAgICogVGhpcyBnZXRzIGNhbGxlZCBieSB0aGUgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5TZXRSb3RhdGlvbiBlZGl0IGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgcHJvdG8uc2V0Um90YXRpb24gPSBmdW5jdGlvbiAoYW5nbGUpIHtcblxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gYW5nbGU7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIG1hcmt1cC5cbiAgICAgKiBUaGlzIGdldHMgY2FsbGVkIGJ5IHRoZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlNldFNpemUgZWRpdCBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge3t4OiBOdW1iZXIsIHk6IE51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqL1xuICAgIHByb3RvLnNldFNpemUgPSBmdW5jdGlvbiAocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLnNpemUueCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemUueSA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgdGhlIEVkaXRGcmFtZSB0byBtb3ZlIHRoZSBtYXJrdXAgaW4gQ2xpZW50IFNwYWNlIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBOZXcgWCBsb2NhdGlvbiBmb3IgdGhlIG1hcmt1cC4gTm90aWNlIHRoYXQgbWFya3VwcyBhcmUgY2VudGVyZWQgb24gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIE5ldyBZIGxvY2F0aW9uIGZvciB0aGUgbWFya3VwLiBOb3RpY2UgdGhhdCBtYXJrdXBzIGFyZSBjZW50ZXJlZCBvbiB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCx5KSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25hbHMgdGhhdCB0aGUgbWFya3VwIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBwcm90by5jcmVhdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgLy9cbiAgICB9O1xuXG4gICAgcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQobnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJvdW5kc1xuICAgICAqL1xuICAgIHByb3RvLmNvbnN0cmFpbnNUb0JvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcykge1xuXG4gICAgfTtcblxuICAgIHByb3RvLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBtZXRhZGF0YS50eXBlID0gXCJmcmVlaGFuZFwiO1xuICAgICAgICBtZXRhZGF0YS5wb3NpdGlvbiA9IFt0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueV0uam9pbihcIiBcIik7XG4gICAgICAgIG1ldGFkYXRhLnNpemUgPSBbdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEucm90YXRpb24gPSBTdHJpbmcodGhpcy5yb3RhdGlvbik7XG4gICAgICAgIG1ldGFkYXRhLmxvY2F0aW9ucyA9IHRoaXMubG9jYXRpb25zLm1hcChmdW5jdGlvbihwb2ludCl7XG4gICAgICAgICAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldLmpvaW4oXCIgXCIpO1xuICAgICAgICB9KS5qb2luKFwiIFwiKTtcblxuICAgICAgICByZXR1cm4gbmFtZXNwYWNlVXRpbHMuYWRkTWFya3VwTWV0YWRhdGEodGhpcy5zaGFwZSwgbWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBwcm90by5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0eWxlWydzdHJva2UtY29sb3InXTtcbiAgICAgICAgdmFyIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0eWxlWydzdHJva2Utb3BhY2l0eSddO1xuXG4gICAgICAgIHZhciBzY2FsZVggPSB0aGlzLnNpemUueCAvIHRoaXMuaW5pU2l6ZS54O1xuICAgICAgICB2YXIgc2NhbGVZID0gdGhpcy5zaXplLnkgLyB0aGlzLmluaVNpemUueTtcbiAgICAgICAgdmFyIG0wID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlU2NhbGUoc2NhbGVYLCBzY2FsZVksIDEpO1xuICAgICAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvblooLXRoaXMucm90YXRpb24pO1xuICAgICAgICB2YXIgbTIgPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbih0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgMCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBtMi5tdWx0aXBseShtMSkubXVsdGlwbHkobTApO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuZWRpdG9yLnNpemVGcm9tTWFya3Vwc1RvQ2xpZW50KHN0cm9rZVdpZHRoLCAwKS54O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocG9pbnQsIGkpe1xuICAgICAgICAgICAgdmVjdG9yMy54ID0gcG9pbnQueDtcbiAgICAgICAgICAgIHZlY3RvcjMueSA9IHBvaW50Lnk7XG4gICAgICAgICAgICB2ZWN0b3IzLnogPSAwO1xuICAgICAgICAgICAgdmVjdG9yMyA9IHZlY3RvcjMuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSk7XG4gICAgICAgICAgICBwb2ludCA9IHRoYXQuZWRpdG9yLnBvc2l0aW9uRnJvbU1hcmt1cHNUb0NsaWVudCh2ZWN0b3IzLngsIHZlY3RvcjMueSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5NYXJrdXBGcmVlaGFuZCA9IE1hcmt1cEZyZWVoYW5kO1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogSW1wbGVtZW50cyBhIFJlY3RhbmdsZSBbTWFya3VwXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cH0uXG4gICAgICogSW5jbHVkZWQgaW4gZG9jdW1lbnRhdGlvbiBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBjcmVhdGVcbiAgICAgKiBhIHNwZWNpZmljIG1hcmt1cCB0eXBlLiBEZXZlbG9wZXJzIGFyZSBlbmNvdXJhZ2UgdG8gbG9vayBpbnRvIHRoaXMgY2xhc3MncyBzb3VyY2UgY29kZSBhbmQgY29weVxuICAgICAqIGFzIG11Y2ggY29kZSBhcyB0aGV5IG5lZWQuIEZpbmQgbGluayB0byBzb3VyY2UgY29kZSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICogQGV4dGVuZHMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZX0gZWRpdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFya3VwUmVjdGFuZ2xlKGlkLCBlZGl0b3IpIHtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5JywgJ2ZpbGwtY29sb3InLCAnZmlsbC1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5NYXJrdXAuY2FsbCh0aGlzLCBpZCwgZWRpdG9yLCBzdHlsZUF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9SRUNUQU5HTEU7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVTVkcoKTtcbiAgICAgICAgdGhpcy5iaW5kRG9tRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgTWFya3VwUmVjdGFuZ2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLk1hcmt1cC5wcm90b3R5cGUpO1xuICAgIE1hcmt1cFJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXJrdXBSZWN0YW5nbGU7XG5cbiAgICB2YXIgcHJvdG8gPSBNYXJrdXBSZWN0YW5nbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZ2V0RWRpdE1vZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IG5hbWVzcGFjZS5FZGl0TW9kZVJlY3RhbmdsZSh0aGlzLmVkaXRvcik7XG4gICAgfTtcblxuICAgIHByb3RvLmNyZWF0ZVNWRyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNoYXBlID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgncmVjdCcpO1xuICAgIH07XG5cbiAgICBwcm90by5iaW5kRG9tRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVdGlscy5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvdWNoRXZlbnRzKHRoaXMuc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyksIHRydWUgKTtcbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24oKXt0aGlzLmhpZ2hsaWdodChmYWxzZSk7fS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zaGFwZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKCl7dGhpcy5oaWdobGlnaHQodHJ1ZSk7fS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyBwb3NpdGlvbiBhbmQgc2l6ZSBpbiBtYXJrdXAgc3BhY2UgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2l6ZVxuICAgICAqL1xuICAgIHByb3RvLnNldCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBzaXplKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7IC8vIFJlc2V0IGFuZ2xlIC8vXG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5zaXplLnggPSBzaXplLng7XG4gICAgICAgIHRoaXMuc2l6ZS55ID0gc2l6ZS55O1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIDNkIHBvc2l0aW9ucyBmb3IgdG9wLWxlZnQgYW5kIGJvdHRvbS1yaWdodCwgaXQgcmVjYWxjdWxhdGVzXG4gICAgICogYWxsIHRoZSAyZCB2YWx1ZXMgaW4gY2xpZW50IHNwYWNlLlxuICAgICAqL1xuICAgIHByb3RvLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuXG4gICAgICAgIHZhciBvcmlnaW5YID0gTWF0aC5tYXgodGhpcy5zaXplLnggLSBzdHJva2VXaWR0aCwgMCkgKiAwLjU7XG4gICAgICAgIHZhciBvcmlnaW5ZID0gTWF0aC5tYXgodGhpcy5zaXplLnkgLSBzdHJva2VXaWR0aCwgMCkgKiAwLjU7XG5cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdmcgPSBbXG4gICAgICAgICAgICAndHJhbnNsYXRlKCcsIHRoaXMucG9zaXRpb24ueCwgJywnLCB0aGlzLnBvc2l0aW9uLnksICcpICcsXG4gICAgICAgICAgICAncm90YXRlKCcsIG5hbWVzcGFjZVV0aWxzLnJhZGlhbnNUb0RlZ3JlZXMoLXRoaXMucm90YXRpb24pLCAnKSAnLFxuICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnLCAtb3JpZ2luWCwgJywnLCAtb3JpZ2luWSwgJykgJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGRhdGEgdmFsdWVzIGludG8gRE9NIGVsZW1lbnQgc3R5bGUvYXR0cmlidXRlKHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90by51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG5cbiAgICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHlsZVsnc3Ryb2tlLXdpZHRoJ107XG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuaGlnaGxpZ2h0ZWQgPyB0aGlzLmhpZ2hsaWdodENvbG9yIDogdGhpcy5zdHlsZVsnc3Ryb2tlLWNvbG9yJ107XG4gICAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHlsZVsnc3Ryb2tlLW9wYWNpdHknXTtcbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IHRoaXMuc3R5bGVbJ2ZpbGwtY29sb3InXTtcbiAgICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gdGhpcy5zdHlsZVsnZmlsbC1vcGFjaXR5J107XG5cbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGhpcy50cmFuc2Zvcm1TdmcpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCAgc3Ryb2tlV2lkdGgpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBuYW1lc3BhY2VVdGlscy5jb21wb3NlUkdCQVN0cmluZyhzdHJva2VDb2xvciwgc3Ryb2tlT3BhY2l0eSkpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5tYXgodGhpcy5zaXplLnggLSBzdHJva2VXaWR0aCwgMCkpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5tYXgodGhpcy5zaXplLnkgLSBzdHJva2VXaWR0aCwgMCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHBhcmVudCBsYXllciB3aGljaCB3aWxsIGNvbnRhaW4gdGhlIG1hcmt1cC5cbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgKi9cbiAgICBwcm90by5zZXRQYXJlbnQgPSBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgICB2YXIgZGl2ID0gdGhpcy5zaGFwZTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUgJiYgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFya3VwIHRvIHRoZSBnaXZlbiBhbmdsZS5cbiAgICAgKiBUaGlzIGdldHMgY2FsbGVkIGJ5IHRoZSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlNldFJvdGF0aW9uIGVkaXQgYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICBwcm90by5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKGFuZ2xlKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IGFuZ2xlO1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIGFuZCBzaXplIG9mIHRoZSBtYXJrdXAuXG4gICAgICogVGhpcyBnZXRzIGNhbGxlZCBieSB0aGUgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5TZXRTaXplIGVkaXQgYWN0aW9uXG4gICAgICogQHBhcmFtIHt7eDogTnVtYmVyLCB5OiBOdW1iZXJ9fSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBwcm90by5zZXRTaXplID0gZnVuY3Rpb24ocG9zaXRpb24sIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSBwb3NpdGlvbi55O1xuICAgICAgICB0aGlzLnNpemUueCA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemUueSA9IGhlaWdodDtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgdGhlIEVkaXRGcmFtZSB0byBtb3ZlIHRoZSBtYXJrdXAgaW4gQ2xpZW50IFNwYWNlIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBOZXcgWCBsb2NhdGlvbiBmb3IgdGhlIG1hcmt1cC4gTm90aWNlIHRoYXQgbWFya3VwcyBhcmUgY2VudGVyZWQgb24gdGhpcyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIE5ldyBZIGxvY2F0aW9uIGZvciB0aGUgbWFya3VwLiBOb3RpY2UgdGhhdCBtYXJrdXBzIGFyZSBjZW50ZXJlZCBvbiB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oeCx5KSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaWduYWxzIHRoYXQgdGhlIG1hcmt1cCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICovXG4gICAgcHJvdG8uY3JlYXRlZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgfTtcblxuICAgIHByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuc2V0UGFyZW50KG51bGwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBib3VuZHNcbiAgICAgKi9cbiAgICBwcm90by5jb25zdHJhaW5zVG9Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5zZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IG5hbWVzcGFjZVV0aWxzLmNsb25lU3R5bGUodGhpcy5zdHlsZSk7XG5cbiAgICAgICAgbWV0YWRhdGEudHlwZSA9IFwicmVjdGFuZ2xlXCI7XG4gICAgICAgIG1ldGFkYXRhLnBvc2l0aW9uID0gW3RoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEuc2l6ZSA9IFt0aGlzLnNpemUueCwgdGhpcy5zaXplLnldLmpvaW4oXCIgXCIpO1xuICAgICAgICBtZXRhZGF0YS5yb3RhdGlvbiA9IFN0cmluZyh0aGlzLnJvdGF0aW9uKTtcblxuICAgICAgICByZXR1cm4gbmFtZXNwYWNlVXRpbHMuYWRkTWFya3VwTWV0YWRhdGEodGhpcy5zaGFwZSwgbWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICBwcm90by5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3R5bGVbJ3N0cm9rZS13aWR0aCddO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLmhpZ2hsaWdodGVkID8gdGhpcy5oaWdobGlnaHRDb2xvciA6IHRoaXMuc3R5bGVbJ3N0cm9rZS1jb2xvciddO1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLnN0eWxlWydmaWxsLWNvbG9yJ107XG4gICAgICAgIHZhciBmaWxsT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ2ZpbGwtb3BhY2l0eSddO1xuXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuc2l6ZS54IC0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLnNpemUueSAtIHN0cm9rZVdpZHRoO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZWRpdG9yLnNpemVGcm9tTWFya3Vwc1RvQ2xpZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgY2xpZW50V2lkdGggPSBzaXplLng7XG4gICAgICAgIHZhciBjbGllbnRIZWlnaHQgPSBzaXplLnk7XG4gICAgICAgIHZhciBjbGllbnRDZW50ZXIgPSB0aGlzLmVkaXRvci5wb3NpdGlvbkZyb21NYXJrdXBzVG9DbGllbnQodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnkpO1xuXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKHN0cm9rZUNvbG9yLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5lZGl0b3Iuc2l6ZUZyb21NYXJrdXBzVG9DbGllbnQoc3Ryb2tlV2lkdGgsIDApLng7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY2xpZW50Q2VudGVyLngsIGNsaWVudENlbnRlci55KTtcbiAgICAgICAgY3R4LnJvdGF0ZSh0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgICAgICBmaWxsT3BhY2l0eSAhPT0gMCAmJiBjdHguZmlsbFJlY3QoY2xpZW50V2lkdGggLyAtMiwgY2xpZW50SGVpZ2h0IC8gLTIsIGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChjbGllbnRXaWR0aCAvIC0yLCBjbGllbnRIZWlnaHQgLyAtMiwgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5NYXJrdXBSZWN0YW5nbGUgPSBNYXJrdXBSZWN0YW5nbGU7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKiBBcnJvdyBNYXJrdXAuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFya3VwVGV4dChpZCwgZWRpdG9yLCBzaXplKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFtcbiAgICAgICAgICAgICdmb250LXNpemUnLFxuICAgICAgICAgICAgJ3N0cm9rZS1jb2xvcicsICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgICAgICAnZmlsbC1jb2xvcicsICdmaWxsLW9wYWNpdHknLFxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JyxcbiAgICAgICAgICAgICdmb250LXN0eWxlJyxcbiAgICAgICAgICAgICdmb250LXdlaWdodCdcbiAgICAgICAgXTtcbiAgICAgICAgbmFtZXNwYWNlLk1hcmt1cC5jYWxsKHRoaXMsIGlkLCBlZGl0b3IsIHN0eWxlQXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuY29uc3RyYWludFJvdGF0aW9uID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBuYW1lc3BhY2UuTUFSS1VQX1RZUEVfVEVYVDtcblxuICAgICAgICB0aGlzLnNpemUueCA9IHNpemUueDtcbiAgICAgICAgdGhpcy5zaXplLnkgPSBzaXplLnk7XG4gICAgICAgIHRoaXMuY3VycmVudFRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0TGluZXMgPSBbXCJcIl07XG4gICAgICAgIHRoaXMudGV4dERpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBOb3RlOiBXZSBjb3VsZCBoYXZlIHRoaXMgcHJvcGVydHkgYmUgYSBzdHlsZSBwcm9wZXJ0eS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgaXMgbm8gbmVlZCBmb3IgdGhpcyBwcm9wZXJ0eSB0byBiZSBleHBvc2VkIHRvIHRoZSB1c2VyIGZvciBhbHRlcmF0aW9uXG4gICAgICAgIC8vIFRoaXMgdmFsdWUgaXMgYSBwZXJjZW50YWdlIG9mIHRoZSBmb250IHNpemUgdXNlZCB0byBvZmZzZXQgdmVydGljYWxseSAyIHRleHQgbGluZXNcbiAgICAgICAgLy8gb2YgdGhlIHNhbWUgcGFyYWdyYXBoLlxuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGlzIHZhbHVlIGlzIHVzZWQgYnkgRWRpdG9yVGV4dElucHV0LmpzXG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IDEzMDtcblxuICAgICAgICB0aGlzLmNyZWF0ZVN2ZygpO1xuICAgICAgICB0aGlzLmJpbmREb21FdmVudHMoKTtcbiAgICB9XG5cbiAgICBNYXJrdXBUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLk1hcmt1cC5wcm90b3R5cGUpO1xuICAgIE1hcmt1cFRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWFya3VwVGV4dDtcblxuICAgIHZhciBwcm90byA9IE1hcmt1cFRleHQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZ2V0RWRpdE1vZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IG5hbWVzcGFjZS5FZGl0TW9kZVRleHQodGhpcy5lZGl0b3IpO1xuICAgIH07XG5cbiAgICBwcm90by5jcmVhdGVTdmcgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBVc2VkIHRvIGNsaXAgcmVuZGVyaW5nIG9mIHRleHQuXG4gICAgICAgIC8vIFdlIGFyZSBwYXJ0aWN1bGFybHkgaW50ZXJlc3RlZCBpbiB2ZXJ0aWNhbCBjbGlwcGluZ1xuICAgICAgICB0aGlzLmNsaXBQYXRoID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgnY2xpcFBhdGgnKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aElkID0gJ0NPMl9NYXJrdXBfY2xpcF8nICsgdGhpcy5pZDtcbiAgICAgICAgdGhpcy5jbGlwUGF0aC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5jbGlwUGF0aElkKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJyk7XG5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBjbGlwcGluZyBzaGFwZVxuICAgICAgICB0aGlzLmNsaXBSZWN0ID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgncmVjdCcpO1xuICAgICAgICB0aGlzLmNsaXBSZWN0LnJlbW92ZUF0dHJpYnV0ZSgncG9pbnRlci1ldmVudHMnKTtcbiAgICAgICAgdGhpcy5jbGlwUGF0aC5hcHBlbmRDaGlsZCh0aGlzLmNsaXBSZWN0KTsgLy8gQWRkIHRvIGNsaXBQYXRoXG5cbiAgICAgICAgdGhpcy5zaGFwZSA9IG5hbWVzcGFjZVV0aWxzLmNyZWF0ZVN2Z0VsZW1lbnQoJ3RleHQnKTtcbiAgICAgICAgdGhpcy5zaGFwZUJnID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgncmVjdCcpO1xuICAgIH07XG5cbiAgICBwcm90by5iaW5kRG9tRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2VVdGlscy5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvdWNoRXZlbnRzKHRoaXMuc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpe3RoaXMuaGlnaGxpZ2h0KGZhbHNlKTt9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNoYXBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oKXt0aGlzLmhpZ2hsaWdodCh0cnVlKTt9LmJpbmQodGhpcykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRTdHJpbmdcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0ZXh0TGluZXNcbiAgICAgKi9cbiAgICBwcm90by5zZXQgPSBmdW5jdGlvbihwb3NpdGlvbiwgc2l6ZSwgdGV4dFN0cmluZywgdGV4dExpbmVzKSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0gcG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5zaXplLnggPSBzaXplLng7XG4gICAgICAgIHRoaXMuc2l6ZS55ID0gc2l6ZS55O1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgdGhpcy5zZXRUZXh0KHRleHRTdHJpbmcsIHRleHRMaW5lcyk7XG4gICAgfTtcblxuICAgIHByb3RvLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBveCA9IHRoaXMuc2l6ZS54ICogMC41O1xuICAgICAgICB2YXIgb3kgPSB0aGlzLnNpemUueSAqIDAuNTtcbiAgICAgICAgdmFyIHBvc194ID0gdGhpcy5wb3NpdGlvbi54IC0gb3g7XG4gICAgICAgIHZhciBwb3NfeSA9IHRoaXMucG9zaXRpb24ueSAtIG95O1xuXG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3ZnID0gW1xuICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnLCBwb3NfeCwgJywnLCBwb3NfeSwgJykgJyxcbiAgICAgICAgICAgICdzY2FsZSgnLCAxLCAnLCcsIC0xLCAnKSAnXS5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnNldFNpemUgPSBmdW5jdGlvbihwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciByZWNhbGNMaW5lcyA9ICh0aGlzLnNpemUueCAhPT0gd2lkdGgpO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuc2l6ZS54ID0gd2lkdGg7XG4gICAgICAgIHRoaXMuc2l6ZS55ID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmIChyZWNhbGNMaW5lcykge1xuICAgICAgICAgICAgdmFyIG5ld0xpbmVzID0gdGhpcy5jYWxjVGV4dExpbmVzKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGluZXNBcmVFcXVhbChuZXdMaW5lcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUZXh0TGluZXMgPSBuZXdMaW5lcztcbiAgICAgICAgICAgICAgICB0aGlzLnRleHREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICBwcm90by5jYWxjVGV4dExpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgdWdseSBhcyBoZWxsLiBXZSBuZWVkIGEgYmV0dGVyIGFwcHJvYWNoIHRvIHRoaXMuXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5lZGl0TW9kZS50ZXh0SW5wdXRIZWxwZXIuZ2V0VGV4dFZhbHVlc0Zvck1hcmt1cCh0aGlzKS5saW5lcztcbiAgICB9O1xuXG4gICAgcHJvdG8uc2V0U3R5bGUgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICBuYW1lc3BhY2VVdGlscy5jb3B5U3R5bGUoc3R5bGUsIHRoaXMuc3R5bGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKHRydWUpOyAvLyBGb3IgVGV4dCBNYXJrdXAgd2UgYWx3YXlzIGZvcmNlIGEgcmUtcmVuZGVyIG9mIHRleHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lcyAtIEFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLmxpbmVzQXJlRXF1YWwgPSBmdW5jdGlvbihsaW5lcykge1xuICAgICAgICB2YXIgY3VyciA9IHRoaXMuY3VycmVudFRleHRMaW5lcztcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gY3Vyci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxlbiA9IGN1cnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChsaW5lc1tpXSAhPT0gY3VycltpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBwYXJlbnQgbGF5ZXIgd2hpY2ggd2lsbCBjb250YWluIHRoZSBtYXJrdXAuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAgICovXG4gICAgcHJvdG8uc2V0UGFyZW50ID0gZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgICAgLy8gTk9URTogRG8gbm90IGFkZCBjbGlwUGF0aCBpbnRvIGEgPGRlZj4gbm9kZS5cbiAgICAgICAgLy8gUmVhc29uOiBJdCBkb2Vzbid0IHdvcmsgaW4gQ2hyb21lIChGaXJlZm94IGRpZCB3b3JrKS5cbiAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB0aGlzLmNsaXBQYXRoLnBhcmVudE5vZGU7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmNsaXBQYXRoKTtcbiAgICAgICAgcGFyZW50ICYmIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNsaXBQYXRoKTtcblxuICAgICAgICBjdXJyZW50UGFyZW50ID0gdGhpcy5zaGFwZUJnLnBhcmVudE5vZGU7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnNoYXBlQmcpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVCZyk7XG5cbiAgICAgICAgY3VycmVudFBhcmVudCA9IHRoaXMuc2hhcGUucGFyZW50Tm9kZTtcbiAgICAgICAgY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuc2hhcGUpO1xuICAgICAgICBwYXJlbnQgJiYgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICovXG4gICAgcHJvdG8uc2V0VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGV4dExpbmVzID0gdGhpcy5jYWxjVGV4dExpbmVzKCk7XG4gICAgICAgIHRoaXMudGV4dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByYXcgc3RyaW5nIHZhbHVlXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBwcm90by5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRleHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHRleHQgbGluZXMgdXNlZCBmb3IgcmVuZGVyaW5nIFNWRyB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5LjxTdHJpbmc+fVxuICAgICAqL1xuICAgIHByb3RvLmdldFRleHRMaW5lcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUZXh0TGluZXMuY29uY2F0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZGF0YSB2YWx1ZXMgaW50byBET00gZWxlbWVudCBzdHlsZS9hdHRyaWJ1dGUocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlRGlydHldIC0gV2hldGhlciB3ZSB3YW50IHRvIHJlLXJlbmRlciB0aGUgdGV4dFxuICAgICAqL1xuICAgIHByb3RvLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24oZm9yY2VEaXJ0eSkge1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtTWF0cml4KCk7XG5cbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5zdHlsZVsnZm9udC1zaXplJ107XG4gICAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuaGlnaGxpZ2h0ZWQgPyB0aGlzLmhpZ2hsaWdodENvbG9yIDogdGhpcy5zdHlsZVsnc3Ryb2tlLWNvbG9yJ107XG4gICAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHlsZVsnc3Ryb2tlLW9wYWNpdHknXTtcblxuICAgICAgICAvLyBTZWUgc3RhbmRhcmQ6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9mb250cy5odG1sXG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKFwiZm9udC1mYW1pbHlcIiwgdGhpcy5zdHlsZVsnZm9udC1mYW1pbHknXSk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKFwiZm9udC1zaXplXCIsIGZvbnRTaXplKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgdGhpcy5zdHlsZVsnZm9udC13ZWlnaHQnXSA/ICdib2xkJyA6ICcnKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJmb250LXN0eWxlXCIsIHRoaXMuc3R5bGVbJ2ZvbnQtc3R5bGUnXSA/ICdpdGFsaWMnIDogJycpO1xuICAgICAgICB0aGlzLnNoYXBlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoc3Ryb2tlQ29sb3IsIHN0cm9rZU9wYWNpdHkpKTtcblxuICAgICAgICAvLyBTVkcgdGV4dCAoYXMgb3Bwb3NlZCB0byBESVYgdGV4dCkgaXMgcmVuZGVyZWQgXCJvbiB0b3BcIiBvZiB0aGUgaW5kaWNhdGVkIFkgcG9zaXRpb24uXG4gICAgICAgIC8vIFRodXMsIHdlIG5lZWQgdG8gb2Zmc2V0IGl0IGRvd24gYSBiaXQsIGFuZCBmb3IgdGhhdCB3ZSBuZWVkIHRvIHRha2UgY2FyZSBpbnRvIGFjY291bnRcbiAgICAgICAgLy8gdGhlIHRleHQgYm91bmRpbmcgYm94J3MgaGVpZ2h0IChhbmQgbWF5YmUgaXRzIHkgY29vcmRpbmF0ZSkuXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5zaGFwZS5nZXRCQm94KCk7IC8vIEFzc3VtZXMgZm9udCBzdHlsZSBpcyBhbHJlYWR5IGluIHBsYWNlLlxuICAgICAgICB2YXIgdmVydGljYWxUcmFuc2Zvcm0gPSBbJ3RyYW5zbGF0ZSgwLCAnLCAtdGhpcy5zaXplLnkgKyBmb250U2l6ZSwgJyknXS5qb2luKCcnKTtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGhpcy50cmFuc2Zvcm1TdmcgKyB2ZXJ0aWNhbFRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuc2hhcGUuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgdGhpcy5jbGlwUGF0aElkICsgJyknKTtcblxuICAgICAgICAvLyBNdXN0IGJlIGNhbGxlZCBBRlRFUiBzaGFwZSdzIHN0eWxlcyBhcmUgaW4gcGxhY2UuXG4gICAgICAgIGlmICh0aGlzLnRleHREaXJ0eSB8fCBmb3JjZURpcnR5KSB7XG4gICAgICAgICAgICBpZiAoZm9yY2VEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRleHRMaW5lcyA9IHRoaXMuY2FsY1RleHRMaW5lcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkVGV4dFN2ZygpO1xuICAgICAgICAgICAgdGhpcy50ZXh0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBjbGlwcGluZyByZWN0XG4gICAgICAgIHRoaXMuY2xpcFJlY3Quc2V0QXR0cmlidXRlKCd4JywgXCIwXCIpO1xuICAgICAgICB0aGlzLmNsaXBSZWN0LnNldEF0dHJpYnV0ZSgneScsIGJib3gueSk7IC8vIE5lZ2F0aXZlIG51bWJlclxuICAgICAgICB0aGlzLmNsaXBSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnNpemUueCk7XG4gICAgICAgIHRoaXMuY2xpcFJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLnNpemUueSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGUgYmFja2dyb3VuZCByZWN0YW5nbGVcbiAgICAgICAgdmFyIGZpbGxDb2xvciA9IHRoaXMuc3R5bGVbJ2ZpbGwtY29sb3InXTtcbiAgICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gdGhpcy5zdHlsZVsnZmlsbC1vcGFjaXR5J107XG4gICAgICAgIHZlcnRpY2FsVHJhbnNmb3JtID0gWyd0cmFuc2xhdGUoMCwgJywgLXRoaXMuc2l6ZS55LCAnKSddLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnNoYXBlQmcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHRoaXMudHJhbnNmb3JtU3ZnICsgdmVydGljYWxUcmFuc2Zvcm0pO1xuICAgICAgICB0aGlzLnNoYXBlQmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuc2l6ZS54KTtcbiAgICAgICAgdGhpcy5zaGFwZUJnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5zaXplLnkpO1xuICAgICAgICB0aGlzLnNoYXBlQmcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsICAnMCcpO1xuICAgICAgICB0aGlzLnNoYXBlQmcuc2V0QXR0cmlidXRlKCdmaWxsJywgbmFtZXNwYWNlVXRpbHMuY29tcG9zZVJHQkFTdHJpbmcoZmlsbENvbG9yLCBmaWxsT3BhY2l0eSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZS1jcmVhdGVzIFNWRyB0YWdzIHRoYXQgcmVuZGVyIFNWRyB0ZXh0LlxuICAgICAqIEVhY2ggbGluZSBpcyBwbGFjZWQgYXJvdW5kIHRzcGFuIHRhZ3Mgd2hpY2ggYXJlIHZlcnRpY2FsbHkgb2Zmc2V0IHRvIGVhY2ggb3RoZXIuXG4gICAgICovXG4gICAgcHJvdG8ucmVidWlsZFRleHRTdmcgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBCZWdpbiBieSByZW1vdmluZyBhbGwgY2hpbGRyZW4gKGlmIGFueSkuXG4gICAgICAgIHdoaWxlICh0aGlzLnNoYXBlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zaGFwZS5yZW1vdmVDaGlsZCh0aGlzLnNoYXBlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbGluZSwgY3JlYXRlIGEgdHNwYW4sIGFkZCBhcyBjaGlsZCBhbmQgb2Zmc2V0IGl0IHZlcnRpY2FsbHkuXG4gICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgIHZhciBkeSA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRleHRMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpe1xuICAgICAgICAgICAgdmFyIHRzcGFuID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgndHNwYW4nKTtcbiAgICAgICAgICAgIHRzcGFuLnNldEF0dHJpYnV0ZSgneCcsIGR4KTtcbiAgICAgICAgICAgIHRzcGFuLnNldEF0dHJpYnV0ZSgneScsIGR5KTtcbiAgICAgICAgICAgIHRzcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgICAgIHRoaXMuc2hhcGUuYXBwZW5kQ2hpbGQodHNwYW4pO1xuICAgICAgICAgICAgZHkgKz0geU9mZnNldDtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uc2V0TWV0YWRhdGEgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWV0YWRhdGEgPSBuYW1lc3BhY2VVdGlscy5jbG9uZVN0eWxlKHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIG1ldGFkYXRhLnR5cGUgPSBcImxhYmVsXCI7XG4gICAgICAgIG1ldGFkYXRhLnBvc2l0aW9uID0gW3RoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55XS5qb2luKFwiIFwiKTtcbiAgICAgICAgbWV0YWRhdGEuc2l6ZSA9IFt0aGlzLnNpemUueCwgdGhpcy5zaXplLnldLmpvaW4oXCIgXCIpO1xuICAgICAgICBtZXRhZGF0YS50ZXh0ID0gU3RyaW5nKHRoaXMuY3VycmVudFRleHQpO1xuXG4gICAgICAgIHJldHVybiBuYW1lc3BhY2VVdGlscy5hZGRNYXJrdXBNZXRhZGF0YSh0aGlzLnNoYXBlLCBtZXRhZGF0YSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCByZXR1cm5zIHRoZSBmb250IHNpemUgaW4gY2xpZW50IHNwYWNlIGNvb3Jkcy5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIHByb3RvLmdldENsaWVudEZvbnRTaXplID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnNpemVGcm9tTWFya3Vwc1RvQ2xpZW50KDAsIHRoaXMuc3R5bGVbJ2ZvbnQtc2l6ZSddKS55O1xuICAgIH07XG5cbiAgICBwcm90by5nZXRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlWydmb250LXNpemUnXSAqICh0aGlzLmxpbmVIZWlnaHQgKiAwLjAxKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uZm9yY2VSZWRyYXcgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBJbiBjaHJvbWUgdGhlIHRleHQgaXMgbm90IHJlbmRlcmVkIHVudGlsIGl0cyBzdHlsZSBjaGFuZ2VzIGFmdGVyIGNyZWF0aW9uLlxuICAgICAgICAvLyBXaXRoIHRoaXMgaGFjayB0aGUgdGV4dCBpcyBkcmF3biBjb3JyZWN0bHkuXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gIXRoaXMuaGlnaGxpZ2h0ZWQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkID0gIXRoaXMuaGlnaGxpZ2h0ZWQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGxpbmVzIG9mIHRleHQgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBhdHRlbXB0IHRvIGZpZ3VyZSBvdXQgaG93IHRvIHdyYXAgdGV4dC4gSW5zdGVhZCwgaXQgZXhwZWN0c1xuICAgICAqIGEgc2V0IG9mIGxpbmVzIHRoYXQgYXJlIGFscmVhZHkgYWRqdXN0ZWQgdG8gZml0IGluIHRoZSBnaXZlbiBzcGFjZS5cbiAgICAgKiBBbGwgdGhpcyBkb2VzIGl0IHJlbmRlcnMgdGhlbSBpbiB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIHRoZSBjYW52YXMgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbGluZXMgLSB0aGUgbGluZXMgb2YgdGV4dCB0byByZW5kZXIgYWxyZWFkeSBhZGp1c3RlZCB0byB3cmFwIHByb3Blcmx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhIZWlnaHQgLSBtYXhpbXVtIGhlaWdodCB0aGUgdGV4dCB3aWxsIHJlbmRlciB0b1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlckxpbmVzT2ZUZXh0KGN0eCwgbGluZXMsIGxpbmVIZWlnaHQsIG1heEhlaWdodCl7XG5cbiAgICAgICAgdmFyIHkgPSAwOy8vb25seSB0aGUgdmVydGljYWwgcG9zaXRpb24gY2hhbmdlc1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpe1xuICAgICAgICAgICAgLy9jaGVjayBpZiB3ZSdyZSBvdmVyIHRoZSBtYXggaGVpZ2h0IGFsbG93ZWRcbiAgICAgICAgICAgIC8vaWYgc28sIGp1c3QgZW5kXG4gICAgICAgICAgICBpZiAoKHkgKyBsaW5lSGVpZ2h0KSA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAwLCB5KTtcbiAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdG8ucmVuZGVyVG9DYW52YXMgPSBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICB2YXIgZm9udEZhbWlseSA9IHRoaXMuc3R5bGVbJ2ZvbnQtZmFtaWx5J107XG4gICAgICAgIHZhciBmb250U3R5bGUgPSB0aGlzLnN0eWxlWydmb250LXN0eWxlJ10gPyBcIml0YWxpY1wiIDogXCJcIjtcbiAgICAgICAgdmFyIGZvbnRXZWlnaHQgPSB0aGlzLnN0eWxlWydmb250LXdlaWdodCddID8gXCJib2xkXCIgOiBcIlwiO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLnN0eWxlWydzdHJva2UtY29sb3InXTtcbiAgICAgICAgdmFyIGZvbnRPcGFjaXR5ID0gdGhpcy5zdHlsZVsnc3Ryb2tlLW9wYWNpdHknXTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRDbGllbnRGb250U2l6ZSgpO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGZvbnRTaXplICogKHRoaXMubGluZUhlaWdodCAqIDAuMDEpO1xuXG4gICAgICAgIC8vdmFyIHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpOyBUT0RPOiBSZXZpc2l0IHJvdGF0aW9uIHdoZW4gaXQgYmVjb21lcyBhdmFpbGFibGVcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZWRpdG9yLnBvc2l0aW9uRnJvbU1hcmt1cHNUb0NsaWVudCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSk7XG4gICAgICAgIHZhciBjbGllbnRTaXplID0gdGhpcy5lZGl0b3Iuc2l6ZUZyb21NYXJrdXBzVG9DbGllbnQodGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcblxuICAgICAgICAvLyBCYWNrZ3JvdW5kIHJlY3RcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpbGxDb2xvciA9IHRoaXMuc3R5bGVbJ2ZpbGwtY29sb3InXTtcbiAgICAgICAgICAgIHZhciBmaWxsT3BhY2l0eSA9IHRoaXMuc3R5bGVbJ2ZpbGwtb3BhY2l0eSddO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNvbXBvc2VSR0JBU3RyaW5nKGZpbGxDb2xvciwgZmlsbE9wYWNpdHkpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICAgICAgLy9jdHgucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5ICE9PSAwICYmIGN0eC5maWxsUmVjdChjbGllbnRTaXplLnggKiAtMC41LCBjbGllbnRTaXplLnkgKiAtMC41LCBjbGllbnRTaXplLngsIGNsaWVudFNpemUueSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvLyBUZXh0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHJva2VDb2xvcjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCAtIChjbGllbnRTaXplLnggKiAwLjUpLCBjZW50ZXIueSAtIChjbGllbnRTaXplLnkgKiAwLjUpKTtcbiAgICAgICAgLy9jdHgucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgICAgY3R4LmZvbnQgPSBmb250U3R5bGUgKyBcIiBcIiArIGZvbnRXZWlnaHQgKyBcIiBcIiArIGZvbnRTaXplICsgXCJweCBcIiArIGZvbnRGYW1pbHk7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGZvbnRPcGFjaXR5O1xuICAgICAgICByZW5kZXJMaW5lc09mVGV4dChjdHgsIHRoaXMuY3VycmVudFRleHRMaW5lcywgbGluZUhlaWdodCwgY2xpZW50U2l6ZS55KTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLk1hcmt1cFRleHQgPSBNYXJrdXBUZXh0O1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIGZ1bmN0aW9uIE1hcmt1cFRvb2woKSB7XG5cbiAgICAgICAgQXV0b2Rlc2suVmlld2luZy5Ub29sSW50ZXJmYWNlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubmFtZXMgPSBbXCJtYXJrdXBzLmNvcmVcIl07XG4gICAgICAgIHRoaXMucGFuVG9vbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWxsb3dOYXYgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmNvcmVFeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmhvdGtleXNFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgX2N0cmxEb3duID0gZmFsc2U7XG4gICAgICAgIHZhciBfc2hpZnREb3duID0gZmFsc2U7XG5cbiAgICAgICAgLy8gTm9uLVRvb2xJbnRlcmZhY2UgbWV0aG9kcyAvL1xuXG4gICAgICAgIHRoaXMuYWxsb3dOYXZpZ2F0aW9uID0gZnVuY3Rpb24oYWxsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dOYXYgPSBhbGxvdztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDb3JlRXh0ZW5zaW9uID0gZnVuY3Rpb24oY29yZUV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb3JlRXh0ID0gY29yZUV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRIb3RrZXlzRW5hYmxlZCA9IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaG90a2V5c0VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLy8gVG9vbEludGVyZmFjZSBtZXRob2RzIC8vXG5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZpZXdlckFwaSkge1xuICAgICAgICAgICAgdGhpcy5wYW5Ub29sID0gdmlld2VyQXBpLnRvb2xDb250cm9sbGVyLmdldFRvb2woXCJwYW5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYW5Ub29sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYW5Ub29sLmFjdGl2YXRlKFwicGFuXCIpOyAvLyBUT0RPOiBXaGF0IGlmIHdlIHdhbnQgXCJ6b29tXCIgaGVyZT9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFuVG9vbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFuVG9vbC5kZWFjdGl2YXRlKFwicGFuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYW5Ub29sID0gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihldmVudCwga2V5Q29kZSkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaG90a2V5c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ29uc3VtZSBldmVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEb24ndCBwcm9wYWdhdGUga2V5IGhhbmRsaW5nIGRvd24gdG8gdG9vbCAvL1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9kZXNrLlZpZXdpbmcuS2V5Q29kZS5DT05UUk9MOiBfY3RybERvd24gPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9kZXNrLlZpZXdpbmcuS2V5Q29kZS5TSElGVDogX3NoaWZ0RG93biA9IHRydWU7IGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvZGVzay5WaWV3aW5nLktleUNvZGUueDogX2N0cmxEb3duICYmICF0aGlzLmFsbG93TmF2ICYmIHRoaXMuY29yZUV4dC5jdXQoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvZGVzay5WaWV3aW5nLktleUNvZGUuYzogX2N0cmxEb3duICYmICF0aGlzLmFsbG93TmF2ICYmIHRoaXMuY29yZUV4dC5jb3B5KCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b2Rlc2suVmlld2luZy5LZXlDb2RlLnY6IF9jdHJsRG93biAmJiAhdGhpcy5hbGxvd05hdiAmJiB0aGlzLmNvcmVFeHQucGFzdGUoKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvZGVzay5WaWV3aW5nLktleUNvZGUuZDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jdHJsRG93biAmJiAhdGhpcy5hbGxvd05hdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRHVwbGljYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcmVFeHQuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlRXh0LnBhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvZGVzay5WaWV3aW5nLktleUNvZGUuejpcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jdHJsRG93biAmJiAhX3NoaWZ0RG93biAmJiAhdGhpcy5hbGxvd05hdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlRXh0LnVuZG8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfY3RybERvd24gJiYgX3NoaWZ0RG93biAmJiAhdGhpcy5hbGxvd05hdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JlRXh0LnJlZG8oKTsgLy8gQWxzbyBzdXBwb3J0IEN0cmwrWVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQXV0b2Rlc2suVmlld2luZy5LZXlDb2RlLnk6IF9jdHJsRG93biAmJiAhdGhpcy5hbGxvd05hdiAmJiB0aGlzLmNvcmVFeHQucmVkbygpOyBicmVhazsgLy8gQWxzbyBzdXBwb3J0IGN0cmwrc2hpZnQrelxuICAgICAgICAgICAgICAgIGNhc2UgQXV0b2Rlc2suVmlld2luZy5LZXlDb2RlLkVTQ0FQRTogdGhpcy5jb3JlRXh0LnNlbGVjdE1hcmt1cChudWxsKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDb25zdW1lIGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlS2V5VXAgPSBmdW5jdGlvbihldmVudCwga2V5Q29kZSkge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaG90a2V5c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ29uc3VtZSBldmVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEb24ndCBwcm9wYWdhdGUga2V5IGhhbmRsaW5nIGRvd24gdG8gdG9vbFxuXG4gICAgICAgICAgICBzd2l0Y2ggKGtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEF1dG9kZXNrLlZpZXdpbmcuS2V5Q29kZS5DT05UUk9MOiBfY3RybERvd24gPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBBdXRvZGVzay5WaWV3aW5nLktleUNvZGUuU0hJRlQ6IF9zaGlmdERvd24gPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDb25zdW1lIGV2ZW50IE9OTFlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dOYXYgJiYgdGhpcy5wYW5Ub29sICYmIHRoaXMucGFuVG9vbC51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaGFuZGxlU2luZ2xlQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIGJ1dHRvbiApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TmF2ICYmIHRoaXMucGFuVG9vbCAmJiB0aGlzLnBhblRvb2wuaGFuZGxlU2luZ2xlQ2xpY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLmhhbmRsZVNpbmdsZUNsaWNrKGV2ZW50LCBidXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgYnV0dG9uICkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dOYXYgJiYgdGhpcy5wYW5Ub29sICYmIHRoaXMucGFuVG9vbC5oYW5kbGVEb3VibGVDbGljaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhblRvb2wuaGFuZGxlRG91YmxlQ2xpY2soZXZlbnQsIGJ1dHRvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ29uc3VtZSBldmVudFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZVRhcCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TmF2ICYmIHRoaXMucGFuVG9vbCAmJiB0aGlzLnBhblRvb2wuaGFuZGxlU2luZ2xlVGFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuVG9vbC5oYW5kbGVTaW5nbGVUYXAoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb3VibGVUYXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd05hdiAmJiB0aGlzLnBhblRvb2wgJiYgdGhpcy5wYW5Ub29sLmhhbmRsZURvdWJsZVRhcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhblRvb2wuaGFuZGxlRG91YmxlVGFwKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDb25zdW1lIGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlV2hlZWxJbnB1dCA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd05hdiAmJiB0aGlzLnBhblRvb2wgJiYgdGhpcy5wYW5Ub29sLmhhbmRsZVdoZWVsSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLmhhbmRsZVdoZWVsSW5wdXQoZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25Eb3duID0gZnVuY3Rpb24oZXZlbnQsIGJ1dHRvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dOYXYgJiYgdGhpcy5wYW5Ub29sICYmIHRoaXMucGFuVG9vbC5oYW5kbGVCdXR0b25Eb3duKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuVG9vbC5oYW5kbGVCdXR0b25Eb3duKGV2ZW50LCBidXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25VcCA9IGZ1bmN0aW9uKGV2ZW50LCBidXR0b24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93TmF2ICYmIHRoaXMucGFuVG9vbCAmJiB0aGlzLnBhblRvb2wuaGFuZGxlQnV0dG9uVXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLmhhbmRsZUJ1dHRvblVwKGV2ZW50LCBidXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dOYXYgJiYgdGhpcy5wYW5Ub29sICYmIHRoaXMucGFuVG9vbC5oYW5kbGVNb3VzZU1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gQ29uc3VtZSBldmVudFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUdlc3R1cmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dOYXYgJiYgdGhpcy5wYW5Ub29sICYmIHRoaXMucGFuVG9vbC5oYW5kbGVHZXN0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFuVG9vbC5oYW5kbGVHZXN0dXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBDb25zdW1lIGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd05hdiAmJiB0aGlzLnBhblRvb2wgJiYgdGhpcy5wYW5Ub29sLmhhbmRsZUJsdXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYW5Ub29sLmhhbmRsZUJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIENvbnN1bWUgZXZlbnRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBuYW1lc3BhY2UuTWFya3VwVG9vbCA9IE1hcmt1cFRvb2w7XG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2tOYW1lc3BhY2UoJ0F1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUnKTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVza05hbWVzcGFjZSgnQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscycpO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogRXh0ZW5zaW9uIHVzZWQgdG8gb3ZlcmxheSAyZCBtYXJrdXBzIG92ZXIgMmQgYW5kIDNkIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5WaWV3ZXIzRH0gdmlld2VyIC0gVmlld2VyIGluc3RhbmNlIHVzZWQgdG8gb3BlcmF0ZSBvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFNhbWUgRGljdGlvbmFyeSBvYmplY3QgcGFzc2VkIGludG8gW1ZpZXdlcjNEXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLlZpZXdlcjNEfSdzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFya3VwQnlwYXNzT3J0aG9DYW1dIC0gV2hldGhlciBvcnRob2dyYXBoaWMgY2FtZXJhIGlzIGZvcmNlZCBvbnRvIDNkIG1vZGVscyB3aGVuIGNhbGxpbmdcbiAgICAgKiBbc2hvdygpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI3Nob3d9LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFya3VwRGlzYWJsZUhvdGtleXNdIC0gRGlzYWJsZXMgaG90a2V5cyBmb3IgY29weSwgY3V0LCBwYXN0ZSwgZHVwbGljYXRlLCB1bmRvLCByZWRvIGFuZCBkZXNlbGVjdC5cbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuVG9vbEludGVyZmFjZX0gW29wdGlvbnMubWFya3VwVG9vbENsYXNzXSAtIENsYXNzIG92ZXJyaWRlIGZvciBpbnB1dCBoYW5kbGluZy5cbiAgICAgKiBVc2UgaXQgdG8gb3ZlcnJpZGUvZXh0ZW5kIGRlZmF1bHQgaG90a2V5cyBhbmQvb3IgbW91c2UvZ2VzdHVyZSBpbnB1dC5cbiAgICAgKiBAbWVtYmVyb2YgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1hcmt1cHNDb3JlKHZpZXdlciwgb3B0aW9ucykge1xuXG4gICAgICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9uLmNhbGwodGhpcywgdmlld2VyLCBvcHRpb25zKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubWFya3VwcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuZHVyaW5nVmlld01vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdXJpbmdFZGl0TW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEFkZCBhY3Rpb24gbWFuYWdlci5cbiAgICAgICAgdGhpcy5hY3Rpb25NYW5hZ2VyID0gbmV3IG5hbWVzcGFjZS5FZGl0QWN0aW9uTWFuYWdlciggNTAgKTsgLy8gaGlzdG9yeSBvZiA1MCBhY3Rpb25zLlxuICAgICAgICB0aGlzLmFjdGlvbk1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lc3BhY2UuRVZFTlRfSElTVE9SWV9DSEFOR0VELCB0aGlzLm9uRWRpdEFjdGlvbkhpc3RvcnlDaGFuZ2VkLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMubmV4dElkID0gMDsgLy8gVXNlZCB0byBpZGVudGlmeSBtYXJrdXBzIGJ5IGlkIGR1cmluZyBhbiBlZGl0IHNlc3Npb24uXG5cbiAgICAgICAgLy8gQ2xpcGJvYXJkLlxuICAgICAgICB0aGlzLmNsaXBib2FyZCA9IG5ldyBuYW1lc3BhY2UuQ2xpcGJvYXJkKHRoaXMpO1xuXG4gICAgICAgIC8vIERlZmF1bHQgSW5wdXQgaGFuZGxlci5cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBuYW1lc3BhY2UuSW5wdXRIYW5kbGVyKCk7XG5cbiAgICAgICAgLy8gRXh0ZW5zaW9uIHdpbGwgZGlzcGF0Y2ggZXZlbnRzLlxuICAgICAgICBuYW1lc3BhY2VVdGlscy5hZGRUcmFpdEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcblxuICAgICAgICAvLyBIYW5kbGVkIGV2ZW50cy5cbiAgICAgICAgdGhpcy5vbkNhbWVyYUNoYW5nZUJpbmRlZCA9IHRoaXMub25DYW1lcmFDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblZpZXdlclJlc2l6ZUJpbmRlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVnbHksIGJ1dCB3ZSBuZWVkIHRvIGRvIHRoaXMgdHdpY2VcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIC8vIEZpcnN0IHVzYWdlIGlzIHRvIGF2b2lkIGEgYmxpbmtpbmcgc2NlbmFyaW9cbiAgICAgICAgICAgIHNlbGYub25WaWV3ZXJSZXNpemUoZXZlbnQpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgLy8gU2Vjb25kIG9uZSBpcyB0byBhY3R1YWxseSBtYWtlIGl0IHdvcmsgb24gc29tZSByZXNpemUgc2NlbmFyaW9zLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSB1bmxpa2VseSBzY2VuYXJpbyB0aGF0IHdlIGFyZSBubyBsb25nZXIgaW4gdmlldyBtb2RlLlxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmR1cmluZ1ZpZXdNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25WaWV3ZXJSZXNpemUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25NYXJrdXBEcmFnZ2luZ0JpbmRlZCA9IHRoaXMub25NYXJrdXBEcmFnZ2luZy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTWFya3VwU2VsZWN0ZWRCaW5kZWQgPSB0aGlzLm9uTWFya3VwU2VsZWN0ZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1hcmt1cEVudGVyRWRpdGlvbkJpbmRlZCA9IHRoaXMub25NYXJrdXBFbnRlckVkaXRpb24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1hcmt1cENhbmNlbEVkaXRpb25CaW5kZWQgPSB0aGlzLm9uTWFya3VwQ2FuY2VsRWRpdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTWFya3VwRGVsZXRlRWRpdGlvbkJpbmRlZCA9IHRoaXMub25NYXJrdXBEZWxldGVFZGl0aW9uLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgTWFya3Vwc0NvcmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbi5wcm90b3R5cGUpO1xuICAgIE1hcmt1cHNDb3JlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcmt1cHNDb3JlO1xuICAgIG5hbWVzcGFjZS5NYXJrdXBzQ29yZSA9IE1hcmt1cHNDb3JlO1xuXG4gICAgLypcbiAgICAgKiBFdmVudCB0eXBlc1xuICAgICAqL1xuICAgIG5hbWVzcGFjZS5FVkVOVF9FTlRFUl9FRElUX01PREUgPSBcIkVWRU5UX01BUktVUF9DT1JFX0VOVEVSX0VESVRfTU9ERVwiO1xuICAgIG5hbWVzcGFjZS5FVkVOVF9MRUFWRV9FRElUX01PREUgPSBcIkVWRU5UX01BUktVUF9DT1JFX0xFQVZFX0VESVRfTU9ERVwiO1xuICAgIG5hbWVzcGFjZS5FVkVOVF9TRUxFQ1RJT05fQ0hBTkdFRCA9IFwiRVZFTlRfTUFSS1VQX1NFTEVDVElPTl9DSEFOR0VEXCI7XG5cbiAgICB2YXIgcHJvdG8gPSBNYXJrdXBzQ29yZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5sb2FkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8vIEFkZCBsYXllciB3aGVyZSBhbm5vdGF0aW9ucyB3aWxsIGFjdHVhbGx5IGxpdmVcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgnc3ZnJyk7XG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLnNldFN2Z1BhcmVudEF0dHJpYnV0ZXMoc3ZnKTtcblxuICAgICAgICAvLyBOT1RFOiBSZXF1aXJlZCBzaW5jZSBMTVYgcmVuZGVycyBZIGNvb3JkaW5hdGVzIHVwd2FyZHMsXG4gICAgICAgIC8vIHdoaWxlIGJyb3dzZXIncyBZIGNvb3JkaW5hdGVzIGdvZXMgZG93bndhcmRzLlxuICAgICAgICB2YXIgc3ZnU3R5bGUgPSBuZXcgbmFtZXNwYWNlVXRpbHMuRG9tRWxlbWVudFN0eWxlKCk7XG4gICAgICAgIHN2Z1N0eWxlLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgc3ZnU3R5bGUuc2V0QXR0cmlidXRlKCdsZWZ0JywgJzAnKTtcbiAgICAgICAgc3ZnU3R5bGUuc2V0QXR0cmlidXRlKCd0b3AnLCAnMCcpO1xuICAgICAgICBzdmdTdHlsZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICdzY2FsZSgxLC0xKScsIHsgYWxsQnJvd3NlcnM6IHRydWV9KTtcbiAgICAgICAgc3ZnU3R5bGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm1PcmlnaW4nLCAnMCwgMCcsIHsgYWxsQnJvd3NlcnM6IHRydWV9KTtcbiAgICAgICAgc3ZnU3R5bGUuc2V0QXR0cmlidXRlKCdjdXJzb3InLCAnZGVmYXVsdCcpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN2Z1N0eWxlLmdldFN0eWxlU3RyaW5nKCkpO1xuXG4gICAgICAgIHRoaXMuYm91bmRzID0ge3g6MCwgeTowLCB3aWR0aDowLCBoZWlnaHQ6MH07XG5cbiAgICAgICAgdGhpcy5pbnB1dC5hdHRhY2hUbyh0aGlzKTtcblxuICAgICAgICAvL0luc3RhbnRpYXRlIGVkaXQgZnJhbWUuXG4gICAgICAgIHRoaXMuZWRpdEZyYW1lID0gbmV3IG5hbWVzcGFjZS5FZGl0RnJhbWUodGhpcy52aWV3ZXIuY29udGFpbmVyLCB0aGlzKTtcbiAgICAgICAgdGhpcy5lZGl0RnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lc3BhY2UuRVZFTlRfRURJVEZSQU1FX0VESVRJT05fU1RBUlQsIGZ1bmN0aW9uKCl7dGhpcy5kaXNhYmxlTWFya3VwSW50ZXJhY3Rpb25zKHRydWUpO30uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZWRpdEZyYW1lLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX0VESVRGUkFNRV9FRElUSU9OX0VORCwgZnVuY3Rpb24oKXt0aGlzLmRpc2FibGVNYXJrdXBJbnRlcmFjdGlvbnMoZmFsc2UpO30uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgdG9vbFxuICAgICAgICB2YXIgdG9vbENsYXNzID0gdGhpcy5vcHRpb25zLm1hcmt1cFRvb2xDbGFzcyB8fCBuYW1lc3BhY2UuTWFya3VwVG9vbDtcbiAgICAgICAgdGhpcy5tYXJrdXBUb29sID0gbmV3IHRvb2xDbGFzcygpO1xuICAgICAgICB0aGlzLm1hcmt1cFRvb2wuc2V0Q29yZUV4dGVuc2lvbih0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrdXBUb29sLnNldEhvdGtleXNFbmFibGVkKCF0aGlzLm9wdGlvbnMubWFya3VwRGlzYWJsZUhvdGtleXMpO1xuICAgICAgICB0aGlzLnZpZXdlci50b29sQ29udHJvbGxlci5yZWdpc3RlclRvb2wodGhpcy5tYXJrdXBUb29sKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5oaWRlKCk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5kZXRhY2hGcm9tKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hcmt1cFRvb2wpIHtcbiAgICAgICAgICAgIHRoaXMudmlld2VyLnRvb2xDb250cm9sbGVyLmRlcmVnaXN0ZXJUb29sKHRoaXMubWFya3VwVG9vbCk7XG4gICAgICAgICAgICB0aGlzLm1hcmt1cFRvb2wgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnO1xuICAgICAgICBpZiAoc3ZnICYmIHRoaXMub25Nb3VzZURvd25CaW5kZWQpIHtcbiAgICAgICAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd25CaW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bkJpbmRlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN2Zy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBzdmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdE1vZGVTdmdMYXllck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnN2ZyA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLnRvZ2dsZUVkaXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmR1cmluZ0VkaXRNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmxlYXZlRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgY2xpY2svdG91Y2ggaW50ZXJhY3Rpb25zIG92ZXIgVmlld2VyIGNhbnZhcyB0byBjcmVhdGUvZHJhdyBtYXJrdXBzLjxicj5cbiAgICAgKiBFeGl0IGVkaXRNb2RlIGJ5IGNhbGxpbmcgW2xlYXZlRWRpdE1vZGUoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNsZWF2ZUVkaXRNb2RlfS48YnI+XG4gICAgICogU2VlIGFsc286XG4gICAgICogW3Nob3coKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNzaG93fVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgZWRpdE1vZGUgaXMgYWN0aXZlXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuZW50ZXJFZGl0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFJldHVybiBpZiBhbHJlYWR5IGluIGVkaXQgbW9kZS5cbiAgICAgICAgaWYgKHRoaXMuZHVyaW5nRWRpdE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm90IGN1cnJlbnRseSBzaG93biwgdGhlbiBzaG93XG4gICAgICAgIGlmICghdGhpcy5kdXJpbmdWaWV3TW9kZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3coKSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBGYWlsZWQgdG8gZW50ZXIgdmlldyBtb2RlLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgnZycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ZnLmluc2VydEJlZm9yZSh0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlLCB0aGlzLnN2Zy5maXJzdENoaWxkKTtcblxuICAgICAgICB0aGlzLmlucHV0LmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuc2V0QWN0aXZlTmF2aWdhdGlvblRvb2wodGhpcy5tYXJrdXBUb29sLmdldE5hbWUoKSk7XG4gICAgICAgIHRoaXMuYWxsb3dOYXZpZ2F0aW9uKGZhbHNlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VFZGl0TW9kZShuZXcgbmFtZXNwYWNlLkVkaXRNb2RlQXJyb3codGhpcykpO1xuICAgICAgICB0aGlzLmFjdGlvbk1hbmFnZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTsgLy8gQ2xlYXIgRWRpdE1vZGUgc3R5bGVzLlxuXG4gICAgICAgIHRoaXMuZHVyaW5nRWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0TW9kZS48YnI+XG4gICAgICogU2VlIGFsc28gW2VudGVyRWRpdE1vZGUoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNlbnRlckVkaXRNb2RlfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgZWRpdCBtb2RlIGhhcyBiZWVuIGRlYWN0aXZhdGVkXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUubGVhdmVFZGl0TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBOT1RfSU5fRURJVF9NT0RFID0gdHJ1ZTtcbiAgICAgICAgdmFyIFdFX0FSRV9TVElMTF9JTl9FRElUX01PREUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuZHVyaW5nRWRpdE1vZGUgfHwgIXRoaXMuZHVyaW5nVmlld01vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBOT1RfSU5fRURJVF9NT0RFO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpZXdlciA9IHRoaXMudmlld2VyO1xuICAgICAgICBpZiAoIXZpZXdlcikge1xuICAgICAgICAgICAgcmV0dXJuIFdFX0FSRV9TVElMTF9JTl9FRElUX01PREU7IC8vIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nLi4uXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN2Zy5yZW1vdmVDaGlsZCh0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlKTtcblxuICAgICAgICB0aGlzLmlucHV0LmxlYXZlRWRpdE1vZGUoKTtcbiAgICAgICAgdGhpcy5lZGl0RnJhbWUuc2V0TWFya3VwKG51bGwpO1xuICAgICAgICB2aWV3ZXIuc2V0QWN0aXZlTmF2aWdhdGlvblRvb2wodGhpcy5tYXJrdXBUb29sLmdldE5hbWUoKSk7XG4gICAgICAgIHRoaXMuYWxsb3dOYXZpZ2F0aW9uKHRydWUpO1xuXG4gICAgICAgIHRoaXMuZWRpdE1vZGUuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmVkaXRNb2RlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmR1cmluZ0VkaXRNb2RlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBOT1RfSU5fRURJVF9NT0RFO1xuICAgIH07XG5cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZHVyaW5nVmlld01vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBsb2FkaW5nIG9mIHByZXZpb3VzbHkgc2F2ZWQgbWFya3Vwcy48YnI+XG4gICAgICogRXhpdCBlZGl0TW9kZSBieSBjYWxsaW5nIFtoaWRlKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjaGlkZX0uPGJyPlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFtlbnRlckVkaXRNb2RlKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZW50ZXJFZGl0TW9kZX1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBpdCBzdWNjZXNzZnVsbHkgZW50ZXJlZCB2aWV3IG1vZGUgb3Igbm90LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gICAgICAgIGlmICghdmlld2VyIHx8ICF2aWV3ZXIubW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiBpZiBhbHJlYWR5IHNob3dpbmcgb3IgaW4gZWRpdC1tb2RlLlxuICAgICAgICAvLyBOb3RpY2UgdGhhdCBlZGl0IG1vZGUgcmVxdWlyZXMgdGhhdCB3ZSBhcmUgY3VycmVudGx5IHNob3coKS1pbmcuXG4gICAgICAgIGlmICh0aGlzLmR1cmluZ1ZpZXdNb2RlIHx8IHRoaXMuZHVyaW5nRWRpdE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoQXV0b2Rlc2suVmlld2luZy5DQU1FUkFfQ0hBTkdFX0VWRU5ULCB0aGlzLm9uQ2FtZXJhQ2hhbmdlQmluZGVkKTtcbiAgICAgICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoQXV0b2Rlc2suVmlld2luZy5WSUVXRVJfUkVTSVpFX0VWRU5ULCB0aGlzLm9uVmlld2VyUmVzaXplQmluZGVkKTtcblxuICAgICAgICAvLyBBZGQgcGFyZW50IHN2ZyBvZiBhbGwgbWFya3Vwcy5cbiAgICAgICAgdmlld2VyLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnN2Zyk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5lbnRlclZpZXdNb2RlKCk7XG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLmhpZGVMbXZVaSh2aWV3ZXIpO1xuXG4gICAgICAgIC8vIFRPRE86IE5hc3R5IGhhY2ssIGN1cnJlbnRseSB0aGVyZSBpcyBubyBBUEkgdG8gZGlzYWJsZSBtb3VzZSBoaWdobGlnaHRpbmcgaW4gM2QgbW9kZWxzLlxuICAgICAgICAvLyBUT0RPOiBXZSBudWtlIHJvbGxvdmVyIGZ1bmN0aW9uIGluIHZpZXdlciwgZm9yIG5vdywgcHVibGljIGFwaSB3aWxsIGJlIGFkZGVkIHNvb24uXG4gICAgICAgIHRoaXMub25WaWV3ZXJSb2xsb3Zlck9iamVjdCA9IHZpZXdlci5pbXBsLnJvbGxvdmVyT2JqZWN0O1xuICAgICAgICB2aWV3ZXIuaW1wbC5yb2xsb3Zlck9iamVjdCA9IGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tYXJrdXBCeXBhc3NPcnRob0NhbSkge1xuICAgICAgICAgICAgbmFtZXNwYWNlVXRpbHMuZm9yY2VPcnRob2dyYXBoaWNDYW1lcmEodmlld2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FjaGVkTmF2aWdhdGlvblRvb2wgPSB0aGlzLnZpZXdlci5nZXRBY3RpdmVOYXZpZ2F0aW9uVG9vbCgpO1xuICAgICAgICB2aWV3ZXIuc2V0QWN0aXZlTmF2aWdhdGlvblRvb2wodGhpcy5tYXJrdXBUb29sLmdldE5hbWUoKSk7XG4gICAgICAgIHRoaXMuYWxsb3dOYXZpZ2F0aW9uKHRydWUpO1xuICAgICAgICB2YXIgY2FtZXJhID0gdmlld2VyLmltcGwuY2FtZXJhO1xuICAgICAgICB0aGlzLm9uVmlld2VyUmVzaXplKHsgd2lkdGg6IGNhbWVyYS5jbGllbnRXaWR0aCwgaGVpZ2h0OiBjYW1lcmEuY2xpZW50SGVpZ2h0IH0pO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gU2VlIGZ1bmN0aW9uIGxvYWRNYXJrdXBzKCkgZm9yIHdoZW4gdGhlIGFjdHVhbCBTVkcgZ2V0cyBhZGRlZCBvbnN0YWdlIC8vXG4gICAgICAgIHRoaXMuc3ZnTGF5ZXJzTWFwID0ge307XG4gICAgICAgIHRoaXMuZHVyaW5nVmlld01vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgbWFya3VwIGN1cnJlbnRseSBvdmVybGFpZCBvbiB0aGUgdmlld2VyLiBJdCB3aWxsIGFsc28gZXhpdCBFZGl0TW9kZSBpZiBpdCBpcyBhY3RpdmUuPGJyPlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFtzaG93KClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjc2hvd31cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBpdCBzdWNjZXNzZnVsbHkgbGVmdCB2aWV3IG1vZGUgb3Igbm90LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgUkVTVUxUX0hJREVfT0sgPSB0cnVlO1xuICAgICAgICB2YXIgUkVTVUxUX0hJREVfRkFJTCA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB2aWV3ZXIgPSB0aGlzLnZpZXdlcjtcbiAgICAgICAgaWYgKCF2aWV3ZXIgfHwgIXRoaXMuZHVyaW5nVmlld01vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBSRVNVTFRfSElERV9PSztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmR1cmluZ0VkaXRNb2RlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGVhdmVFZGl0TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJFU1VMVF9ISURFX0ZBSUw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2aWV3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBdXRvZGVzay5WaWV3aW5nLkNBTUVSQV9DSEFOR0VfRVZFTlQsIHRoaXMub25DYW1lcmFDaGFuZ2VCaW5kZWQpO1xuICAgICAgICB2aWV3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihBdXRvZGVzay5WaWV3aW5nLlZJRVdFUl9SRVNJWkVfRVZFTlQsIHRoaXMub25WaWV3ZXJSZXNpemVCaW5kZWQpO1xuXG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnN2ZztcbiAgICAgICAgc3ZnLnBhcmVudE5vZGUgJiYgc3ZnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3ZnKTtcblxuICAgICAgICAvLyBSZW1vdmUgYWxsIE1hcmt1cHMgYW5kIG1ldGFkYXRhIChpZiBhbnkpXG4gICAgICAgIHRoaXMudW5sb2FkTWFya3Vwc0FsbExheWVycygpO1xuICAgICAgICBuYW1lc3BhY2VVdGlscy5yZW1vdmVBbGxNZXRhZGF0YShzdmcpO1xuXG4gICAgICAgIHRoaXMuaW5wdXQubGVhdmVWaWV3TW9kZSgpO1xuICAgICAgICBuYW1lc3BhY2VVdGlscy5yZXN0b3JlTG12VWkodmlld2VyKTtcbiAgICAgICAgdGhpcy52aWV3ZXIuaW1wbC5yb2xsb3Zlck9iamVjdCA9IHRoaXMub25WaWV3ZXJSb2xsb3Zlck9iamVjdDtcblxuICAgICAgICB0aGlzLnZpZXdlci5zZXRBY3RpdmVOYXZpZ2F0aW9uVG9vbCh0aGlzLmNhY2hlZE5hdmlnYXRpb25Ub29sKTtcbiAgICAgICAgdGhpcy5jYWNoZWROYXZpZ2F0aW9uVG9vbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5kdXJpbmdWaWV3TW9kZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gUkVTVUxUX0hJREVfT0s7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIG1hcmt1cHMgZnJvbSBzY3JlZW4uPGJyPlxuICAgICAqIE1hcmt1cHMgc2hvdWxkIGhhdmUgYmVlbiBhZGRlZCB3aGlsZSBpblxuICAgICAqIFtFZGl0IE1vZGVde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZW50ZXJFZGl0TW9kZX0uXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwcyA9IHRoaXMubWFya3VwcztcbiAgICAgICAgd2hpbGUobWFya3Vwcy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBzWzBdO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVNYXJrdXAobWFya3VwKTtcbiAgICAgICAgICAgIG1hcmt1cC5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IG5vIG90aGVyIG1hcmt1cHMgc2hvdWxkIGJlIGF2YWlsYWJsZS5cbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuZWRpdE1vZGVTdmdMYXllck5vZGU7XG4gICAgICAgIGlmIChzdmcgJiYgc3ZnLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHN2Zy5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN2Zy5yZW1vdmVDaGlsZChzdmcuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBTVkcgc3RyaW5nIHdpdGggdGhlIG1hcmt1cHMgY3JlYXRlZCBzbyBmYXIuPGJyPlxuICAgICAqIE1hcmt1cHMgc2hvdWxkIGhhdmUgYmVlbiBhZGRlZCB3aGlsZSBpblxuICAgICAqIFtFZGl0IE1vZGVde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZW50ZXJFZGl0TW9kZX0uXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5nZW5lcmF0ZURhdGEgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBTYW5pdHkgY2hlY2ssIHJlbW92ZSBhbnkgbGluZ2VyaW5nIG1ldGFkYXRhIG5vZGVzXG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLnJlbW92ZUFsbE1ldGFkYXRhKHRoaXMuc3ZnKTtcblxuXG4gICAgICAgIHZhciB0bXBOb2RlID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudChcInN2Z1wiKTtcbiAgICAgICAgbmFtZXNwYWNlVXRpbHMudHJhbnNmZXJDaGlsZE5vZGVzKHRoaXMuc3ZnLCB0bXBOb2RlKTsgLy8gVHJhbnNmZXIgaW5jbHVkZXMgdGhpcy5lZGl0TW9kZVN2Z0xheWVyTm9kZVxuICAgICAgICBuYW1lc3BhY2VVdGlscy50cmFuc2ZlckNoaWxkTm9kZXModGhpcy5lZGl0TW9kZVN2Z0xheWVyTm9kZSwgdGhpcy5zdmcpO1xuXG4gICAgICAgIHZhciBtZXRhZGF0YU9iamVjdCA9IHtcbiAgICAgICAgICAgIFwiZGF0YS1tb2RlbC12ZXJzaW9uXCI6IFwiMVwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZXRhZGF0YU5vZGUgPSBuYW1lc3BhY2VVdGlscy5hZGRTdmdNZXRhZGF0YSh0aGlzLnN2ZywgbWV0YWRhdGFPYmplY3QpO1xuICAgICAgICB2YXIgbWV0YWRhdGFOb2RlcyA9IFsgbWV0YWRhdGFOb2RlIF07XG5cbiAgICAgICAgLy8gTm90aWZ5IGVhY2ggbWFya3VwIHRvIGluamVjdCBtZXRhZGF0YVxuICAgICAgICB0aGlzLm1hcmt1cHMuZm9yRWFjaChmdW5jdGlvbihtYXJrdXApe1xuICAgICAgICAgICAgdmFyIGFkZGVkTm9kZSA9IG1hcmt1cC5zZXRNZXRhZGF0YSgpO1xuICAgICAgICAgICAgaWYgKGFkZGVkTm9kZSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhTm9kZXMucHVzaChhZGRlZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgZGF0YSFcbiAgICAgICAgdmFyIGRhdGEgPSBuYW1lc3BhY2VVdGlscy5zdmdOb2RlVG9TdHJpbmcodGhpcy5zdmcpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtZXRhZGF0YU9iamVjdCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgICAgIG1ldGFkYXRhTm9kZXMuZm9yRWFjaChmdW5jdGlvbihtZXRhZGF0YU5vZGUpe1xuICAgICAgICAgICAgbWV0YWRhdGFOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobWV0YWRhdGFOb2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmFtZXNwYWNlVXRpbHMudHJhbnNmZXJDaGlsZE5vZGVzKHRoaXMuc3ZnLCB0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlKTtcbiAgICAgICAgbmFtZXNwYWNlVXRpbHMudHJhbnNmZXJDaGlsZE5vZGVzKHRtcE5vZGUsIHRoaXMuc3ZnKTtcbiAgICAgICAgdG1wTm9kZSA9IG51bGw7IC8vIGdldCByaWQgb2YgaXQuXG5cbiAgICAgICAgcmV0dXJuICBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIG1hcmt1cHMgY3VycmVudGx5IHByZXNlbnQgb24gdGhlIGNhbnZhcyB0byBiZSByZW5kZXJlZCBpbnRvIGEgJmx0O2NhbnZhcyZndDsgMmQgY29udGV4dC48YnI+XG4gICAgICogSW50ZXJuYWxseSwgaXQgd2lsbCB1c2UgZWFjaCBFZGl0TW9kZSdzIHJlbmRlclRvQ2FudmFzKCkgYXBpLjxicj5cbiAgICAgKiBUaGUgaW50ZW5kZWQgdXNlLWNhc2UgaXMgdG8gZ2VuZXJhdGUgYW4gaW1hZ2UuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5yZW5kZXJUb0NhbnZhcyA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXJrdXBzLmZvckVhY2goZnVuY3Rpb24obWFya3VwKXtcbiAgICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgbWFya3VwLnJlbmRlclRvQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBhY3RpdmUgZHJhd2luZyB0b29sLjxicj5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG8gY2hhbmdlIGZyb20sIGZvciBleGFtcGxlOiB0aGUgQXJyb3cgZHJhd2luZyB0b29sIGludG8gdGhlIFJlY3RhbmdsZSBkcmF3aW5nIHRvb2wuPGJyPlxuICAgICAqIEFwcGxpY2FibGUgb25seSB3aGlsZSBpbiBbRWRpdCBNb2RlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2VudGVyRWRpdE1vZGV9Ljxicj5cbiAgICAgKiBGaXJlcyBFVkVOVF9FRElUTU9ERV9DSEFOR0VEXG4gICAgICogQHBhcmFtIGVkaXRNb2RlXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuY2hhbmdlRWRpdE1vZGUgPSBmdW5jdGlvbihlZGl0TW9kZSkge1xuXG4gICAgICAgIHZhciBvbGRFZGl0TW9kZSA9IHRoaXMuZWRpdE1vZGU7XG4gICAgICAgIG9sZEVkaXRNb2RlICYmIG9sZEVkaXRNb2RlLmRlc3Ryb3koKTtcblxuICAgICAgICBlZGl0TW9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9FRElUTU9ERV9DUkVBVElPTl9CRUdJTiwgZnVuY3Rpb24oKSB7dGhpcy5kaXNhYmxlTWFya3VwSW50ZXJhY3Rpb25zKHRydWUpO30uYmluZCh0aGlzKSk7XG4gICAgICAgIGVkaXRNb2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX0VESVRNT0RFX0NSRUFUSU9OX0VORCwgZnVuY3Rpb24oKXt0aGlzLmRpc2FibGVNYXJrdXBJbnRlcmFjdGlvbnMoZmFsc2UpO30uYmluZCh0aGlzKSk7XG4gICAgICAgIGVkaXRNb2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9ERVNFTEVDVCwgZnVuY3Rpb24oZXZlbnQpe3RoaXMuZmlyZUV2ZW50KGV2ZW50KTt9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSBlZGl0TW9kZTtcbiAgICAgICAgdGhpcy5zdHlsZXNbZWRpdE1vZGUudHlwZV0gPSBuYW1lc3BhY2VVdGlscy5jbG9uZVN0eWxlKGVkaXRNb2RlLmdldFN0eWxlKCkpO1xuXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHt0eXBlOm5hbWVzcGFjZS5FVkVOVF9FRElUTU9ERV9DSEFOR0VELCB0YXJnZXQ6IGVkaXRNb2RlfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoaWxlIGluIFtFZGl0IE1vZGVde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZW50ZXJFZGl0TW9kZX0sXG4gICAgICogaXQgc3dpdGNoZXMgdGhlIGNsaWNrL3RhcC9zd2lwZSBiZWhhdmlvciB0byBhbGxvdyBjYW1lcmEgem9vbSBhbmQgcGFubmluZyBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyAtIFdoZXRoZXIgY2FtZXJhIG5hdmlnYXRpb24gaW50ZXJhY3Rpb25zIGFyZSBhY3RpdmUgb3Igbm90LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLmFsbG93TmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGFsbG93KSB7XG5cbiAgICAgICAgdmFyIGVkaXRNb2RlID0gdGhpcy5lZGl0TW9kZTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gYWxsb3c7XG5cbiAgICAgICAgaWYgKGFsbG93KXtcbiAgICAgICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgIGVkaXRNb2RlICYmIHRoaXMuc2VsZWN0TWFya3VwKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwicG9pbnRlci1ldmVudHNcIiwgXCJwYWludGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXJrdXBUb29sLmFsbG93TmF2aWdhdGlvbihhbGxvdyk7XG4gICAgICAgIGVkaXRNb2RlICYmIGVkaXRNb2RlLm5vdGlmeUFsbG93TmF2aWdhdGlvbihhbGxvdyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgbW91c2UvdGFwIGludGVyYWN0aW9ucyB3aXRoIGFsbCBNYXJrdXBzIHByZXNlbnQgd2hpbGUgaW5cbiAgICAgKiBbRWRpdCBNb2RlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2VudGVyRWRpdE1vZGV9LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZSAtIFdoZXRoZXIgbWFya3VwcyB3aWxsIGludGVyYWN0IHdpdGggbW91c2UvdGFwIGFjdGlvbnMuXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuZGlzYWJsZU1hcmt1cEludGVyYWN0aW9ucyA9IGZ1bmN0aW9uKGRpc2FibGUpIHtcblxuICAgICAgICB0aGlzLm1hcmt1cHMuZm9yRWFjaChmdW5jdGlvbihtYXJrdXApIHttYXJrdXAuZGlzYWJsZUludGVyYWN0aW9ucyhkaXNhYmxlKTt9KTtcbiAgICB9O1xuXG4gICAgLy8vLyBJbnB1dCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHByb3RvLmNoYW5nZUlucHV0SGFuZGxlciA9IGZ1bmN0aW9uKGlucHV0SGFuZGxlcikge1xuXG4gICAgICAgIHRoaXMuaW5wdXQuZGV0YWNoRnJvbSh0aGlzKTtcbiAgICAgICAgaW5wdXRIYW5kbGVyLmF0dGFjaFRvKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXRIYW5kbGVyO1xuXG4gICAgICAgIGlmICh0aGlzLmR1cmluZ0VkaXRNb2RlKSB7XG4gICAgICAgICAgICBpbnB1dEhhbmRsZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHVyaW5nVmlld01vZGUpIHtcbiAgICAgICAgICAgIGlucHV0SGFuZGxlci5lbnRlclZpZXdNb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLyBDb3B5IGFuZCBQYXN0ZSBTeXN0ZW0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIGNvcHkgb3BlcmF0aW9uLiBBcHBsaWVzIHRvIGFueSBzZWxlY3RlZCBNYXJrdXAuIEl0IGhhcyBlZmZlY3Qgb25seSB3aGVuIGEgbWFya3VwIGlzIHNlbGVjdGVkLjxicj5cbiAgICAgKiBTZWUgYWxzb1xuICAgICAqIFtjdXQoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNjdXR9IGFuZFxuICAgICAqIFtwYXN0ZSgpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI3Bhc3RlfS5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuY29weSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBjdXQgb3BlcmF0aW9uLiBBcHBsaWVzIHRvIGFueSBzZWxlY3RlZCBNYXJrdXAsIHdoaWNoIGdldHMgcmVtb3ZlZCBmcm9tIHNjcmVlbiBhdCBjYWxsIHRpbWUuPGJyPlxuICAgICAqIFNlZSBhbHNvXG4gICAgICogW2NvcHkoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNjb3B5fSBhbmRcbiAgICAgKiBbcGFzdGUoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNwYXN0ZX0uXG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuY3V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jbGlwYm9hcmQuY3V0KCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIHBhc3RlIG9wZXJhdGlvbi4gV2lsbCBwYXN0ZSBhZGQgdG8gc3RhZ2UgYW55IHByZXZpb3VzbHkgY29waWVkIG9yIGN1dCBtYXJrdXAuXG4gICAgICogQ2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFmdGVyIGFmdGVyIGEgc2luZ2xlIGNvcHkgb3IgY3V0IG9wZXJhdGlvbi48YnI+XG4gICAgICogU2VlIGFsc29cbiAgICAgKiBbY29weSgpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2NvcHl9IGFuZFxuICAgICAqIFtjdXQoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNjdXR9LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLnBhc3RlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jbGlwYm9hcmQucGFzdGUoKTtcbiAgICB9O1xuXG4gICAgLy8vLyBVbmRvIGFuZCBSZWRvIFN5c3RlbSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvKipcbiAgICAgKiBXaWxsIHVuZG8gdGhlIHByZXZpb3VzIG9wZXJhdGlvbi48YnI+XG4gICAgICogVGhlIFVuZG8vUmVkbyBzdGFja3Mgd2lsbCB0cmFjayBhbnkgY2hhbmdlIGRvbmUgdGhyb3VnaCBhbiBFZGl0QWN0aW9uLjxicj5cbiAgICAgKiBTZWUgYWxzb1xuICAgICAqIFtyZWRvKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjcmVkb30sXG4gICAgICogW2lzVW5kb1N0YWNrRW1wdHkoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNpc1VuZG9TdGFja0VtcHR5fS5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hY3Rpb25NYW5hZ2VyLnVuZG8oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2lsbCByZWRvIGFuZCBwcmV2aW91c2x5IHVuZG8gb3BlcmF0aW9uLjxicj5cbiAgICAgKiBTZWUgYWxzb1xuICAgICAqIFt1bmRvKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjdW5kb30sXG4gICAgICogW2lzUmVkb1N0YWNrRW1wdHkoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNpc1JlZG9TdGFja0VtcHR5fS5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hY3Rpb25NYW5hZ2VyLnJlZG8oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIHdoZW4gW3VuZG8oKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSN1bmRvfVxuICAgICAqIHdpbGwgcHJvZHVjZSBubyBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuaXNVbmRvU3RhY2tFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbk1hbmFnZXIuaXNVbmRvU3RhY2tFbXB0eSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiBbcmVkbygpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI3JlZG99XG4gICAgICogd2lsbCBwcm9kdWNlIG5vIGNoYW5nZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5pc1JlZG9TdGFja0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uTWFuYWdlci5pc1JlZG9TdGFja0VtcHR5KCk7XG4gICAgfTtcblxuICAgIHByb3RvLmJlZ2luQWN0aW9uR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFjdGlvbk1hbmFnZXIuYmVnaW5BY3Rpb25Hcm91cCgpO1xuICAgIH07XG5cbiAgICBwcm90by5jbG9zZUFjdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hY3Rpb25NYW5hZ2VyLmNsb3NlQWN0aW9uR3JvdXAoKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uY2FuY2VsQWN0aW9uR3JvdXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFjdGlvbk1hbmFnZXIuY2FuY2VsQWN0aW9uR3JvdXAoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBtYXJrdXAgaWRzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZS5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKyt0aGlzLm5leHRJZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbkVkaXRBY3Rpb25IaXN0b3J5Q2hhbmdlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICB2YXIgZWRpdE1vZGUgPSB0aGlzLmVkaXRNb2RlO1xuXG4gICAgICAgIHZhciBrZWVwU2VsZWN0aW9uID0gZWRpdE1vZGUgJiYgZWRpdE1vZGUuc2VsZWN0ZWRNYXJrdXAgJiYgZWRpdE1vZGUuc2VsZWN0ZWRNYXJrdXAuaWQgPT09IGRhdGEudGFyZ2V0SWQ7XG5cbiAgICAgICAgaWYoKGRhdGEuYWN0aW9uICE9PSAndW5kbycgJiYgZGF0YS50YXJnZXRJZCAhPT0gLTEpIHx8XG4gICAgICAgICAgICBkYXRhLmFjdGlvbiA9PT0gJ3VuZG8nICYmIGtlZXBTZWxlY3Rpb24pIHtcblxuICAgICAgICAgICAgLy8gTWFya3VwIGNhbiBiZSBudWxsIHdoZW4gZGVsZXRpbmcsIHRoYXQncyBvaywgd2UgdW5zZWxlY3QgaW4gdGhhdCBjYXNlLlxuICAgICAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuZ2V0TWFya3VwKGRhdGEudGFyZ2V0SWQpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RNYXJrdXAobWFya3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcmt1cCB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuIFJldHVybnMgbnVsbCB3aGVuIG5vdCBmb3VuZC48YnI+XG4gICAgICogU2VlIGFsc286XG4gICAgICogW2dldFNlbGVjdGlvbigpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2dldFNlbGVjdGlvbn0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIE1hcmt1cCBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cH1cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5nZXRNYXJrdXAgPSBmdW5jdGlvbihpZCkge1xuXG4gICAgICAgIHZhciBtYXJrdXBzID0gdGhpcy5tYXJrdXBzO1xuICAgICAgICB2YXIgbWFya3Vwc0NvdW50ID0gbWFya3Vwcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcmt1cHNDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobWFya3Vwc1tpXS5pZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXJrdXBzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIG1hcmt1cC4gIEEgc2VsZWN0ZWQgbWFya3VwIGdldHMgYW4gb3ZlcmxheWVkIFVJIHRoYXQgYWxsb3dzIHRyYW5zZm9ybWF0aW9ucyBzdWNoXG4gICAgICogYXMgcmVzaXppbmcsIHJvdGF0aW9ucyBhbmQgdHJhbnNsYXRpb24uPGJyPlxuICAgICAqIEFsbG93cyBzZW5kaW5nIG51bGwgdG8gcmVtb3ZlIHNlbGVjdGlvbiBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbWFya3VwLlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFtnZXRNYXJrdXAoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNnZXRNYXJrdXB9LlxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXB8bnVsbH0gbWFya3VwIE1hcmt1cCBpbnN0YW5jZSB0byBzZWxlY3QsIG9yIG51bGwuXG4gICAgICovXG4gICAgcHJvdG8uc2VsZWN0TWFya3VwID0gZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0TW9kZS50eXBlID09PSBtYXJrdXAudHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdE1vZGUuc2V0U2VsZWN0aW9uKG1hcmt1cCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRNb2RlID0gbWFya3VwLmdldEVkaXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgZWRpdE1vZGUuc2V0U2VsZWN0aW9uKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VFZGl0TW9kZShlZGl0TW9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZShtYXJrdXAuZ2V0U3R5bGUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0TW9kZS5zZXRTZWxlY3Rpb24obWFya3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZS5zZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIE1hcmt1cC4gIEEgc2VsZWN0ZWQgbWFya3VwIGhhcyBjdXN0b20gVUkgb3ZlcmxheWVkIHRoYXQgYWxsb3dzIGZvclxuICAgICAqIHJlc2l6aW5nLCByb3RhdGlvbiBhbmQgdHJhbnNsYXRpb24uPGJyPlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFtzZWxlY3RNYXJrdXAoKV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSNzZWxlY3RNYXJrdXB9LlxuICAgICAqIEByZXR1cm5zIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHxudWxsfVxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRNb2RlLmdldFNlbGVjdGlvbigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgbWFya3VwIGZyb20gdGhlIHNjZW5lLiBBcHBsaWVzIG9ubHkgd2hpbGUgaW5cbiAgICAgKiBbRWRpdCBNb2RlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2VudGVyRWRpdE1vZGV9LlxuICAgICAqIEBwYXJhbSB7QXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXB9IG1hcmt1cFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RvbnRBZGRUb0hpc3RvcnldIFdoZXRoZXIgZGVsZXRlIGFjdGlvbiBjYW4gYmUgW3VuZG9uZV17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5NYXJrdXBzQ29yZSN1bmRvfS5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXAsIGRvbnRBZGRUb0hpc3RvcnkpIHtcblxuICAgICAgICB2YXIgZWRpdE1vZGUgPSBtYXJrdXAuZ2V0RWRpdE1vZGUoKTtcbiAgICAgICAgZWRpdE1vZGUuZGVsZXRlTWFya3VwKG1hcmt1cCwgZG9udEFkZFRvSGlzdG9yeSk7XG4gICAgfTtcblxuICAgIHByb3RvLmFkZE1hcmt1cCA9IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIG1hcmt1cC5zZXRQYXJlbnQodGhpcy5lZGl0TW9kZVN2Z0xheWVyTm9kZSk7XG5cbiAgICAgICAgbWFya3VwLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9TRUxFQ1RFRCwgdGhpcy5vbk1hcmt1cFNlbGVjdGVkQmluZGVkKTtcbiAgICAgICAgbWFya3VwLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9EUkFHR0lORywgdGhpcy5vbk1hcmt1cERyYWdnaW5nQmluZGVkKTtcbiAgICAgICAgbWFya3VwLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9FTlRFUl9FRElUSU9OLCB0aGlzLm9uTWFya3VwRW50ZXJFZGl0aW9uQmluZGVkKTtcbiAgICAgICAgbWFya3VwLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9DQU5DRUxfRURJVElPTiwgdGhpcy5vbk1hcmt1cENhbmNlbEVkaXRpb25CaW5kZWQpO1xuICAgICAgICBtYXJrdXAuYWRkRXZlbnRMaXN0ZW5lcihuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX0RFTEVURV9FRElUSU9OLCB0aGlzLm9uTWFya3VwRGVsZXRlRWRpdGlvbkJpbmRlZCk7XG5cbiAgICAgICAgdGhpcy5tYXJrdXBzLnB1c2gobWFya3VwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya3VwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgICAgICBtYXJrdXAuc2V0UGFyZW50KG51bGwpO1xuXG4gICAgICAgIG1hcmt1cC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfU0VMRUNURUQsIHRoaXMub25NYXJrdXBTZWxlY3RlZEJpbmRlZCk7XG4gICAgICAgIG1hcmt1cC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfRFJBR0dJTkcsIHRoaXMub25NYXJrdXBEcmFnZ2luZ0JpbmRlZCk7XG4gICAgICAgIG1hcmt1cC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfRU5URVJfRURJVElPTiwgdGhpcy5vbk1hcmt1cEVudGVyRWRpdGlvbkJpbmRlZCk7XG4gICAgICAgIG1hcmt1cC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9NQVJLVVBfQ0FOQ0VMX0VESVRJT04sIHRoaXMub25NYXJrdXBDYW5jZWxFZGl0aW9uQmluZGVkKTtcbiAgICAgICAgbWFya3VwLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX01BUktVUF9ERUxFVEVfRURJVElPTiwgdGhpcy5vbk1hcmt1cERlbGV0ZUVkaXRpb25CaW5kZWQpO1xuXG4gICAgICAgIHZhciBtYXJrdXBzID0gdGhpcy5tYXJrdXBzO1xuICAgICAgICB2YXIgbWFya3Vwc0luZGV4ID0gbWFya3Vwcy5pbmRleE9mKG1hcmt1cCk7XG4gICAgICAgIGlmIChtYXJrdXBzSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBtYXJrdXBzLnNwbGljZShtYXJrdXBzSW5kZXgsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRNb2RlID0gdGhpcy5lZGl0TW9kZTtcbiAgICAgICAgaWYgKGVkaXRNb2RlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRNYXJrdXAgPSBlZGl0TW9kZS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE1hcmt1cCA9PT0gbWFya3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RNYXJrdXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8vLyBNYXJrdXBzIHN0eWxlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIHByb3RvLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcblxuICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5zdHlsZXM7XG4gICAgICAgIHZhciBlZGl0TW9kZSA9IHRoaXMuZWRpdE1vZGU7XG5cbiAgICAgICAgbmFtZXNwYWNlVXRpbHMuY29weVN0eWxlKHN0eWxlLCBzdHlsZXNbZWRpdE1vZGUudHlwZV0pO1xuICAgICAgICBlZGl0TW9kZS5zZXRTdHlsZShzdHlsZXNbZWRpdE1vZGUudHlwZV0pO1xuICAgIH07XG5cbiAgICBwcm90by5nZXRTdHlsZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuYW1lc3BhY2VVdGlscy5jbG9uZVN0eWxlKHRoaXMuc3R5bGVzW3RoaXMuZWRpdE1vZGUudHlwZV0pO1xuICAgIH07XG5cbiAgICAvLy8vIE1hcmt1cHMgZGVwdGggb3JkZXIgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya3VwXG4gICAgICovXG4gICAgcHJvdG8uYnJpbmdUb0Zyb250ID0gZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdGhpcy5zZW5kTWFya3VwVG8obWFya3VwLCB0aGlzLm1hcmt1cHMubGVuZ3RoLTEpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXJrdXBcbiAgICAgKi9cbiAgICBwcm90by5zZW5kVG9CYWNrID0gZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdGhpcy5zZW5kTWFya3VwVG8obWFya3VwLCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya3VwXG4gICAgICovXG4gICAgcHJvdG8uYnJpbmdGb3J3YXJkID0gZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cEluZGV4ID0gdGhpcy5tYXJrdXBzLmluZGV4T2YobWFya3VwKTtcbiAgICAgICAgdGhpcy5zZW5kTWFya3VwVG8obWFya3VwLCBtYXJrdXBJbmRleCsxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWFya3VwXG4gICAgICovXG4gICAgcHJvdG8uYnJpbmdCYWNrd2FyZCA9IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIHZhciBtYXJrdXBJbmRleCA9IHRoaXMubWFya3Vwcy5pbmRleE9mKG1hcmt1cCk7XG4gICAgICAgIHRoaXMuc2VuZE1hcmt1cFRvKG1hcmt1cCwgbWFya3VwSW5kZXgtMSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG1hcmt1cFxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uc2VuZE1hcmt1cFRvID0gZnVuY3Rpb24obWFya3VwLCBpbmRleCkge1xuXG4gICAgICAgIHZhciBtYXJrdXBzID0gdGhpcy5tYXJrdXBzO1xuICAgICAgICB2YXIgbWFya3VwSW5kZXggPSBtYXJrdXBzLmluZGV4T2YobWFya3VwKTtcblxuICAgICAgICBpZiAobWFya3VwSW5kZXggIT09IC0xIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSBtYXJrdXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya3Vwcy5zcGxpY2UobWFya3VwSW5kZXgsIDEpO1xuICAgICAgICBpbmRleCA9IG1hcmt1cEluZGV4ID4gaW5kZXggPyBpbmRleCAtMSA6IGluZGV4O1xuICAgICAgICBtYXJrdXBzLnNwbGljZShpbmRleCwgMCwgbWFya3VwKTtcblxuICAgICAgICAvLyBUT0RPOiBBZGQgbWFya3VwIGluIHJpZ2h0IHBvc2l0aW9uIG5vdCBhbHdheXMgYXQgdGhlIGVuZC5cbiAgICAgICAgbWFya3VwLnNldFBhcmVudChudWxsKTtcbiAgICAgICAgbWFya3VwLnNldFBhcmVudCh0aGlzLmVkaXRNb2RlU3ZnTGF5ZXJOb2RlKTtcbiAgICB9O1xuXG4gICAgLy8vLyBTZXJpYWxpemF0aW9uIGFuZCBSZXN0b3JhdGlvbiBvZiBNYXJrdXBzICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXlzIE1hcmt1cCBkYXRhIChTVkcgc3RyaW5nKSBvbnRvIHZpZXdlcidzIGNhbnZhcy4gQSBsYXllcklkIGlzIHJlcXVpcmVkIHRvIGdyb3VwIG1hcmt1cHMgYW5kIHJlZmVyZW5jZVxuICAgICAqIHRoZW0gaW4gb3BlcmF0aW9ucyBzdWNoIGFzXG4gICAgICogW2hpZGVNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjaGlkZU1hcmt1cHN9Ljxicj5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFt1bmxvYWRNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjdW5sb2FkTWFya3Vwc30sXG4gICAgICogW2hpZGVNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjaGlkZU1hcmt1cHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hcmt1cFN0cmluZyAtIHN2ZyBzdHJpbmcgd2l0aCBtYXJrdXBzLiBTZWUgYWxzbyBbZ2VuZXJhdGVEYXRhKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjZ2VuZXJhdGVEYXRhfS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIElkZW50aWZpZXIgZm9yIHRoZSBsYXllciB3aGVyZSB0aGUgbWFya3VwIHNob3VsZCBiZSBsb2FkZWQgdG8uIEV4YW1wbGUgXCJMYXllcjFcIi5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBtYXJrdXAgc3RyaW5nIHdhcyBhYmxlIHRvIGJlIGxvYWRlZCBzdWNjZXNzZnVsbHlcbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5sb2FkTWFya3VwcyA9IGZ1bmN0aW9uIChtYXJrdXBTdHJpbmcsIGxheWVySWQpIHtcblxuICAgICAgICBpZighdGhpcy5kdXJpbmdWaWV3TW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYXllcklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJsb2FkTWFya3VwcyBmYWlsZWQ7IG1pc3NpbmcgMm5kIGFyZ3VtZW50ICdsYXllcklkJ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbiBpdCBiZSBwYXJzZWQgaW50byBTVkc/XG4gICAgICAgIHZhciBwYXJlbnQgPSBuYW1lc3BhY2VVdGlscy5zdHJpbmdUb1N2Z05vZGUobWFya3VwU3RyaW5nKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgbWV0YWRhdGEgbm9kZXNcbiAgICAgICAgbmFtZXNwYWNlVXRpbHMucmVtb3ZlQWxsTWV0YWRhdGEocGFyZW50KTtcblxuICAgICAgICAvLyBDcmVhdGUgc3ZnIG5vZGUgZm9yIGxheWVyIChpZiBub3QgcHJlc2VudClcbiAgICAgICAgdmFyIHN2Z0xheWVyTm9kZSA9IHRoaXMuc3ZnTGF5ZXJzTWFwW2xheWVySWRdO1xuICAgICAgICBpZiAoIXN2Z0xheWVyTm9kZSkge1xuICAgICAgICAgICAgc3ZnTGF5ZXJOb2RlID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3ZnRWxlbWVudCgnZycpO1xuICAgICAgICAgICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQoc3ZnTGF5ZXJOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuc3ZnTGF5ZXJzTWFwW2xheWVySWRdID0gc3ZnTGF5ZXJOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkTm9kZXM7XG4gICAgICAgIHdoaWxlKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgc3ZnTGF5ZXJOb2RlLmFwcGVuZENoaWxkKGNoaWxkcmVuWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBNYXJrdXBzIGZyb20gRE9NLCB3aGljaCBpcyBnb29kIHRvIGZyZWUgdXAgc29tZSBtZW1vcnkuPGJyPlxuICAgICAqXG4gICAgICogU2VlIGFsc286XG4gICAgICogW2xvYWRNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjbG9hZE1hcmt1cHN9LFxuICAgICAqIFt1bmxvYWRNYXJrdXBzQWxsTGF5ZXJzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjdW5sb2FkTWFya3Vwc0FsbExheWVyc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJJZCAtIElkIG9mIHRoZSBsYXllciBjb250YWluaW5nIGFsbCBtYXJrdXBzIHRvIHVubG9hZCAoZnJvbSBET00pLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIG9wZXJhdGlvbiBzdWNjZWVkZWQgb3Igbm90LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLnVubG9hZE1hcmt1cHMgPSBmdW5jdGlvbihsYXllcklkKSB7XG5cbiAgICAgICAgaWYgKCFsYXllcklkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJ1bmxvYWRNYXJrdXBzIGZhaWxlZDsgTm8gbGF5ZXJJZCBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ZnTGF5ZXJOb2RlID0gdGhpcy5zdmdMYXllcnNNYXBbbGF5ZXJJZF07XG4gICAgICAgIGlmICghc3ZnTGF5ZXJOb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGxvZyBhbnl0aGluZyBoZXJlP1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmcucmVtb3ZlQ2hpbGQoc3ZnTGF5ZXJOb2RlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3ZnTGF5ZXJzTWFwW2xheWVySWRdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVW5sb2FkIGFsbCBtYXJrdXBzIGxvYWRlZCBzbyBmYXIuIEdyZWF0IGZvciBmcmVlaW5nIHVwIG1lbW9yeS5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvOlxuICAgICAqIFtsb2FkTWFya3VwcygpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI2xvYWRNYXJrdXBzfSxcbiAgICAgKiBbdW5sb2FkTWFya3VwcygpXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlI3VubG9hZE1hcmt1cHN9LlxuICAgICAqL1xuICAgIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUucHJvdG90eXBlLnVubG9hZE1hcmt1cHNBbGxMYXllcnMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBmb3IgKHZhciBsYXllcklkIGluIHRoaXMuc3ZnTGF5ZXJzTWFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdmdMYXllcnNNYXAuaGFzT3duUHJvcGVydHkobGF5ZXJJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN2Zy5yZW1vdmVDaGlsZCh0aGlzLnN2Z0xheWVyc01hcFtsYXllcklkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdmdMYXllcnNNYXAgPSB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgYWxsIG1hcmt1cHMgZnJvbSBhIHNwZWNpZmllZCBsYXllci4gTm90ZSB0aGF0IG1hcmt1cHMgd2lsbCBiZSBoaWRkZW4gYW5kIG5vdCB1bmxvYWRlZCxcbiAgICAgKiB0aHVzIG1lbW9yeSB3aWxsIHN0aWxsIGJlIGNvbnN1bWVkIHRvIGtlZXAgdGhlbSBhcm91bmQuIEhvd2V2ZXIsIG5vIGFkZGl0aW9uYWwgcGFyc2luZyBpcyByZXF1aXJlZFxuICAgICAqIHRvIG1ha2UgdGhlbSB2aXNpYmxlIGFnYWluIHRocm91Z2ggbWV0aG9kXG4gICAgICogW3Nob3dNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjc2hvd01hcmt1cHN9LlxuICAgICAqXG4gICAgICogU2VlIGFsc286XG4gICAgICogW3Nob3dNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjc2hvd01hcmt1cHN9LFxuICAgICAqIFt1bmxvYWRNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjdW5sb2FkTWFya3Vwc30sXG4gICAgICogW2xvYWRNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjbG9hZE1hcmt1cHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBJZCBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyBhbGwgbWFya3VwcyB0byB1bmxvYWQgKGZyb20gRE9NKS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvcGVyYXRpb24gc3VjY2VlZGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5oaWRlTWFya3VwcyA9IGZ1bmN0aW9uKGxheWVySWQpIHtcblxuICAgICAgICBpZiAoIWxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImhpZGVNYXJrdXBzIGZhaWxlZDsgTm8gbGF5ZXJJZCBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ZnTGF5ZXJOb2RlID0gdGhpcy5zdmdMYXllcnNNYXBbbGF5ZXJJZF07XG4gICAgICAgIGlmICghc3ZnTGF5ZXJOb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGxvZyBhbnl0aGluZyBoZXJlP1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnTGF5ZXJOb2RlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBsYXllciBjb250YWluaW5nIG1hcmt1cHMgdmlzaWJsZSBhZ2Fpbi4gIE1hcmt1cHMgY2FuIGJlIHNldCBub24tdmlzaWJsZSBieSBjYWxsaW5nXG4gICAgICogW2hpZGVNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjaGlkZU1hcmt1cHN9LlxuICAgICAqXG4gICAgICogU2VlIGFsc286XG4gICAgICogW2hpZGVNYXJrdXBzKClde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmUjaGlkZU1hcmt1cHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxheWVySWQgLSBJZCBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyBhbGwgbWFya3VwcyB0byB1bmxvYWQgKGZyb20gRE9NKS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBvcGVyYXRpb24gc3VjY2VlZGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlLnByb3RvdHlwZS5zaG93TWFya3VwcyA9IGZ1bmN0aW9uKGxheWVySWQpIHtcblxuICAgICAgICBpZiAoIWxheWVySWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNob3dNYXJrdXBzIGZhaWxlZDsgTm8gbGF5ZXJJZCBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ZnTGF5ZXJOb2RlID0gdGhpcy5zdmdMYXllcnNNYXBbbGF5ZXJJZF07XG4gICAgICAgIGlmICghc3ZnTGF5ZXJOb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGxvZyBhbnl0aGluZyBoZXJlP1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnTGF5ZXJOb2RlLnNldEF0dHJpYnV0ZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xuICAgIH07XG5cbiAgICAvLy8vIENsaWVudCBTcGFjZSA8LT4gTWFya3VwIFNwYWNlIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgcHJvdG8ucG9zaXRpb25Gcm9tQ2xpZW50VG9NYXJrdXBzID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFRvTWFya3Vwcyh4LCB5KTtcbiAgICB9O1xuXG4gICAgcHJvdG8ucG9zaXRpb25Gcm9tTWFya3Vwc1RvQ2xpZW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1hcmt1cHNUb0NsaWVudCh4LCB5KTtcbiAgICB9O1xuXG4gICAgcHJvdG8uc2l6ZUZyb21DbGllbnRUb01hcmt1cHMgPSBmdW5jdGlvbih3LCBoKSB7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmNsaWVudFRvTWFya3VwcygwLCAwKTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNsaWVudFRvTWFya3Vwcyh3LCBoKTtcblxuICAgICAgICByZXR1cm4ge3g6IE1hdGguYWJzKGIueCAtIGEueCksIHk6IE1hdGguYWJzKGIueSAtIGEueSl9O1xuICAgIH07XG5cbiAgICBwcm90by5zaXplRnJvbU1hcmt1cHNUb0NsaWVudCA9IGZ1bmN0aW9uKHcsIGgpIHtcblxuICAgICAgICB2YXIgYSA9IHRoaXMubWFya3Vwc1RvQ2xpZW50KDAsIDApO1xuICAgICAgICB2YXIgYiA9IHRoaXMubWFya3Vwc1RvQ2xpZW50KHcsIGgpO1xuXG4gICAgICAgIHJldHVybiB7eDogTWF0aC5hYnMoYi54IC0gYS54KSwgeTogTWF0aC5hYnMoYi55IC0gYS55KX07XG4gICAgfTtcblxuICAgIHByb3RvLm1hcmt1cHNUb0NsaWVudCA9IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCAwKTtcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMudmlld2VyLmltcGwuY2FtZXJhO1xuXG4gICAgICAgIHBvaW50LmFwcGx5TWF0cml4NChjYW1lcmEubWF0cml4V29ybGQpO1xuICAgICAgICBwb2ludC5zdWIoY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgcG9pbnQgPSBuYW1lc3BhY2VVdGlscy53b3JsZFRvQ2xpZW50KHBvaW50LCB0aGlzLnZpZXdlciwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xuXG4gICAgcHJvdG8uY2xpZW50VG9NYXJrdXBzID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHZhciBwb2ludCA9IG5hbWVzcGFjZVV0aWxzLmNsaWVudFRvV29ybGQoeCwgeSwgMCwgdGhpcy52aWV3ZXIpO1xuICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy52aWV3ZXIuaW1wbC5jYW1lcmE7XG5cbiAgICAgICAgcG9pbnQuYWRkKGNhbWVyYS5wb3NpdGlvbikuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuICAgICAgICBwb2ludC56ID0gMDtcblxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcblxuICAgIHByb3RvLmdldFN2Z1ZpZXdCb3ggPSBmdW5jdGlvbihjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0KSB7XG5cbiAgICAgICAgLy8gR2V0IHBhbiBvZmZzZXQuXG4gICAgICAgIHZhciBsdCA9IHRoaXMuY2xpZW50VG9NYXJrdXBzKDAsIDApO1xuICAgICAgICB2YXIgcmIgPSB0aGlzLmNsaWVudFRvTWFya3VwcyhjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICB2YXIgbCA9IE1hdGgubWluKGx0LngsIHJiLngpO1xuICAgICAgICB2YXIgdCA9IE1hdGgubWluKGx0LnksIHJiLnkpO1xuICAgICAgICB2YXIgciA9IE1hdGgubWF4KGx0LngsIHJiLngpO1xuICAgICAgICB2YXIgYiA9IE1hdGgubWF4KGx0LnksIHJiLnkpO1xuXG4gICAgICAgIHJldHVybiBbbCAsIHQsIHItbCwgYi10XS5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIHByb3RvLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfTtcblxuICAgIHByb3RvLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgfTtcblxuICAgIC8vLy8gSGFuZGxlZCBFdmVudHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBwcm90by5vbkNhbWVyYUNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFubm90YXRpb25zJyBwYXJlbnQgdHJhbnNmb3JtLlxuICAgICAgICB2YXIgdmlld0JveCA9IHRoaXMuZ2V0U3ZnVmlld0JveCh0aGlzLmJvdW5kcy53aWR0aCwgdGhpcy5ib3VuZHMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBIQUNLLCBmb3Igc29tZSByZWFzb24gdGhlIDJuZCBmcmFtZSByZXR1cm5zIGFuIGVtcHR5IGNhbnZhcy5cbiAgICAgICAgLy8gVGhlIHJlYXNvbiB3aHkgdGhpcyBoYXBwZW5zIGlzIHRoYXQgdGhlIGNvZGUgYWJvdmUgY2FsbHMgaW50byB0aGUgdmlld2VyXG4gICAgICAgIC8vIGFuZCBhIGRpdmlzaW9uIGJ5IHplcm8gb2NjdXJzIGR1ZSB0byBMTVYgY2FudmFzIGhhdmluZyB6ZXJvIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgLy8gV2hlbiB3ZSBkZXRlY3QgdGhpcyBjYXNlLCBhdm9pZCBzZXR0aW5nIHRoZSB2aWV3Qm94IHZhbHVlIGFuZCByZWx5IG9uIG9uZVxuICAgICAgICAvLyBwcmV2aW91c2x5IHNldC5cbiAgICAgICAgaWYgKHZpZXdCb3ggPT09IFwiTmFOIE5hTiBOYU4gTmFOXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHZpZXdCb3gpO1xuXG4gICAgICAgIC8vIEVkaXQgZnJhbWUgaGFzIHRvIGJlIHVwZGF0ZWQsIHJlLXNldHRpbmcgdGhlIHNlbGVjdGVkIG1hcmt1cCBkb2VzIHRoZSBqb2IuXG4gICAgICAgIHZhciBlZGl0TW9kZSA9IHRoaXMuZWRpdE1vZGU7XG4gICAgICAgIGlmIChlZGl0TW9kZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gZWRpdE1vZGUuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRGcmFtZS5zZXRNYXJrdXAoc2VsZWN0ZWRNYXJrdXApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RvLm9uVmlld2VyUmVzaXplID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB0aGlzLmJvdW5kcy54ID0gMDtcbiAgICAgICAgdGhpcy5ib3VuZHMueSA9IDA7XG4gICAgICAgIHRoaXMuYm91bmRzLndpZHRoID0gZXZlbnQud2lkdGg7XG4gICAgICAgIHRoaXMuYm91bmRzLmhlaWdodCA9IGV2ZW50LmhlaWdodDtcblxuICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5ib3VuZHMud2lkdGgpO1xuICAgICAgICB0aGlzLnN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYm91bmRzLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5vbkNhbWVyYUNoYW5nZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIG1vdmUgZXZlbnRzLCB1c2VkIHRvIGNyZWF0ZSBtYXJrdXBzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8ub25Nb3VzZU1vdmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcm9wYWdhdGUgZXZlbnQgdG8gZWRpdCBmcmFtZS5cbiAgICAgICAgaWYgKHRoaXMuZWRpdEZyYW1lLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdEZyYW1lLm9uTW91c2VNb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVkaXRNb2RlICYmIHRoaXMuZWRpdE1vZGUub25Nb3VzZU1vdmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciB0byBtb3VzZSBkb3duIGV2ZW50cywgdXNlZCB0byBzdGFydCBjcmVhdGlvbiBtYXJrdXBzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8ub25Nb3VzZURvd24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLmRpc21pc3NMbXZIdWRNZXNzYWdlKCk7XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1vdXNlUG9zaXRpb24ueCA+PSBib3VuZHMueCAmJiBtb3VzZVBvc2l0aW9uLnggPD0gYm91bmRzLnggKyBib3VuZHMud2lkdGggJiZcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24ueSA+PSBib3VuZHMueSAmJiBtb3VzZVBvc2l0aW9uLnkgPD0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlLm9uTW91c2VEb3duKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBUaGVyZSBpcyBhIGJldHRlciB3YXkgdG8gZG8gdGhpcywgaW1wbGVtZW50IHdoZW4gdW5kby9yZWRvIGdyb3VwLlxuICAgICAgICBpZighdGhpcy5lZGl0TW9kZS5jcmVhdGluZyAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuc3ZnKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE1hcmt1cChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlnbm9yZU5leHRNb3VzZVVwID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHByb3RvLm9uTW91c2VVcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVkaXRGcmFtZS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRGcmFtZS5vbk1vdXNlVXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0aGlzLmlnbm9yZU5leHRNb3VzZVVwKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlLm9uTW91c2VVcCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgcHJvdG8ub25NYXJrdXBTZWxlY3RlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RNYXJrdXAoZXZlbnQubWFya3VwKTtcbiAgICAgICAgdGhpcy5maXJlRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGVzZSBldmVudHMgYXJlIHN0aWxsIHJlbGV2YW50LlxuICAgIHByb3RvLm9uTWFya3VwRHJhZ2dpbmcgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGlmIChldmVudC5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5lZGl0TW9kZS5zdGFydERyYWdnaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlLmZpbmlzaERyYWdnaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdG8ub25NYXJrdXBFbnRlckVkaXRpb24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgfTtcblxuICAgIHByb3RvLm9uTWFya3VwQ2FuY2VsRWRpdGlvbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdGhpcy5lZGl0TW9kZS51bnNlbGVjdCgpO1xuICAgIH07XG5cbiAgICBwcm90by5vbk1hcmt1cERlbGV0ZUVkaXRpb24gPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlTWFya3VwKGV2ZW50Lm1hcmt1cCk7XG4gICAgICAgIHRoaXMuZWRpdE1vZGUuZGVsZXRlTWFya3VwKCk7XG4gICAgfTtcblxuICAgIEF1dG9kZXNrLlZpZXdpbmcudGhlRXh0ZW5zaW9uTWFuYWdlci5yZWdpc3RlckV4dGVuc2lvbignQXV0b2Rlc2suVmlld2luZy5NYXJrdXBzQ29yZScsIE1hcmt1cHNDb3JlKTtcbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIG1hcmt1cFxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsb25lTWFya3VwKGVkaXRvciwgaWQsIG1hcmt1cCwgcG9zaXRpb24pIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbi5jYWxsKHRoaXMsIGVkaXRvciwgJ0NMT05FLU1BUktVUCcsIGlkKTtcblxuICAgICAgICB0aGlzLmNsb25lID0gbWFya3VwLmNsb25lKCk7XG4gICAgICAgIHRoaXMuY2xvbmUuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fTtcbiAgICB9XG5cbiAgICBDbG9uZU1hcmt1cC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgQ2xvbmVNYXJrdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xvbmVNYXJrdXA7XG5cbiAgICB2YXIgcHJvdG8gPSBDbG9uZU1hcmt1cC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChlZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFya3VwID0gY2xvbmUuY2xvbmUoKTtcbiAgICAgICAgbWFya3VwLnNldFBvc2l0aW9uKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuXG4gICAgICAgIGVkaXRvci5hZGRNYXJrdXAobWFya3VwKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIG1hcmt1cCAmJiB0aGlzLmVkaXRvci5yZW1vdmVNYXJrdXAobWFya3VwKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkNsb25lTWFya3VwID0gQ2xvbmVNYXJrdXA7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDcmVhdGVBcnJvdyhlZGl0b3IsIGlkLCBoZWFkLCB0YWlsLCBzdHlsZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnQ1JFQVRFLUFSUk9XJywgaWQpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0T25FeGVjdXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNsb25lU3R5bGUoc3R5bGUpO1xuICAgIH1cblxuICAgIENyZWF0ZUFycm93LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBDcmVhdGVBcnJvdy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDcmVhdGVBcnJvdztcblxuICAgIHZhciBwcm90byA9IENyZWF0ZUFycm93LnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBhcnJvdyA9IG5ldyBuYW1lc3BhY2UuTWFya3VwQXJyb3codGhpcy50YXJnZXRJZCwgZWRpdG9yKTtcblxuICAgICAgICBlZGl0b3IuYWRkTWFya3VwKGFycm93KTtcblxuICAgICAgICBhcnJvdy5zZXQodGhpcy5oZWFkLngsIHRoaXMuaGVhZC55LCB0aGlzLnRhaWwueCwgdGhpcy50YWlsLnkpO1xuICAgICAgICBhcnJvdy5zZXRTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBhcnJvdy5jcmVhdGVkKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgdGhpcy5lZGl0b3IucmVtb3ZlTWFya3VwKG1hcmt1cCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5DcmVhdGVBcnJvdyA9IENyZWF0ZUFycm93O1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogSW1wbGVtZW50cyBhbiBbRWRpdEFjdGlvbl17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9ufVxuICAgICAqIGZvciBjcmVhdGluZyBhIENpcmNsZSBbTWFya3VwXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cH0uXG4gICAgICogSW5jbHVkZWQgaW4gZG9jdW1lbnRhdGlvbiBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBjcmVhdGVcbiAgICAgKiBhIHNwZWNpZmljIEVkaXRBY3Rpb24gdGhhdCBkZWFscyB3aXRoIE1hcmt1cCBjcmVhdGlvbi5cbiAgICAgKiBEZXZlbG9wZXJzIGFyZSBlbmNvdXJhZ2UgdG8gbG9vayBpbnRvIHRoaXMgY2xhc3MncyBzb3VyY2UgY29kZSBhbmQgY29weVxuICAgICAqIGFzIG11Y2ggY29kZSBhcyB0aGV5IG5lZWQuIEZpbmQgbGluayB0byBzb3VyY2UgY29kZSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICogQGV4dGVuZHMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHNpemVcbiAgICAgKiBAcGFyYW0gcm90YXRpb25cbiAgICAgKiBAcGFyYW0gc3R5bGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDcmVhdGVDaXJjbGUoZWRpdG9yLCBpZCwgcG9zaXRpb24sIHNpemUsIHJvdGF0aW9uLCBzdHlsZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnQ1JFQVRFLUNJUkNMRScsIGlkKTtcblxuICAgICAgICB0aGlzLnNlbGVjdE9uRXhlY3V0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX07XG4gICAgICAgIHRoaXMuc2l6ZSA9IHt4OiBzaXplLngsIHk6IHNpemUueX07XG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNsb25lU3R5bGUoc3R5bGUpO1xuICAgIH1cblxuICAgIENyZWF0ZUNpcmNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENyZWF0ZUNpcmNsZTtcblxuICAgIHZhciBwcm90byA9IENyZWF0ZUNpcmNsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IG5hbWVzcGFjZS5NYXJrdXBDaXJjbGUodGhpcy50YXJnZXRJZCwgZWRpdG9yKTtcblxuICAgICAgICBlZGl0b3IuYWRkTWFya3VwKGNpcmNsZSk7XG5cbiAgICAgICAgY2lyY2xlLnNldCh0aGlzLnBvc2l0aW9uLCB0aGlzLnNpemUpO1xuICAgICAgICBjaXJjbGUuc2V0Um90YXRpb24odGhpcy5yb3RhdGlvbik7XG4gICAgICAgIGNpcmNsZS5zZXRTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBjaXJjbGUuY3JlYXRlZCgpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgbWFya3VwICYmIHRoaXMuZWRpdG9yLnJlbW92ZU1hcmt1cChtYXJrdXApO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuQ3JlYXRlQ2lyY2xlID0gQ3JlYXRlQ2lyY2xlO1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHNpemVcbiAgICAgKiBAcGFyYW0gcm90YXRpb25cbiAgICAgKiBAcGFyYW0gc3R5bGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDcmVhdGVDbG91ZChlZGl0b3IsIGlkLCBwb3NpdGlvbiwgc2l6ZSwgcm90YXRpb24sIHN0eWxlKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdDUkVBVEUtQ0xPVUQnLCBpZCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RPbkV4ZWN1dGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0ge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLnNpemUgPSB7eDogc2l6ZS54LCB5OiBzaXplLnl9O1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMuc3R5bGUgPSBuYW1lc3BhY2VVdGlscy5jbG9uZVN0eWxlKHN0eWxlKTtcbiAgICB9XG5cbiAgICBDcmVhdGVDbG91ZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgQ3JlYXRlQ2xvdWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3JlYXRlQ2xvdWQ7XG5cbiAgICB2YXIgcHJvdG8gPSBDcmVhdGVDbG91ZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgY2xvdWQgPSBuZXcgbmFtZXNwYWNlLk1hcmt1cENsb3VkKHRoaXMudGFyZ2V0SWQsIGVkaXRvcik7XG5cbiAgICAgICAgZWRpdG9yLmFkZE1hcmt1cChjbG91ZCk7XG5cbiAgICAgICAgY2xvdWQuc2V0KHRoaXMucG9zaXRpb24sIHRoaXMuc2l6ZSk7XG4gICAgICAgIGNsb3VkLnNldFJvdGF0aW9uKHRoaXMucm90YXRpb24pO1xuICAgICAgICBjbG91ZC5zZXRTdHlsZSh0aGlzLnN0eWxlKTtcblxuICAgICAgICBjbG91ZC5jcmVhdGVkKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgdGhpcy5lZGl0b3IucmVtb3ZlTWFya3VwKG1hcmt1cCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5DcmVhdGVDbG91ZCA9IENyZWF0ZUNsb3VkO1xuXG59KSgpO1xyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBzaXplXG4gICAgICogQHBhcmFtIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIGxvY2F0aW9uc1xuICAgICAqIEBwYXJhbSBzdHlsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENyZWF0ZUZyZWVoYW5kKGVkaXRvciwgaWQsIHBvc2l0aW9uLCBzaXplLCByb3RhdGlvbiwgbG9jYXRpb25zLCBzdHlsZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnQ1JFQVRFLUZSRUVIQU5EJywgaWQpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0T25FeGVjdXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMubW92ZW1lbnRzID0gbG9jYXRpb25zLmNvbmNhdCgpO1xuICAgICAgICB0aGlzLnN0eWxlID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZShzdHlsZSk7XG4gICAgfVxuXG4gICAgQ3JlYXRlRnJlZWhhbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIENyZWF0ZUZyZWVoYW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENyZWF0ZUZyZWVoYW5kO1xuXG4gICAgdmFyIHByb3RvID0gQ3JlYXRlRnJlZWhhbmQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdmFyIGZyZWVoYW5kID0gbmV3IG5hbWVzcGFjZS5NYXJrdXBGcmVlaGFuZCh0aGlzLnRhcmdldElkLCBlZGl0b3IpO1xuXG4gICAgICAgIGVkaXRvci5hZGRNYXJrdXAoZnJlZWhhbmQpO1xuXG4gICAgICAgIGZyZWVoYW5kLnNldCh0aGlzLnBvc2l0aW9uLCB0aGlzLnNpemUsIHRoaXMubW92ZW1lbnRzKTtcbiAgICAgICAgZnJlZWhhbmQuc2V0Um90YXRpb24odGhpcy5yb3RhdGlvbik7XG4gICAgICAgIGZyZWVoYW5kLnNldFN0eWxlKHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIGZyZWVoYW5kLmNyZWF0ZWQoKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIG1hcmt1cCAmJiB0aGlzLmVkaXRvci5yZW1vdmVNYXJrdXAobWFya3VwKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkNyZWF0ZUZyZWVoYW5kID0gQ3JlYXRlRnJlZWhhbmQ7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gc2l6ZVxuICAgICAqIEBwYXJhbSByb3RhdGlvblxuICAgICAqIEBwYXJhbSBzdHlsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENyZWF0ZVJlY3RhbmdsZShlZGl0b3IsIGlkLCBwb3NpdGlvbiwgc2l6ZSwgcm90YXRpb24sIHN0eWxlKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdDUkVBVEUtUkVDVEFOR0xFJywgaWQpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0T25FeGVjdXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fTtcbiAgICAgICAgdGhpcy5zaXplID0ge3g6IHNpemUueCwgeTogc2l6ZS55fTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICB0aGlzLnN0eWxlID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZShzdHlsZSk7XG4gICAgfVxuXG4gICAgQ3JlYXRlUmVjdGFuZ2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBDcmVhdGVSZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3JlYXRlUmVjdGFuZ2xlO1xuXG4gICAgdmFyIHByb3RvID0gQ3JlYXRlUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciByZWN0YW5nbGUgPSBuZXcgbmFtZXNwYWNlLk1hcmt1cFJlY3RhbmdsZSh0aGlzLnRhcmdldElkLCBlZGl0b3IpO1xuXG4gICAgICAgIGVkaXRvci5hZGRNYXJrdXAocmVjdGFuZ2xlKTtcblxuICAgICAgICByZWN0YW5nbGUuc2V0KHRoaXMucG9zaXRpb24sIHRoaXMuc2l6ZSk7XG4gICAgICAgIHJlY3RhbmdsZS5zZXRSb3RhdGlvbih0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgcmVjdGFuZ2xlLnNldFN0eWxlKHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIHJlY3RhbmdsZS5jcmVhdGVkKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgdGhpcy5lZGl0b3IucmVtb3ZlTWFya3VwKG1hcmt1cCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5DcmVhdGVSZWN0YW5nbGUgPSBDcmVhdGVSZWN0YW5nbGU7XG5cbn0pKCk7XHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHNpemVcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEBwYXJhbSBzdHlsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENyZWF0ZVRleHQoZWRpdG9yLCBpZCwgcG9zaXRpb24sIHNpemUsIHRleHQsIHN0eWxlICkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnQ1JFQVRFLVRFWFQnLCBpZCk7XG5cbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fTtcbiAgICAgICAgdGhpcy5zaXplID0ge3g6IHNpemUueCwgeTogc2l6ZS55fTtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG5hbWVzcGFjZVV0aWxzLmNsb25lU3R5bGUoc3R5bGUpO1xuICAgIH1cblxuICAgIENyZWF0ZVRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIENyZWF0ZVRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3JlYXRlVGV4dDtcblxuICAgIHZhciBwcm90byA9IENyZWF0ZVRleHQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuXG4gICAgICAgIHZhciB0ZXh0ID0gbmV3IG5hbWVzcGFjZS5NYXJrdXBUZXh0KHRoaXMudGFyZ2V0SWQsIGVkaXRvciwgc2l6ZSk7XG5cbiAgICAgICAgZWRpdG9yLmFkZE1hcmt1cCh0ZXh0KTtcblxuICAgICAgICB0ZXh0LnNldFNpemUocG9zaXRpb24sIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgdGV4dC5zZXRUZXh0KHRoaXMudGV4dCk7XG4gICAgICAgIHRleHQuc2V0U3R5bGUodGhpcy5zdHlsZSk7XG5cbiAgICAgICAgdGV4dC5mb3JjZVJlZHJhdygpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnJlbW92ZU1hcmt1cChtYXJrdXApO1xuICAgICAgICAgICAgbWFya3VwLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuQ3JlYXRlVGV4dCA9IENyZWF0ZVRleHQ7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGFycm93XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVsZXRlQXJyb3coZWRpdG9yLCBhcnJvdykge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnREVMRVRFLUFSUk9XJywgYXJyb3cuaWQpO1xuICAgICAgICB0aGlzLmNyZWF0ZUFycm93ID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVBcnJvdyhcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGFycm93LmlkLFxuICAgICAgICAgICAgYXJyb3cuaGVhZCxcbiAgICAgICAgICAgIGFycm93LnRhaWwsXG4gICAgICAgICAgICBhcnJvdy5nZXRTdHlsZSgpKTtcbiAgICB9XG5cbiAgICBEZWxldGVBcnJvdy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgRGVsZXRlQXJyb3cucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVsZXRlQXJyb3c7XG5cbiAgICB2YXIgcHJvdG8gPSBEZWxldGVBcnJvdy5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVBcnJvdy51bmRvKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNyZWF0ZUFycm93LnJlZG8oKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkRlbGV0ZUFycm93ID0gRGVsZXRlQXJyb3c7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICogQGNsYXNzXG4gICAgICogSW1wbGVtZW50cyBhbiBbRWRpdEFjdGlvbl17QGxpbmsgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9ufVxuICAgICAqIGZvciBkZWxldGluZyBhIENpcmNsZSBbTWFya3VwXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cH0uXG4gICAgICogSW5jbHVkZWQgaW4gZG9jdW1lbnRhdGlvbiBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBjcmVhdGVcbiAgICAgKiBhIHNwZWNpZmljIEVkaXRBY3Rpb24gdGhhdCBkZWFscyB3aXRoIE1hcmt1cCBkZWxldGlvbi5cbiAgICAgKiBEZXZlbG9wZXJzIGFyZSBlbmNvdXJhZ2UgdG8gbG9vayBpbnRvIHRoaXMgY2xhc3MncyBzb3VyY2UgY29kZSBhbmQgY29weVxuICAgICAqIGFzIG11Y2ggY29kZSBhcyB0aGV5IG5lZWQuIEZpbmQgbGluayB0byBzb3VyY2UgY29kZSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICogQGV4dGVuZHMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0QWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGNpcmNsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlbGV0ZUNpcmNsZShlZGl0b3IsIGNpcmNsZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnREVMRVRFLUNJUkNMRScsIGNpcmNsZS5pZCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2lyY2xlID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVDaXJjbGUoXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBjaXJjbGUuaWQsXG4gICAgICAgICAgICBjaXJjbGUucG9zaXRpb24sXG4gICAgICAgICAgICBjaXJjbGUuc2l6ZSxcbiAgICAgICAgICAgIGNpcmNsZS5yb3RhdGlvbixcbiAgICAgICAgICAgIGNpcmNsZS5nZXRTdHlsZSgpKTtcbiAgICB9XG5cbiAgICBEZWxldGVDaXJjbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIERlbGV0ZUNpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWxldGVDaXJjbGU7XG5cbiAgICB2YXIgcHJvdG8gPSBEZWxldGVDaXJjbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY3JlYXRlQ2lyY2xlLnVuZG8oKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY3JlYXRlQ2lyY2xlLnJlZG8oKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkRlbGV0ZUNpcmNsZSA9IERlbGV0ZUNpcmNsZTtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gY2xvdWRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWxldGVDbG91ZChlZGl0b3IsIGNsb3VkKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdERUxFVEUtQ0xPVUQnLCBjbG91ZC5pZCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2xvdWQgPSBuZXcgbmFtZXNwYWNlLkNyZWF0ZUNsb3VkKFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgY2xvdWQuaWQsXG4gICAgICAgICAgICBjbG91ZC5wb3NpdGlvbixcbiAgICAgICAgICAgIGNsb3VkLnNpemUsXG4gICAgICAgICAgICBjbG91ZC5yb3RhdGlvbixcbiAgICAgICAgICAgIGNsb3VkLmdldFN0eWxlKCkpO1xuICAgIH1cblxuICAgIERlbGV0ZUNsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBEZWxldGVDbG91ZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWxldGVDbG91ZDtcblxuICAgIHZhciBwcm90byA9IERlbGV0ZUNsb3VkLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNyZWF0ZUNsb3VkLnVuZG8oKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY3JlYXRlQ2xvdWQucmVkbygpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRGVsZXRlQ2xvdWQgPSBEZWxldGVDbG91ZDtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gZnJlZWhhbmRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWxldGVGcmVlaGFuZChlZGl0b3IsIGZyZWVoYW5kKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdERUxFVEUtRlJFRUhBTkQnLCBmcmVlaGFuZC5pZCk7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJlZWhhbmQgPSBuZXcgbmFtZXNwYWNlLkNyZWF0ZUZyZWVoYW5kKFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZnJlZWhhbmQuaWQsXG4gICAgICAgICAgICBmcmVlaGFuZC5wb3NpdGlvbixcbiAgICAgICAgICAgIGZyZWVoYW5kLnNpemUsXG4gICAgICAgICAgICBmcmVlaGFuZC5yb3RhdGlvbixcbiAgICAgICAgICAgIGZyZWVoYW5kLmxvY2F0aW9ucyxcbiAgICAgICAgICAgIGZyZWVoYW5kLmdldFN0eWxlKCkpO1xuICAgIH1cblxuICAgIERlbGV0ZUZyZWVoYW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBEZWxldGVGcmVlaGFuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWxldGVGcmVlaGFuZDtcblxuICAgIHZhciBwcm90byA9ICBEZWxldGVGcmVlaGFuZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVGcmVlaGFuZC51bmRvKCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNyZWF0ZUZyZWVoYW5kLnJlZG8oKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkRlbGV0ZUZyZWVoYW5kID0gRGVsZXRlRnJlZWhhbmQ7XG5cbn0pKCk7XHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBwYXJhbSByZWN0YW5nbGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgRGVsZXRlUmVjdGFuZ2xlID0gZnVuY3Rpb24oZWRpdG9yLCByZWN0YW5nbGUpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbi5jYWxsKHRoaXMsIGVkaXRvciwgJ0RFTEVURS1SRUNUQU5HTEUnLCByZWN0YW5nbGUuaWQpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlY3RhbmdsZSA9IG5ldyBuYW1lc3BhY2UuQ3JlYXRlUmVjdGFuZ2xlKFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLmlkLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLnBvc2l0aW9uLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLnNpemUsXG4gICAgICAgICAgICByZWN0YW5nbGUucm90YXRpb24sXG4gICAgICAgICAgICByZWN0YW5nbGUuZ2V0U3R5bGUoKSk7XG4gICAgfTtcblxuICAgIERlbGV0ZVJlY3RhbmdsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgRGVsZXRlUmVjdGFuZ2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlbGV0ZVJlY3RhbmdsZTtcblxuICAgIHZhciBwcm90byA9IERlbGV0ZVJlY3RhbmdsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVSZWN0YW5nbGUudW5kbygpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVSZWN0YW5nbGUucmVkbygpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRGVsZXRlUmVjdGFuZ2xlID0gRGVsZXRlUmVjdGFuZ2xlO1xuXG59KSgpO1xyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlbGV0ZVRleHQoZWRpdG9yLCB0ZXh0KSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdERUxFVEUtVEVYVCcsIHRleHQuaWQpO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHt4OiB0ZXh0LnBvc2l0aW9uLngsIHk6IHRleHQucG9zaXRpb24ueX07XG4gICAgICAgIHZhciBzaXplID0ge3g6IHRleHQuc2l6ZS54LCB5OiB0ZXh0LnNpemUueX07XG5cbiAgICAgICAgdGhpcy5jcmVhdGVUZXh0ID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVUZXh0KFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgdGV4dC5pZCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHRleHQuZ2V0VGV4dCgpLFxuICAgICAgICAgICAgdGV4dC5nZXRTdHlsZSgpKTtcbiAgICB9XG5cbiAgICBEZWxldGVUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBEZWxldGVUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlbGV0ZVRleHQ7XG5cbiAgICB2YXIgcHJvdG8gPSBEZWxldGVUZXh0LnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNyZWF0ZVRleHQudW5kbygpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVUZXh0LnJlZG8oKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkRlbGV0ZVRleHQgPSBEZWxldGVUZXh0O1xuXG59KSgpO1xyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHdpbGwgZ3JvdXAgYWN0aW9ucyBlZGl0IGFjdGlvbnMgdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSB3aG9sZS5cbiAgICAgKiBXaGVuIGEgZ3JvdXAgaXMgb3BlbiBhY3Rpb25zIGNhbiBiZSBhZGRlZCB0byBpdCwgc2ltaWxhciBhY3Rpb25zIHdpbGwgYmUgbWVyZ2VkIGludG8gb25lIGR1cmluZyB0aGlzIHByb2Nlc3MuXG4gICAgICogVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBieSB1c2VycywgaXQncyBhIGhlbHBlciBjbGFzcyBvZiBFZGl0QWN0aW9uTWFuYWdlci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFZGl0QWN0aW9uR3JvdXAoKSB7XG5cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBFZGl0QWN0aW9uR3JvdXAucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5vcGVuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0YXJnZXRJZFxuICAgICAqL1xuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGFjdGlvbnNNYXhJbmRleCA9IGFjdGlvbnMubGVuZ3RoIC0gMTtcblxuICAgICAgICB2YXIgdGFyZ2V0SWQgPSAtMTtcbiAgICAgICAgZm9yKHZhciBpID0gYWN0aW9uc01heEluZGV4OyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gIGFjdGlvbnNbaV07XG4gICAgICAgICAgICBhY3Rpb24udW5kbygpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aW9uLnRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldElkID0gYWN0aW9uLnRhcmdldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldElkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRhcmdldElkXG4gICAgICovXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICB2YXIgYWN0aW9uc0NvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHRhcmdldElkID0gLTE7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhY3Rpb25zQ291bnQ7ICsraSkge1xuXG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gIGFjdGlvbnNbaV07XG4gICAgICAgICAgICBhY3Rpb24ucmVkbygpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aW9uLnRhcmdldElkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRhcmdldElkID0gYWN0aW9uLnRhcmdldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldElkO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHByb3RvLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5jbG9zZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNDbG9zZWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRpdEFjdGlvbn0gYWN0aW9uXG4gICAgICovXG4gICAgcHJvdG8uYWRkQWN0aW9uID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICB0aGlzLmNvbXBhY3QoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBhY3Rpb25zQ291bnQgPSBhY3Rpb25zLmxlbmd0aDtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYWN0aW9uc0NvdW50OyArK2kpIHtcblxuICAgICAgICAgICAgLy8gSWYgYW4gYWN0aW9uIGRvZXMgbm90aGluZywgcmVtb3ZlIGl0LlxuICAgICAgICAgICAgdmFyIGFjdGlvbkEgPSBhY3Rpb25zW2ldO1xuICAgICAgICAgICAgaWYgKGFjdGlvbkEuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgLS1hY3Rpb25zQ291bnQ7XG4gICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhbiBhY3Rpb24gY2FuIGJlIG1lcmdlZCwgbWVyZ2UgaXQuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBhY3Rpb25zQ291bnQ7ICsraikge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbkIgPSBhY3Rpb25zW2pdO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb25BLnR5cGUgPT09IGFjdGlvbkIudHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BLm1lcmdlKGFjdGlvbkIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICAtLWFjdGlvbnNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkVkaXRBY3Rpb25Hcm91cCA9IEVkaXRBY3Rpb25Hcm91cDtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gYXJyb3dcbiAgICAgKiBAcGFyYW0gaGVhZFxuICAgICAqIEBwYXJhbSB0YWlsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0QXJyb3coZWRpdG9yLCBhcnJvdywgaGVhZCwgdGFpbCkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnU0VULUFSUk9XJywgYXJyb3cuaWQpO1xuXG4gICAgICAgIHRoaXMubmV3SGVhZCA9IHt4OiBoZWFkLngsIHk6IGhlYWQueX07XG4gICAgICAgIHRoaXMubmV3VGFpbCA9IHt4OiB0YWlsLngsIHk6IHRhaWwueX07XG4gICAgICAgIHRoaXMub2xkSGVhZCA9IHt4OiBhcnJvdy5oZWFkLngsIHk6IGFycm93LmhlYWQueX07XG4gICAgICAgIHRoaXMub2xkVGFpbCA9IHt4OiBhcnJvdy50YWlsLngsIHk6IGFycm93LnRhaWwueX07XG4gICAgfVxuXG4gICAgU2V0QXJyb3cucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIFNldEFycm93LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldEFycm93O1xuXG4gICAgdmFyIHByb3RvID0gU2V0QXJyb3cucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZSh0aGlzLnRhcmdldElkLCB0aGlzLm5ld0hlYWQsIHRoaXMubmV3VGFpbCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwcGx5U3RhdGUodGhpcy50YXJnZXRJZCwgdGhpcy5vbGRIZWFkLCB0aGlzLm9sZFRhaWwpO1xuICAgIH07XG5cbiAgICBwcm90by5tZXJnZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgICAgIGlmICh0aGlzLnRhcmdldElkID09PSBhY3Rpb24udGFyZ2V0SWQgJiZcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gYWN0aW9uLnR5cGUpIHtcblxuICAgICAgICAgICAgdGhpcy5uZXdIZWFkID0gYWN0aW9uLm5ld0hlYWQ7XG4gICAgICAgICAgICB0aGlzLm5ld1RhaWwgPSBhY3Rpb24ubmV3VGFpbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLmFwcGx5U3RhdGUgPSBmdW5jdGlvbih0YXJnZXRJZCwgaGVhZCwgdGFpbCkge1xuXG4gICAgICAgIHZhciBhcnJvdyA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0YXJnZXRJZCk7XG4gICAgICAgIGlmKCFhcnJvdykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlmZmVyZW50IHN0cm9rZSB3aWR0aHMgbWFrZSBwb3NpdGlvbnMgZGlmZmVyIGF0IHN1Yi1waXhlbCBsZXZlbC5cbiAgICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDE7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGFycm93LmhlYWQueCAtIGhlYWQueCkgPj0gZXBzaWxvbiB8fCBNYXRoLmFicyhhcnJvdy5oZWFkLnkgLSBoZWFkLnkpID49IGVwc2lsb24gfHxcbiAgICAgICAgICAgIE1hdGguYWJzKGFycm93LnRhaWwueCAtIHRhaWwueCkgPj0gZXBzaWxvbiB8fCBNYXRoLmFicyhhcnJvdy50YWlsLnkgLSB0YWlsLnkpID49IGVwc2lsb24pIHtcblxuICAgICAgICAgICAgYXJyb3cuc2V0KGhlYWQueCwgaGVhZC55LCB0YWlsLngsIHRhaWwueSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm5ld0hlYWQueCA9PT0gdGhpcy5vbGRIZWFkLnggJiZcbiAgICAgICAgICAgIHRoaXMubmV3SGVhZC55ID09PSB0aGlzLm9sZEhlYWQueSAmJlxuICAgICAgICAgICAgdGhpcy5uZXdUYWlsLnggPT09IHRoaXMub2xkVGFpbC54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1RhaWwueSA9PT0gdGhpcy5vbGRUYWlsLnkpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuU2V0QXJyb3cgPSBTZXRBcnJvdztcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBJbXBsZW1lbnRzIGFuIFtFZGl0QWN0aW9uXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRBY3Rpb259XG4gICAgICogZm9yIGVkaXRpbmcgcHJvcGVydGllcyBvZiBhIENpcmNsZSBbTWFya3VwXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cH0uXG4gICAgICogSW5jbHVkZWQgaW4gZG9jdW1lbnRhdGlvbiBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBjcmVhdGVcbiAgICAgKiBhIHNwZWNpZmljIEVkaXRBY3Rpb24gdGhhdCBkZWFscyB3aXRoIE1hcmt1cCBlZGl0aW9uLlxuICAgICAqIERldmVsb3BlcnMgYXJlIGVuY291cmFnZSB0byBsb29rIGludG8gdGhpcyBjbGFzcydzIHNvdXJjZSBjb2RlIGFuZCBjb3B5XG4gICAgICogYXMgbXVjaCBjb2RlIGFzIHRoZXkgbmVlZC4gRmluZCBsaW5rIHRvIHNvdXJjZSBjb2RlIGJlbG93LlxuICAgICAqXG4gICAgICogQHR1dG9yaWFsIGZlYXR1cmVfbWFya3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmVcbiAgICAgKiBAZXh0ZW5kcyBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRBY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gY2lyY2xlXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHNpemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDaXJjbGUoZWRpdG9yLCBjaXJjbGUsIHBvc2l0aW9uLCBzaXplKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdTRVQtQ0lSQ0xFJywgY2lyY2xlLmlkKTtcblxuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0ge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLm5ld1NpemUgPSB7eDogc2l6ZS54LCB5OiBzaXplLnl9O1xuICAgICAgICB0aGlzLm9sZFBvc2l0aW9uID0ge3g6IGNpcmNsZS5wb3NpdGlvbi54LCB5OiBjaXJjbGUucG9zaXRpb24ueX07XG4gICAgICAgIHRoaXMub2xkU2l6ZSA9IHt4OiBjaXJjbGUuc2l6ZS54LCB5OiBjaXJjbGUuc2l6ZS55fTtcbiAgICB9XG5cbiAgICBTZXRDaXJjbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIFNldENpcmNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDaXJjbGU7XG5cbiAgICB2YXIgcHJvdG8gPSBTZXRDaXJjbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZSh0aGlzLnRhcmdldElkLCB0aGlzLm5ld1Bvc2l0aW9uLCB0aGlzLm5ld1NpemUpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5hcHBseVN0YXRlKHRoaXMudGFyZ2V0SWQsIHRoaXMub2xkUG9zaXRpb24sIHRoaXMub2xkU2l6ZSk7XG4gICAgfTtcblxuICAgIHByb3RvLm1lcmdlID0gZnVuY3Rpb24oYWN0aW9uKSB7XG5cbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0SWQgPT09IGFjdGlvbi50YXJnZXRJZCAmJlxuICAgICAgICAgICAgdGhpcy50eXBlID09PSBhY3Rpb24udHlwZSkge1xuXG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0gYWN0aW9uLm5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5uZXdTaXplID0gYWN0aW9uLm5ld1NpemU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5hcHBseVN0YXRlID0gZnVuY3Rpb24odGFyZ2V0SWQsIHBvc2l0aW9uLCBzaXplKSB7XG5cbiAgICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0YXJnZXRJZCk7XG4gICAgICAgIGlmKCFjaXJjbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpZmZlcmVudCBzdHJva2Ugd2lkdGhzIG1ha2UgcG9zaXRpb25zIGRpZmZlciBhdCBzdWItcGl4ZWwgbGV2ZWwuXG4gICAgICAgIHZhciBlcHNpbG9uID0gMC4wMDAxO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhjaXJjbGUucG9zaXRpb24ueCAtIHBvc2l0aW9uLngpID4gZXBzaWxvbiB8fCBNYXRoLmFicyhjaXJjbGUuc2l6ZS55IC0gc2l6ZS55KSA+IGVwc2lsb24gfHxcbiAgICAgICAgICAgIE1hdGguYWJzKGNpcmNsZS5wb3NpdGlvbi55IC0gcG9zaXRpb24ueSkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKGNpcmNsZS5zaXplLnkgLSBzaXplLnkpID4gZXBzaWxvbikge1xuXG4gICAgICAgICAgICBjaXJjbGUuc2V0KHBvc2l0aW9uLCBzaXplKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5pc0lkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24ueCA9PT0gdGhpcy5vbGRQb3NpdGlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLnkgPT09IHRoaXMub2xkUG9zaXRpb24ueSAmJlxuICAgICAgICAgICAgdGhpcy5uZXdTaXplLnggPT09IHRoaXMub2xkU2l6ZS54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1NpemUueSA9PT0gdGhpcy5vbGRTaXplLnkpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuU2V0Q2lyY2xlID0gU2V0Q2lyY2xlO1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBwYXJhbSBjbG91ZFxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBzaXplXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2xvdWQoZWRpdG9yLCBjbG91ZCwgcG9zaXRpb24sIHNpemUpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbi5jYWxsKHRoaXMsIGVkaXRvciwgJ1NFVC1DTE9VRCcsIGNsb3VkLmlkKTtcblxuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0ge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLm5ld1NpemUgPSB7eDogc2l6ZS54LCB5OiBzaXplLnl9O1xuICAgICAgICB0aGlzLm9sZFBvc2l0aW9uID0ge3g6IGNsb3VkLnBvc2l0aW9uLngsIHk6IGNsb3VkLnBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLm9sZFNpemUgPSB7eDogY2xvdWQuc2l6ZS54LCB5OiBjbG91ZC5zaXplLnl9O1xuICAgIH1cblxuICAgIFNldENsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRDbG91ZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRDbG91ZDtcblxuICAgIHZhciBwcm90byA9IFNldENsb3VkLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwcGx5U3RhdGUodGhpcy50YXJnZXRJZCwgdGhpcy5uZXdQb3NpdGlvbiwgdGhpcy5uZXdTaXplLCB0aGlzLm5ld1N0cm9rZVdpZHRoLCB0aGlzLm5ld0NvbG9yKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZSh0aGlzLnRhcmdldElkLCB0aGlzLm9sZFBvc2l0aW9uLCB0aGlzLm9sZFNpemUsIHRoaXMub2xkU3Ryb2tlV2lkdGgsIHRoaXMub2xkQ29sb3IpO1xuICAgIH07XG5cbiAgICBwcm90by5tZXJnZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgICAgIGlmICh0aGlzLnRhcmdldElkID09PSBhY3Rpb24udGFyZ2V0SWQgJiZcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gYWN0aW9uLnR5cGUpIHtcblxuICAgICAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IGFjdGlvbi5uZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMubmV3U2l6ZSA9IGFjdGlvbi5uZXdTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uYXBwbHlTdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldElkLCBwb3NpdGlvbiwgc2l6ZSkge1xuXG4gICAgICAgIHZhciBjbG91ZCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0YXJnZXRJZCk7XG4gICAgICAgIGlmKCFjbG91ZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlmZmVyZW50IHN0cm9rZSB3aWR0aHMgbWFrZSBwb3NpdGlvbnMgZGlmZmVyIGF0IHN1Yi1waXhlbCBsZXZlbC5cbiAgICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDE7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGNsb3VkLnBvc2l0aW9uLnggLSBwb3NpdGlvbi54KSA+IGVwc2lsb24gfHwgTWF0aC5hYnMoY2xvdWQuc2l6ZS55IC0gc2l6ZS55KSA+IGVwc2lsb24gfHxcbiAgICAgICAgICAgIE1hdGguYWJzKGNsb3VkLnBvc2l0aW9uLnkgLSBwb3NpdGlvbi55KSA+IGVwc2lsb24gfHwgTWF0aC5hYnMoY2xvdWQuc2l6ZS55IC0gc2l6ZS55KSA+IGVwc2lsb24pIHtcblxuICAgICAgICAgICAgY2xvdWQuc2V0KHBvc2l0aW9uLCBzaXplKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5pc0lkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24ueCA9PT0gdGhpcy5vbGRQb3NpdGlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLnkgPT09IHRoaXMub2xkUG9zaXRpb24ueSAmJlxuICAgICAgICAgICAgdGhpcy5uZXdTaXplLnggPT09IHRoaXMub2xkU2l6ZS54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1NpemUueSA9PT0gdGhpcy5vbGRTaXplLnkpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuU2V0Q2xvdWQgPSBTZXRDbG91ZDtcblxufSkoKTtcclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIGZyZWVoYW5kXG4gICAgICogQHBhcmFtIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHNpemVcbiAgICAgKiBAcGFyYW0gbG9jYXRpb25zXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0RnJlZWhhbmQoZWRpdG9yLCBmcmVlaGFuZCwgcG9zaXRpb24sIHNpemUsIGxvY2F0aW9ucykge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnU0VULUZSRUVIQU5EJywgZnJlZWhhbmQuaWQpO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSBsb2NhdGlvbnMuY29uY2F0KCk7XG5cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzYXZlIG9sZCBkYXRhXG4gICAgfVxuXG4gICAgU2V0RnJlZWhhbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdEFjdGlvbi5wcm90b3R5cGUpO1xuICAgIFNldEZyZWVoYW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldEZyZWVoYW5kO1xuXG4gICAgdmFyIHByb3RvID0gU2V0RnJlZWhhbmQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8ucmVkbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBmcmVlaGFuZCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgaWYoIWZyZWVoYW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmcmVlaGFuZC5zZXQodGhpcy5wb3NpdGlvbiwgdGhpcy5zaXplLCB0aGlzLmxvY2F0aW9ucyk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gTm8gbmVlZCBmb3IgdW5kby5cbiAgICB9O1xuXG4gICAgcHJvdG8ubWVyZ2UgPSBmdW5jdGlvbihhY3Rpb24pIHtcblxuICAgICAgICBpZiAodGhpcy50YXJnZXRJZCA9PT0gYWN0aW9uLnRhcmdldElkICYmXG4gICAgICAgICAgICB0aGlzLnR5cGUgPT09IGFjdGlvbi50eXBlKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYXRpb25zID0gYWN0aW9uLmxvY2F0aW9ucy5jb25jYXQoKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBhY3Rpb24ucG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLnNpemUgPSBhY3Rpb24uc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbmVlZCB0byBvcHRpbWl6ZSwgYWx3YXlzIGZhbHNlLlxuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuU2V0RnJlZWhhbmQgPSBTZXRGcmVlaGFuZDtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICBmdW5jdGlvbiBTZXRQb3NpdGlvbihlZGl0b3IsIG1hcmt1cCwgcG9zaXRpb24pIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbi5jYWxsKHRoaXMsIGVkaXRvciwgJ1NFVC1QT1NJVElPTicsIG1hcmt1cC5pZCk7XG5cbiAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fTtcbiAgICAgICAgdGhpcy5vbGRQb3NpdGlvbiA9IHt4OiBtYXJrdXAucG9zaXRpb24ueCwgeTogbWFya3VwLnBvc2l0aW9uLnl9O1xuICAgIH1cblxuICAgIFNldFBvc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRQb3NpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRQb3NpdGlvbjtcblxuICAgIHZhciBwcm90byA9IFNldFBvc2l0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgbWFya3VwLnNldFBvc2l0aW9uKHRoaXMubmV3UG9zaXRpb24ueCwgdGhpcy5uZXdQb3NpdGlvbi55KTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIG1hcmt1cCAmJiBtYXJrdXAuc2V0UG9zaXRpb24odGhpcy5vbGRQb3NpdGlvbi54LCB0aGlzLm9sZFBvc2l0aW9uLnkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5tZXJnZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgICAgIGlmICh0aGlzLnRhcmdldElkID09PSBhY3Rpb24udGFyZ2V0SWQgJiZcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gYWN0aW9uLnR5cGUpIHtcblxuICAgICAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IGFjdGlvbi5uZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMubmV3UG9zaXRpb247XG4gICAgICAgIHZhciBvbGRQb3NpdGlvbiA9IHRoaXMub2xkUG9zaXRpb247XG5cbiAgICAgICAgcmV0dXJuIG5ld1Bvc2l0aW9uLnggPT09IG9sZFBvc2l0aW9uLnggJiYgbmV3UG9zaXRpb24ueSA9PT0gb2xkUG9zaXRpb24ueTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLlNldFBvc2l0aW9uID0gU2V0UG9zaXRpb247XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBzaXplXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0UmVjdGFuZ2xlKGVkaXRvciwgcmVjdGFuZ2xlLCBwb3NpdGlvbiwgc2l6ZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnU0VULVJFQ1RBTkdMRScsIHJlY3RhbmdsZS5pZCk7XG5cbiAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fTtcbiAgICAgICAgdGhpcy5uZXdTaXplID0ge3g6IHNpemUueCwgeTogc2l6ZS55fTtcbiAgICAgICAgdGhpcy5vbGRQb3NpdGlvbiA9IHt4OiByZWN0YW5nbGUucG9zaXRpb24ueCwgeTogcmVjdGFuZ2xlLnBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLm9sZFNpemUgPSB7eDogcmVjdGFuZ2xlLnNpemUueCwgeTogcmVjdGFuZ2xlLnNpemUueX07XG4gICAgfVxuXG4gICAgU2V0UmVjdGFuZ2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRSZWN0YW5nbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0UmVjdGFuZ2xlO1xuXG4gICAgdmFyIHByb3RvID0gU2V0UmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmFwcGx5U3RhdGUodGhpcy50YXJnZXRJZCwgdGhpcy5uZXdQb3NpdGlvbiwgdGhpcy5uZXdTaXplKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdGF0ZSh0aGlzLnRhcmdldElkLCB0aGlzLm9sZFBvc2l0aW9uLCB0aGlzLm9sZFNpemUpO1xuICAgIH07XG5cbiAgICBwcm90by5tZXJnZSA9IGZ1bmN0aW9uKGFjdGlvbikge1xuXG4gICAgICAgIGlmICh0aGlzLnRhcmdldElkID09PSBhY3Rpb24udGFyZ2V0SWQgJiZcbiAgICAgICAgICAgIHRoaXMudHlwZSA9PT0gYWN0aW9uLnR5cGUpIHtcblxuICAgICAgICAgICAgdGhpcy5uZXdQb3NpdGlvbiA9IGFjdGlvbi5uZXdQb3NpdGlvbjtcbiAgICAgICAgICAgIHRoaXMubmV3U2l6ZSA9IGFjdGlvbi5uZXdTaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uYXBwbHlTdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldElkLCBwb3NpdGlvbiwgc2l6ZSkge1xuXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGFyZ2V0SWQpO1xuICAgICAgICBpZighcmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEaWZmZXJlbnQgc3Ryb2tlIHdpZHRocyBtYWtlIHBvc2l0aW9ucyBkaWZmZXIgYXQgc3ViLXBpeGVsIGxldmVsLlxuICAgICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMTtcblxuICAgICAgICBpZiAoTWF0aC5hYnMocmVjdGFuZ2xlLnBvc2l0aW9uLnggLSBwb3NpdGlvbi54KSA+IGVwc2lsb24gfHwgTWF0aC5hYnMocmVjdGFuZ2xlLnNpemUueSAtIHNpemUueSkgPiBlcHNpbG9uIHx8XG4gICAgICAgICAgICBNYXRoLmFicyhyZWN0YW5nbGUucG9zaXRpb24ueSAtIHBvc2l0aW9uLnkpID4gZXBzaWxvbiB8fCBNYXRoLmFicyhyZWN0YW5nbGUuc2l6ZS55IC0gc2l6ZS55KSA+IGVwc2lsb24pIHtcblxuICAgICAgICAgICAgcmVjdGFuZ2xlLnNldChwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8uaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybihcbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24ueCA9PT0gdGhpcy5vbGRQb3NpdGlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLnkgPT09IHRoaXMub2xkUG9zaXRpb24ueSAmJlxuICAgICAgICAgICAgdGhpcy5uZXdTaXplLnggPT09IHRoaXMub2xkU2l6ZS54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1NpemUueSA9PT0gdGhpcy5vbGRTaXplLnkpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuU2V0UmVjdGFuZ2xlID0gU2V0UmVjdGFuZ2xlO1xuXG59KSgpO1xyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAcGFyYW0gbWFya3VwXG4gICAgICogQHBhcmFtIGFuZ2xlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Um90YXRpb24oZWRpdG9yLCBtYXJrdXAsIGFuZ2xlKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRBY3Rpb24uY2FsbCh0aGlzLCBlZGl0b3IsICdTRVQtUk9UQVRJT04nLCBtYXJrdXAuaWQpO1xuXG4gICAgICAgIHZhciBjdXJBbmdsZSA9IG1hcmt1cC5nZXRSb3RhdGlvbigpO1xuXG4gICAgICAgIHRoaXMubmV3Um90YXRpb24gPSB7YW5nbGU6IGFuZ2xlfTtcbiAgICAgICAgdGhpcy5vbGRSb3RhdGlvbiA9IHthbmdsZTogY3VyQW5nbGV9O1xuICAgIH1cblxuICAgIFNldFJvdGF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRSb3RhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRSb3RhdGlvbjtcblxuICAgIHZhciBwcm90byA9IFNldFJvdGF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgbWFya3VwLnNldFJvdGF0aW9uKHRoaXMubmV3Um90YXRpb24uYW5nbGUpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgbWFya3VwICYmIG1hcmt1cC5zZXRSb3RhdGlvbih0aGlzLm9sZFJvdGF0aW9uLmFuZ2xlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcHJvdG8ubWVyZ2UgPSBmdW5jdGlvbihhY3Rpb24pIHtcblxuICAgICAgICBpZiAodGhpcy50YXJnZXRJZCA9PT0gYWN0aW9uLnRhcmdldElkICYmXG4gICAgICAgICAgICB0aGlzLnR5cGUgPT09IGFjdGlvbi50eXBlKSB7XG5cbiAgICAgICAgICAgIHRoaXMubmV3Um90YXRpb24gPSBhY3Rpb24ubmV3Um90YXRpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIHByb3RvLmlzSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5uZXdSb3RhdGlvbi5hbmdsZSA9PT0gdGhpcy5vbGRSb3RhdGlvbi5hbmdsZTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLlNldFJvdGF0aW9uID0gU2V0Um90YXRpb247XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIG1hcmt1cFxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRTaXplKGVkaXRvciwgbWFya3VwLCBwb3NpdGlvbiwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnU0VULVNJWkUnLCBtYXJrdXAuaWQpO1xuXG4gICAgICAgIHRoaXMubmV3UG9zaXRpb24gPSB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX07XG4gICAgICAgIHRoaXMub2xkUG9zaXRpb24gPSB7eDogbWFya3VwLnBvc2l0aW9uLngsIHk6IG1hcmt1cC5wb3NpdGlvbi55fTtcbiAgICAgICAgdGhpcy5uZXdXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLm9sZFdpZHRoID0gbWFya3VwLnNpemUueDtcbiAgICAgICAgdGhpcy5uZXdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMub2xkSGVpZ2h0ID0gbWFya3VwLnNpemUueTtcbiAgICB9XG5cbiAgICBTZXRTaXplLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRTaXplLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFNpemU7XG5cbiAgICB2YXIgcHJvdG8gPSBTZXRTaXplLnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0TWFya3VwKHRoaXMudGFyZ2V0SWQpO1xuICAgICAgICBtYXJrdXAgJiYgbWFya3VwLnNldFNpemUodGhpcy5uZXdQb3NpdGlvbiwgdGhpcy5uZXdXaWR0aCwgdGhpcy5uZXdIZWlnaHQpO1xuICAgIH07XG5cbiAgICBwcm90by51bmRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgbWFya3VwICYmIG1hcmt1cC5zZXRTaXplKHRoaXMub2xkUG9zaXRpb24sIHRoaXMub2xkV2lkdGgsIHRoaXMub2xkSGVpZ2h0KTtcbiAgICB9O1xuXG4gICAgcHJvdG8ubWVyZ2UgPSBmdW5jdGlvbihhY3Rpb24pIHtcblxuICAgICAgICBpZiAodGhpcy50YXJnZXRJZCA9PT0gYWN0aW9uLnRhcmdldElkICYmXG4gICAgICAgICAgICB0aGlzLnR5cGUgPT09IGFjdGlvbi50eXBlKSB7XG5cbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24gPSBhY3Rpb24ubmV3UG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLm5ld1dpZHRoID0gYWN0aW9uLm5ld1dpZHRoO1xuICAgICAgICAgICAgdGhpcy5uZXdIZWlnaHQgPSBhY3Rpb24ubmV3SGVpZ2h0O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5pc0lkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGlkZW50aXR5ID1cbiAgICAgICAgICAgIHRoaXMubmV3UG9zaXRpb24ueCA9PT0gdGhpcy5vbGRQb3NpdGlvbi54ICYmXG4gICAgICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uLnkgPT09IHRoaXMub2xkUG9zaXRpb24ueSAmJlxuICAgICAgICAgICAgdGhpcy5uZXdXaWR0aCA9PT0gdGhpcy5vbGRXaWR0aCAmJlxuICAgICAgICAgICAgdGhpcy5uZXdIZWlnaHQgPT09IHRoaXMub2xkSGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLlNldFNpemUgPSBTZXRTaXplO1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQHBhcmFtIG1hcmt1cFxuICAgICAqIEBwYXJhbSBzdHlsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNldFN0eWxlKGVkaXRvciwgbWFya3VwLCBzdHlsZSkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0QWN0aW9uLmNhbGwodGhpcywgZWRpdG9yLCAnU0VULVNUWUxFJywgbWFya3VwLmlkKTtcblxuICAgICAgICB0aGlzLm5ld1N0eWxlID0gbmFtZXNwYWNlVXRpbHMuY2xvbmVTdHlsZShzdHlsZSk7XG4gICAgICAgIHRoaXMub2xkU3R5bGUgPSBtYXJrdXAuZ2V0U3R5bGUoKTtcbiAgICB9XG5cbiAgICBTZXRTdHlsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0QWN0aW9uLnByb3RvdHlwZSk7XG4gICAgU2V0U3R5bGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0U3R5bGU7XG5cbiAgICB2YXIgcHJvdG8gPSBTZXRTdHlsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5yZWRvID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgbWFya3VwICYmIG1hcmt1cC5zZXRTdHlsZSh0aGlzLm5ld1N0eWxlKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5kbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtYXJrdXAgPSB0aGlzLmVkaXRvci5nZXRNYXJrdXAodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIG1hcmt1cCAmJiBtYXJrdXAuc2V0U3R5bGUodGhpcy5vbGRTdHlsZSk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5TZXRTdHlsZSA9IFNldFN0eWxlO1xuXG59KSgpO1xuXHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBwYXJhbSBtYXJrdXBcbiAgICAgKiBAcGFyYW0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gc2l6ZVxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0VGV4dChlZGl0b3IsIG1hcmt1cCwgcG9zaXRpb24sIHNpemUsIHRleHQpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdEFjdGlvbi5jYWxsKHRoaXMsIGVkaXRvciwgJ1NFVC1URVhUJywgbWFya3VwLmlkKTtcblxuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0ge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9O1xuICAgICAgICB0aGlzLm9sZFBvc2l0aW9uID0ge3g6IG1hcmt1cC5wb3NpdGlvbi54LCB5OiBtYXJrdXAucG9zaXRpb24ueX07XG4gICAgICAgIHRoaXMubmV3U2l6ZSA9IHt4OiBzaXplLngsIHk6IHNpemUueX07XG4gICAgICAgIHRoaXMub2xkU2l6ZSA9IHt4OiBtYXJrdXAuc2l6ZS54LCB5OiBtYXJrdXAuc2l6ZS55fTtcbiAgICAgICAgdGhpcy5uZXdUZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5vbGRUZXh0ID0gbWFya3VwLmdldFRleHQoKTtcbiAgICB9XG5cbiAgICBTZXRUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRBY3Rpb24ucHJvdG90eXBlKTtcbiAgICBTZXRUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFRleHQ7XG5cbiAgICB2YXIgcHJvdG8gPSBTZXRUZXh0LnByb3RvdHlwZTtcblxuICAgIHByb3RvLnJlZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgdGV4dCAmJiB0ZXh0LnNldCh0aGlzLm5ld1Bvc2l0aW9uLCB0aGlzLm5ld1NpemUsIHRoaXMubmV3VGV4dCk7XG4gICAgfTtcblxuICAgIHByb3RvLnVuZG8gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdGV4dCA9IHRoaXMuZWRpdG9yLmdldE1hcmt1cCh0aGlzLnRhcmdldElkKTtcbiAgICAgICAgdGV4dCAmJiB0ZXh0LnNldCh0aGlzLm9sZFBvc2l0aW9uLCB0aGlzLm9sZFNpemUsIHRoaXMub2xkVGV4dCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5TZXRUZXh0ID0gU2V0VGV4dDtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGlwYm9hcmQoZWRpdG9yKSB7XG5cbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucGFzdGVQb3NpdGlvbiA9IHt4OjAsIHk6IDB9O1xuXG4gICAgICAgIG5hbWVzcGFjZVV0aWxzLmFkZFRyYWl0RXZlbnREaXNwYXRjaGVyKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IENsaXBib2FyZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmKCFzZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb250ZW50ID0gc2VsZWN0ZWRNYXJrdXAuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5wYXN0ZVBvc2l0aW9uLnggPSBzZWxlY3RlZE1hcmt1cC5wb3NpdGlvbi54O1xuICAgICAgICB0aGlzLnBhc3RlUG9zaXRpb24ueSA9IHNlbGVjdGVkTWFya3VwLnBvc2l0aW9uLnk7XG4gICAgfTtcblxuICAgIHByb3RvLmN1dCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxlY3RlZE1hcmt1cCA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZighc2VsZWN0ZWRNYXJrdXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29weSgpO1xuICAgICAgICB0aGlzLmVkaXRvci5kZWxldGVNYXJrdXAoc2VsZWN0ZWRNYXJrdXApO1xuICAgIH07XG5cbiAgICBwcm90by5wYXN0ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50O1xuICAgICAgICBpZighY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBhc3RlUG9zaXRpb247XG4gICAgICAgIHZhciBkZWx0YSA9IGVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3VwcygyMCwgMjApO1xuXG4gICAgICAgIHBvc2l0aW9uLnggKz0gZGVsdGEueDtcbiAgICAgICAgcG9zaXRpb24ueSAtPSBkZWx0YS55O1xuXG4gICAgICAgIHZhciBjbG9uZU1hcmt1cCA9IG5ldyBuYW1lc3BhY2UuQ2xvbmVNYXJrdXAoZWRpdG9yLCBlZGl0b3IuZ2V0SWQoKSwgY29udGVudCwgcG9zaXRpb24pO1xuICAgICAgICBjbG9uZU1hcmt1cC5leGVjdXRlKCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5DbGlwYm9hcmQgPSBDbGlwYm9hcmQ7XG59KSgpO1xuXHJcbihmdW5jdGlvbigpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG4gICAgdmFyIG5hbWVzcGFjZVV0aWxzID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5VdGlscztcblxuICAgIGZ1bmN0aW9uIElucHV0SGFuZGxlcigpIHtcblxuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMubW91c2VQb3NpdGlvbiA9IHt4OjAsIHk6MH07XG4gICAgICAgIHRoaXMubWFrZVNhbWVYWSA9IGZhbHNlOyAvLyBUT0RPOiBGSU5EIGEgYmV0dGVyIHdheSB0byBuYW1lIGFuZCBjb21tdW5pY2F0ZSB0aGVzZS5cbiAgICAgICAgdGhpcy5zbmFwUm90YXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMua2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uc3RyYWluQXhpcyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMub25IYW1tZXJEcmFnQmluZGVkID0gdGhpcy5vbkhhbW1lckRyYWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNpbmdsZVRhcEJpbmRlZCA9IHRoaXMub25TaW5nbGVUYXAuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlTW92ZUJpbmRlZCA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXBCaW5kZWQgPSB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duQmluZGVkID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IElucHV0SGFuZGxlci5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hdHRhY2hUbyA9IGZ1bmN0aW9uKGVkaXRvcikge1xuXG4gICAgICAgIHRoaXMuZWRpdG9yICYmIHRoaXMuZGV0YWNoRnJvbSh0aGlzLmVkaXRvcik7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgIGlmIChuYW1lc3BhY2VVdGlscy5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFtbWVyID0gbmV3IEhhbW1lci5NYW5hZ2VyKGVkaXRvci5zdmcsIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyczogW1xuICAgICAgICAgICAgICAgICAgICBbSGFtbWVyLlBhbiwge2V2ZW50OiAnZHJhZycsIHBvaW50ZXJzOiAxfV0sXG4gICAgICAgICAgICAgICAgICAgIFtIYW1tZXIuVGFwLCB7ZXZlbnQ6ICdzaW5nbGV0YXAnLCBwb2ludGVyczogMSwgdGhyZXNob2xkOiAyfV1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGlucHV0Q2xhc3M6IEhhbW1lci5Ub3VjaElucHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5kZXRhY2hGcm9tID0gZnVuY3Rpb24oZWRpdG9yKSB7XG5cbiAgICAgICAgdGhpcy5oYW1tZXIgJiYgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVCaW5kZWQsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXBCaW5kZWQsIHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5zdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duQmluZGVkKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgfTtcblxuICAgIHByb3RvLmVudGVyRWRpdE1vZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5oYW1tZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFtbWVyLm9uKFwiZHJhZ3N0YXJ0IGRyYWdtb3ZlIGRyYWdlbmRcIiwgdGhpcy5vbkhhbW1lckRyYWdCaW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5oYW1tZXIub24oXCJzaW5nbGV0YXBcIiwgdGhpcy5vblNpbmdsZVRhcEJpbmRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdXNlTW92ZUJpbmRlZCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcEJpbmRlZCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnN2Zy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMub25Nb3VzZURvd25CaW5kZWQpO1xuICAgIH07XG5cbiAgICBwcm90by5sZWF2ZUVkaXRNb2RlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFtbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmhhbW1lci5vZmYoXCJkcmFnc3RhcnQgZHJhZ21vdmUgZHJhZ2VuZFwiLCB0aGlzLm9uSGFtbWVyRHJhZ0JpbmRlZCk7XG4gICAgICAgICAgICB0aGlzLmhhbW1lci5vZmYoXCJzaW5nbGV0YXBcIiwgdGhpcy5vblNpbmdsZVRhcEJpbmRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm9uTW91c2VNb3ZlQmluZGVkLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXBCaW5kZWQsIHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5zdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2VEb3duQmluZGVkKTtcbiAgICB9O1xuXG4gICAgcHJvdG8uZW50ZXJWaWV3TW9kZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgfTtcblxuICAgIHByb3RvLmxlYXZlVmlld01vZGUgPSBmdW5jdGlvbigpIHtcblxuICAgIH07XG5cbiAgICBwcm90by5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHt4OiB0aGlzLm1vdXNlUG9zaXRpb24ueCwgeTogdGhpcy5tb3VzZVBvc2l0aW9uLnl9O1xuICAgIH07XG5cbiAgICBwcm90by5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgcHJvY2Vzc01vdXNlRXZlbnQodGhpcywgZXZlbnQpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbk1vdXNlTW92ZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgcHJvY2Vzc01vdXNlRXZlbnQodGhpcywgZXZlbnQpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbk1vdXNlRG93bihldmVudCk7IC8vIFRPRE86IFRoZXJlIHNob3VsZCBiZSBubyBuZWVkIHRvIHNlbmQgZXZlbnQgaGVyZS5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgcHJvdG8ub25Nb3VzZVVwID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBwcm9jZXNzTW91c2VFdmVudCh0aGlzLCBldmVudCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uTW91c2VVcCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBwcm90by5vbkhhbW1lckRyYWcgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGNvbnZlcnRFdmVudEhhbW1lclRvTW91c2UoZXZlbnQpO1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlRG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkcmFnbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkcmFnZW5kJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW91c2VVcChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdG8ub25TaW5nbGVUYXAgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGNvbnZlcnRFdmVudEhhbW1lclRvTW91c2UoZXZlbnQpO1xuXG4gICAgICAgIHRoaXMub25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgICB0aGlzLm9uTW91c2VVcChldmVudCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NNb3VzZUV2ZW50KGlucHV0LCBldmVudCkge1xuXG4gICAgICAgIHZhciByZWN0ID0gaW5wdXQuZWRpdG9yLnN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBpbnB1dC5tYWtlU2FtZVhZID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGlucHV0LnNuYXBSb3RhdGlvbnMgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgaW5wdXQua2VlcEFzcGVjdFJhdGlvID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGlucHV0LmNvbnN0cmFpbkF4aXMgPSBldmVudC5zaGlmdEtleTtcblxuICAgICAgICBpbnB1dC5tb3VzZVBvc2l0aW9uLnggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICBpbnB1dC5tb3VzZVBvc2l0aW9uLnkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEV2ZW50SGFtbWVyVG9Nb3VzZShldmVudCkge1xuXG4gICAgICAgIC8vIENvbnZlcnQgSGFtbWVyIHRvdWNoLWV2ZW50IFgsWSBpbnRvIG1vdXNlLWV2ZW50IFgsWS5cbiAgICAgICAgZXZlbnQuc2hpZnRLZXkgPSBmYWxzZTtcbiAgICAgICAgZXZlbnQuY2xpZW50WCA9IGV2ZW50LnBvaW50ZXJzWzBdLmNsaWVudFg7XG4gICAgICAgIGV2ZW50LmNsaWVudFkgPSBldmVudC5wb2ludGVyc1swXS5jbGllbnRZO1xuICAgIH1cblxuICAgIG5hbWVzcGFjZS5JbnB1dEhhbmRsZXIgPSBJbnB1dEhhbmRsZXI7XG5cbn0pKCk7XG5cclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuICAgIHZhciBuYW1lc3BhY2VVdGlscyA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuVXRpbHM7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgRWRpdE1vZGVzLjxicj5cbiAgICAgKiBBbiBFZGl0TW9kZSBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdXNlciBpbnB1dCB0byBjcmVhdGUgYW5kIGVkaXQgYVxuICAgICAqIFtNYXJrdXBde0BsaW5rIEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3VwfS5cbiAgICAgKlxuICAgICAqIEFueSBjbGFzcyBleHRlbmRpbmcgTWFya3VwIHNob3VsZCBjb250YWluIGF0IGxlYXN0IHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAgICAgKiAtIGRlbGV0ZU1hcmt1cCgpXG4gICAgICogLSBvbk1vdXNlRG93bigpXG4gICAgICogLSBvbk1vdXNlTW92ZSgpXG4gICAgICpcbiAgICAgKiBBIGdvb2QgcmVmZXJlbmNlIGlzIHRoZSBDaXJjbGUgRWRpdE1vZGUgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGluXG4gICAgICogW0VkaXRNb2RlQ2lyY2xlLmpzXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRNb2RlQ2lyY2xlfS5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmUuTWFya3Vwc0NvcmV9IGVkaXRvciAtIE1hcmt1cHMgZXh0ZW5zaW9uLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gQW4gaWRlbnRpZmllciBmb3IgdGhlIEVkaXRNb2RlIHR5cGUuIE5vdCB0byBiZSBjb25mdXNlZCBieSB0aGUgTWFya3VwJ3MgaWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3R5bGVBdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyBmb3IgY3VzdG9taXphdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFZGl0TW9kZShlZGl0b3IsIHR5cGUsIHN0eWxlQXR0cmlidXRlcykge1xuXG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLnZpZXdlciA9IGVkaXRvci52aWV3ZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNYXJrdXAgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmdBbm5vdGF0aW9uSW5pUG9zaXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdnaW5nTW91c2VJbmlQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFggPSAwO1xuICAgICAgICB0aGlzLmluaXRpYWxZID0gMDtcbiAgICAgICAgdGhpcy5taW5TaXplID0gOTsgLy8gSW4gcGl4ZWxzXG4gICAgICAgIHRoaXMuY3JlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0ge3g6IDAsIHk6IDB9O1xuICAgICAgICB0aGlzLnN0eWxlID0gbmFtZXNwYWNlVXRpbHMuY3JlYXRlU3R5bGUoc3R5bGVBdHRyaWJ1dGVzLCB0aGlzLnZpZXdlcik7XG5cbiAgICAgICAgbmFtZXNwYWNlVXRpbHMuYWRkVHJhaXRFdmVudERpc3BhdGNoZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gRXZlbnQgdHlwZXMgLy9cbiAgICBuYW1lc3BhY2UuRVZFTlRfRURJVE1PREVfQ1JFQVRJT05fQkVHSU4gPSBcIkVWRU5UX0VESVRNT0RFX0NSRUFUSU9OX0JFR0lOXCI7XG4gICAgbmFtZXNwYWNlLkVWRU5UX0VESVRNT0RFX0NSRUFUSU9OX0VORCA9IFwiRVZFTlRfRURJVE1PREVfQ1JFQVRJT05fRU5EXCI7XG4gICAgbmFtZXNwYWNlLkVWRU5UX01BUktVUF9ERVNFTEVDVCA9IFwiRVZFTlRfTUFSS1VQX0RFU0VMRUNUXCI7XG5cbiAgICB2YXIgcHJvdG8gPSBFZGl0TW9kZS5wcm90b3R5cGU7XG5cbiAgICBwcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICBuYW1lc3BhY2VVdGlscy5yZW1vdmVUcmFpdEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcbiAgICB9O1xuXG4gICAgcHJvdG8udW5zZWxlY3QgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZmlyZUV2ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZWxlY3RlZE1hcmt1cCA9IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmIChzZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRNYXJrdXAudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNYXJrdXAgPSBudWxsO1xuICAgICAgICAgICAgZmlyZUV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWRpdG9yLmVkaXRGcmFtZS5zZXRNYXJrdXAobnVsbCk7XG5cbiAgICAgICAgaWYgKGZpcmVFdikge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoeyB0eXBlOiBuYW1lc3BhY2UuRVZFTlRfTUFSS1VQX0RFU0VMRUNUIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RvLmNyZWF0ZUJlZ2luID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYoIXRoaXMuY3JlYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoeyB0eXBlOiBuYW1lc3BhY2UuRVZFTlRfRURJVE1PREVfQ1JFQVRJT05fQkVHSU4gfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvdG8uY3JlYXRlRW5kID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuY3JlYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmlyZUV2ZW50KHsgdHlwZTogbmFtZXNwYWNlLkVWRU5UX0VESVRNT0RFX0NSRUFUSU9OX0VORCB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHlsZVxuICAgICAqL1xuICAgIHByb3RvLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcblxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICAgICAgaWYoIXNlbGVjdGVkTWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0U3R5bGUgPSBuZXcgbmFtZXNwYWNlLlNldFN0eWxlKHRoaXMuZWRpdG9yLCBzZWxlY3RlZE1hcmt1cCwgc3R5bGUpO1xuICAgICAgICBzZXRTdHlsZS5leGVjdXRlKCk7XG4gICAgfTtcblxuICAgIHByb3RvLmdldFN0eWxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGU7XG4gICAgfTtcblxuICAgIHByb3RvLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWFya3VwICE9PSBtYXJrdXApIHtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIG1hcmt1cCAmJiBtYXJrdXAuc2VsZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbGVjdGVkTWFya3VwID0gbWFya3VwO1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgbWFya3VwICYmIGVkaXRvci5icmluZ1RvRnJvbnQobWFya3VwKTtcblxuICAgICAgICBpZighdGhpcy5jcmVhdGluZykge1xuICAgICAgICAgICAgZWRpdG9yLmVkaXRGcmFtZS5zZXRNYXJrdXAobWFya3VwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW21hcmt1cF0gSWYgcHJvdmlkZWQgZGVsZXRlcyBtYXJrdXAgKGhhcyB0byBoYXZlIHNhbWUgdHlwZSB0aGF0IHRoZSBlZGl0IG1vZGUpLCBvdGhlcndpc2UgZGVsZXRlcyBzZWxlY3RlZCBvbmUuXG4gICAgICogQHBhcmFtIFtjYW50VW5kb10gSWYgdHJ1ZSB0byBub3QgYWRkIGRlbGV0aW9uIHRvIHVuZG8gaGlzdG9yeS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBwcm90by5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbiAobWFya3VwLCBjYW50VW5kbykge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBjbGFzc2VzIGV4dGVuZGluZyBFZGl0TW9kZSB0byB2YWxpZGF0ZSB0aGUgbWluaW11bSBzaXplIChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpIG9mIHRoZSBtYXJrdXAuXG4gICAgICogU2VlIG1pblNpemUgYXR0cmlidXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBjdXJyZW50IHNpemUgaXMgdmFsaWQgZm9yIGNyZWF0aW5nIHRoZSBtYXJrdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLmlzTWluU2l6ZVZhbGlkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1pblNpemUgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgdG1wID0gdGhpcy5lZGl0b3Iuc2l6ZUZyb21NYXJrdXBzVG9DbGllbnQodGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcbiAgICAgICAgcmV0dXJuICh0bXAueCp0bXAueCArIHRtcC55KnRtcC55KSA+PSAodGhpcy5taW5TaXplICogdGhpcy5taW5TaXplKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5zdGFydERyYWdnaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB0aGlzLmVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTWFya3VwKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdBbm5vdGF0aW9uSW5pUG9zaXRpb24gPSBzZWxlY3RlZE1hcmt1cC5nZXRDbGllbnRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ01vdXNlSW5pUG9zaXRpb24uc2V0KG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLmZpbmlzaERyYWdnaW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZztcbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5zZWxlY3RlZE1hcmt1cDtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkTWFya3VwICYmIGRyYWdnaW5nKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE1hcmt1cC5maW5pc2hEcmFnZ2luZygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICovXG4gICAgcHJvdG8uZ2V0RmluYWxNb3VzZURyYWdnaW5nUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBib3VuZHMgPSBlZGl0b3IuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgaW5pdGlhbFggPSB0aGlzLmluaXRpYWxYO1xuICAgICAgICB2YXIgaW5pdGlhbFkgPSB0aGlzLmluaXRpYWxZO1xuXG4gICAgICAgIHZhciBmaW5hbFggPSBNYXRoLm1pbihNYXRoLm1heChib3VuZHMueCwgbW91c2VQb3NpdGlvbi54KSwgYm91bmRzLnggKyBib3VuZHMud2lkdGgpO1xuICAgICAgICB2YXIgZmluYWxZID0gTWF0aC5taW4oTWF0aC5tYXgoYm91bmRzLnksIG1vdXNlUG9zaXRpb24ueSksIGJvdW5kcy55ICsgYm91bmRzLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKGZpbmFsWCA9PSBpbml0aWFsWCAmJlxuICAgICAgICAgICAgZmluYWxZID09IGluaXRpYWxZKSB7XG4gICAgICAgICAgICBmaW5hbFgrKztcbiAgICAgICAgICAgIGZpbmFsWSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBlcXVhbCB4L3kgd2hlbiBzaGlmdCBpcyBkb3duXG4gICAgICAgIGlmIChlZGl0b3IuaW5wdXQubWFrZVNhbWVYWSkge1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoZmluYWxYIC0gaW5pdGlhbFgpO1xuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnMoZmluYWxZIC0gaW5pdGlhbFkpO1xuXG4gICAgICAgICAgICB2YXIgbWF4RGVsdGEgPSBNYXRoLm1heChkeCwgZHkpO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBjYWxjdWxhdGlvbnMgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gZ28gYmV5b25kICdib3VuZHMnLlxuICAgICAgICAgICAgZmluYWxYID0gaW5pdGlhbFggKyBtYXhEZWx0YSAqIG5hbWVzcGFjZVV0aWxzLnNpZ24oZmluYWxYIC0gaW5pdGlhbFgpO1xuICAgICAgICAgICAgZmluYWxZID0gaW5pdGlhbFkgKyBtYXhEZWx0YSAqIG5hbWVzcGFjZVV0aWxzLnNpZ24oZmluYWxZIC0gaW5pdGlhbFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgeDpmaW5hbFgsIHk6ZmluYWxZIH07XG4gICAgfTtcblxuICAgIHByb3RvLm5vdGlmeUFsbG93TmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGFsbG93cykge1xuXG4gICAgfTtcblxuICAgIHByb3RvLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgdXAgZXZlbnRzLCB1c2VkIHRvIHN0YXJ0IGFubm90YXRpb25zIGNyZWF0aW9uLlxuICAgICAqIEl0IHdpbGwgY2FuY2VsIHRoZSBjcmVhdGlvbiBvZiBhIG1hcmt1cCBpZiBpdHMgbWluU2l6ZSBjb25kaXRpb25zIGFyZSBub3QgbWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLm9uTW91c2VVcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNYXJrdXAgJiYgdGhpcy5jcmVhdGluZyAmJiAhdGhpcy5pc01pblNpemVWYWxpZCgpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRW5kKCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5jYW5jZWxBY3Rpb25Hcm91cCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1hcmt1cCA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybjsgLy8gWXVwLCBqdXN0IHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5pc2hEcmFnZ2luZygpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRNYXJrdXAgPSB0aGlzLnNlbGVjdGVkTWFya3VwO1xuICAgICAgICBpZiAoc2VsZWN0ZWRNYXJrdXAgJiYgdGhpcy5jcmVhdGluZykge1xuXG4gICAgICAgICAgICBzZWxlY3RlZE1hcmt1cC5jcmVhdGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUVuZCgpO1xuXG4gICAgICAgICAgICAvLyBPcGVuZWQgb24gbW91c2UgZG93bi5cbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmNsb3NlQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgfTtcblxuICAgIHByb3RvLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgIH07XG5cbiAgICBwcm90by5jYW5jZWxNYXJrdXBDcmVhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuY3JlYXRlRW5kKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNhbmNlbEFjdGlvbkdyb3VwKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNYXJrdXAgPSBudWxsOyAvLyBObyBuZWVkIHRvIGNhbGwgdW5zZWxlY3RcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3g6ICosIHk6ICp9fVxuICAgICAqL1xuICAgIHByb3RvLmdldERyYWdnaW5nUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB0aGlzLmVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIGR4ID0gbW91c2VQb3NpdGlvbi54IC0gdGhpcy5kcmFnZ2luZ01vdXNlSW5pUG9zaXRpb24ueDtcbiAgICAgICAgdmFyIGR5ID0gbW91c2VQb3NpdGlvbi55IC0gdGhpcy5kcmFnZ2luZ01vdXNlSW5pUG9zaXRpb24ueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdGhpcy5kcmFnZ2luZ0Fubm90YXRpb25JbmlQb3NpdGlvbi54ICsgZHgsXG4gICAgICAgICAgICB5OiB0aGlzLmRyYWdnaW5nQW5ub3RhdGlvbkluaVBvc2l0aW9uLnkgKyBkeVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gYm91bmRzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQG9yaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5pc0luc2lkZUJvdW5kcyA9IGZ1bmN0aW9uICh4LCB5LCBib3VuZHMpIHtcblxuICAgICAgICByZXR1cm4geCA+PSBib3VuZHMueCAmJiB4IDw9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoICYmXG4gICAgICAgICAgICAgICB5ID49IGJvdW5kcy55ICYmIHkgPD0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0O1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRWRpdE1vZGUgPSBFZGl0TW9kZTtcblxufSkoKTtcblxyXG4oZnVuY3Rpb24oKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG5hbWVzcGFjZSA9IEF1dG9kZXNrLlZpZXdpbmcuRXh0ZW5zaW9ucy5NYXJrdXBzLkNvcmU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlZGl0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFZGl0TW9kZUFycm93KGVkaXRvcikge1xuXG4gICAgICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSBbJ3N0cm9rZS13aWR0aCcsICdzdHJva2UtY29sb3InLCAnc3Ryb2tlLW9wYWNpdHknXTtcbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLmNhbGwodGhpcywgZWRpdG9yLCBuYW1lc3BhY2UuTUFSS1VQX1RZUEVfQVJST1csIHN0eWxlQXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgRWRpdE1vZGVBcnJvdy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0TW9kZS5wcm90b3R5cGUpO1xuICAgIEVkaXRNb2RlQXJyb3cucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRpdE1vZGVBcnJvdztcblxuXG4gICAgdmFyIHByb3RvID0gRWRpdE1vZGVBcnJvdy5wcm90b3R5cGU7XG5cbiAgICBwcm90by5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXAsIGNhbnRVbmRvKSB7XG5cbiAgICAgICAgbWFya3VwID0gbWFya3VwIHx8IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLnR5cGUgPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlQXJyb3cgPSBuZXcgbmFtZXNwYWNlLkRlbGV0ZUFycm93KHRoaXMuZWRpdG9yLCBtYXJrdXApO1xuICAgICAgICAgICAgZGVsZXRlQXJyb3cuYWRkVG9IaXN0b3J5ID0gIWNhbnRVbmRvO1xuICAgICAgICAgICAgZGVsZXRlQXJyb3cuZXhlY3V0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIGRvd24gZXZlbnRzLCB1c2VkIHRvIHN0YXJ0IG1hcmt1cHMgY3JlYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5wcm90b3R5cGUub25Nb3VzZURvd24uY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSB0aGlzLmVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsWCA9IG1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5pbml0aWFsWSA9IG1vdXNlUG9zaXRpb24ueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgaGVhZCBhbmQgdGFpbC5cbiAgICAgICAgdmFyIHdpZHRoID0gMTsgLy8gVE9ETzogV2hlbiBhbiBBcnJvdyB0b28gc2hvcnQgaXMgY3JlYXRlZCwgaXQgc2hvdWxkIGFjdHVhbGx5IGJlIGlnbm9yZWQuXG4gICAgICAgIHZhciBoZWFkID0ge3g6IHRoaXMuaW5pdGlhbFgsIHk6IHRoaXMuaW5pdGlhbFl9O1xuICAgICAgICB2YXIgdGFpbCA9IHt4OiBNYXRoLnJvdW5kKGhlYWQueCArIE1hdGguY29zKCBNYXRoLlBJICogMC4yNSkgKiB3aWR0aCksIHk6IE1hdGgucm91bmQoaGVhZC55ICsgTWF0aC5zaW4oLU1hdGguUEkgKiAwLjI1KSAqIHdpZHRoKX07XG5cbiAgICAgICAgLy8gQ29uc3RyYWluIGhlYWQgYW5kIHRhaWwgaW5zaWRlIHdvcmtpbmcgYXJlYS5cbiAgICAgICAgdmFyIGNvbnN0cmFpbiA9IGZ1bmN0aW9uKGhlYWQsIHRhaWwsIHdpZHRoLCBib3VuZHMpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnNpZGVCb3VuZHModGFpbC54LCB0YWlsLnksIGJvdW5kcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhaWwueSA9IE1hdGgucm91bmQoaGVhZC55ICsgTWF0aC5zaW4oIE1hdGguUEkgKiAwLjI1KSAqIHdpZHRoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5zaWRlQm91bmRzKCB0YWlsLngsIHRhaWwueSwgYm91bmRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFpbC54ID0gTWF0aC5yb3VuZChoZWFkLnkgKyBNYXRoLmNvcygtTWF0aC5QSSAqIDAuMjUpICogd2lkdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnNpZGVCb3VuZHMoIHRhaWwueCwgdGFpbC55LCBib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YWlsLnkgPSBNYXRoLnJvdW5kKGhlYWQueSArIE1hdGguc2luKC1NYXRoLlBJICogMC4yNSkgKiB3aWR0aCk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgY29uc3RyYWluKCBoZWFkLCB0YWlsLCB3aWR0aCwgZWRpdG9yLmdldEJvdW5kcygpKTtcblxuICAgICAgICAvLyBDcmVhdGUgYXJyb3cuXG4gICAgICAgIGVkaXRvci5iZWdpbkFjdGlvbkdyb3VwKCk7XG5cbiAgICAgICAgaGVhZCA9IGVkaXRvci5wb3NpdGlvbkZyb21DbGllbnRUb01hcmt1cHMoaGVhZC54LCBoZWFkLnkpO1xuICAgICAgICB0YWlsID0gZWRpdG9yLnBvc2l0aW9uRnJvbUNsaWVudFRvTWFya3Vwcyh0YWlsLngsIHRhaWwueSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHt4OiB0YWlsLnggLSBoZWFkLngsIHk6IHRhaWwueSAtIGhlYWQueX07XG5cbiAgICAgICAgdmFyIGFycm93SWQgPSBlZGl0b3IuZ2V0SWQoKTtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IG5ldyBuYW1lc3BhY2UuQ3JlYXRlQXJyb3coZWRpdG9yLCBhcnJvd0lkLCBoZWFkLCB0YWlsLCB0aGlzLnN0eWxlKTtcbiAgICAgICAgY3JlYXRlLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTWFya3VwID0gZWRpdG9yLmdldE1hcmt1cChhcnJvd0lkKTtcbiAgICAgICAgdGhpcy5jcmVhdGVCZWdpbigpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIG1vdmUgZXZlbnRzLCB1c2VkIHRvIGNyZWF0ZSBtYXJrdXBzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5vbk1vdXNlTW92ZS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG4gICAgICAgIHZhciBzZWxlY3RlZE1hcmt1cCA9IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmKCFzZWxlY3RlZE1hcmt1cCB8fCAhdGhpcy5jcmVhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgZmluYWwgPSB0aGlzLmdldEZpbmFsTW91c2VEcmFnZ2luZ1Bvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIGhlYWQgPSBlZGl0b3IucG9zaXRpb25Gcm9tQ2xpZW50VG9NYXJrdXBzKHRoaXMuaW5pdGlhbFgsIHRoaXMuaW5pdGlhbFkpO1xuICAgICAgICB2YXIgdGFpbCA9IGVkaXRvci5wb3NpdGlvbkZyb21DbGllbnRUb01hcmt1cHMoZmluYWwueCwgZmluYWwueSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHt4OiB0YWlsLnggLSBoZWFkLngsIHk6IHRhaWwueSAtIGhlYWQueX07XG5cbiAgICAgICAgdmFyIHNldEFycm93ID0gbmV3IG5hbWVzcGFjZS5TZXRBcnJvdyhlZGl0b3IsIHNlbGVjdGVkTWFya3VwLCBoZWFkLCB0YWlsKTtcbiAgICAgICAgc2V0QXJyb3cuZXhlY3V0ZSgpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRWRpdE1vZGVBcnJvdyA9IEVkaXRNb2RlQXJyb3c7XG5cbn0pKCk7XHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIC8qKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEltcGxlbWVudHMgYSBDaXJjbGUgW0VkaXRNb2RlXXtAbGluayBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLkVkaXRNb2RlfS5cbiAgICAgKiBJbmNsdWRlZCBpbiBkb2N1bWVudGF0aW9uIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIGNyZWF0ZVxuICAgICAqIGFuIEVkaXRNb2RlIGZvciBhIHNwZWNpZmljIG1hcmt1cCB0eXBlLiBEZXZlbG9wZXJzIGFyZSBlbmNvdXJhZ2UgdG8gbG9vayBpbnRvIHRoaXMgY2xhc3MncyBzb3VyY2UgY29kZSBhbmQgY29weVxuICAgICAqIGFzIG11Y2ggY29kZSBhcyB0aGV5IG5lZWQuIEZpbmQgbGluayB0byBzb3VyY2UgY29kZSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEB0dXRvcmlhbCBmZWF0dXJlX21hcmt1cFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlXG4gICAgICogQGV4dGVuZHMgQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZS5FZGl0TW9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLk1hcmt1cHNDb3JlfSBlZGl0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFZGl0TW9kZUNpcmNsZShlZGl0b3IpIHtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5JywgJ2ZpbGwtY29sb3InLCAnZmlsbC1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5jYWxsKHRoaXMsIGVkaXRvciwgbmFtZXNwYWNlLk1BUktVUF9UWVBFX0NJUkNMRSwgc3R5bGVBdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICBFZGl0TW9kZUNpcmNsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG5hbWVzcGFjZS5FZGl0TW9kZS5wcm90b3R5cGUpO1xuICAgIEVkaXRNb2RlQ2lyY2xlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkaXRNb2RlQ2lyY2xlO1xuXG4gICAgdmFyIHByb3RvID0gRWRpdE1vZGVDaXJjbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZGVsZXRlTWFya3VwID0gZnVuY3Rpb24obWFya3VwLCBjYW50VW5kbykge1xuXG4gICAgICAgIG1hcmt1cCA9IG1hcmt1cCB8fCB0aGlzLnNlbGVjdGVkTWFya3VwO1xuICAgICAgICBpZiAobWFya3VwICYmIG1hcmt1cC50eXBlID09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZUNpcmNsZSA9IG5ldyBuYW1lc3BhY2UuRGVsZXRlQ2lyY2xlKHRoaXMuZWRpdG9yLCBtYXJrdXApO1xuICAgICAgICAgICAgZGVsZXRlQ2lyY2xlLmFkZFRvSGlzdG9yeSA9ICFjYW50VW5kbztcbiAgICAgICAgICAgIGRlbGV0ZUNpcmNsZS5leGVjdXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgbW92ZSBldmVudHMsIHVzZWQgdG8gY3JlYXRlIG1hcmt1cHMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUucHJvdG90eXBlLm9uTW91c2VNb3ZlLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICAgICAgaWYoIXNlbGVjdGVkTWFya3VwIHx8ICF0aGlzLmNyZWF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBpbml0aWFsWCA9IHRoaXMuaW5pdGlhbFg7XG4gICAgICAgIHZhciBpbml0aWFsWSA9IHRoaXMuaW5pdGlhbFk7XG5cbiAgICAgICAgdmFyIGZpbmFsID0gdGhpcy5nZXRGaW5hbE1vdXNlRHJhZ2dpbmdQb3NpdGlvbigpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKChpbml0aWFsWCArIGZpbmFsLngpLzIsIChpbml0aWFsWSArIGZpbmFsLnkpLzIpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSA9IGVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3VwcygoZmluYWwueCAtIGluaXRpYWxYKSwgKGZpbmFsLnkgLSBpbml0aWFsWSkpO1xuXG4gICAgICAgIHZhciBzZXRDaXJjbGUgPSBuZXcgbmFtZXNwYWNlLlNldENpcmNsZShcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHNlbGVjdGVkTWFya3VwLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplKTtcblxuICAgICAgICBzZXRDaXJjbGUuZXhlY3V0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIGRvd24gZXZlbnRzLCB1c2VkIHRvIHN0YXJ0IG1hcmt1cHMgY3JlYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5wcm90b3R5cGUub25Nb3VzZURvd24uY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsWCA9IG1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5pbml0aWFsWSA9IG1vdXNlUG9zaXRpb24ueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgY2VudGVyIGFuZCBzaXplLlxuICAgICAgICB2YXIgcG9zaXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKHRoaXMuaW5pdGlhbFgsIHRoaXMuaW5pdGlhbFkpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSA9IGVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3VwcygxLCAxKTtcblxuICAgICAgICAvLyBDcmVhdGUgY2lyY2xlLlxuICAgICAgICBlZGl0b3IuYmVnaW5BY3Rpb25Hcm91cCgpO1xuXG4gICAgICAgIHZhciBtYXJrdXBJZCA9IGVkaXRvci5nZXRJZCgpO1xuICAgICAgICB2YXIgY3JlYXRlID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVDaXJjbGUoXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBtYXJrdXBJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnN0eWxlKTtcbiAgICAgICAgY3JlYXRlLmV4ZWN1dGUoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTWFya3VwID0gZWRpdG9yLmdldE1hcmt1cChtYXJrdXBJZCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQmVnaW4oKTtcbiAgICB9O1xuXG4gICAgbmFtZXNwYWNlLkVkaXRNb2RlQ2lyY2xlID0gRWRpdE1vZGVDaXJjbGU7XG5cbn0pKCk7XHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVkaXRvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVkaXRNb2RlQ2xvdWQoZWRpdG9yKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZS1jb2xvcicsICdzdHJva2Utb3BhY2l0eScsICdmaWxsLWNvbG9yJywgJ2ZpbGwtb3BhY2l0eSddO1xuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUuY2FsbCh0aGlzLCBlZGl0b3IsIG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9DTE9VRCwgc3R5bGVBdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICBFZGl0TW9kZUNsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZSk7XG4gICAgRWRpdE1vZGVDbG91ZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGl0TW9kZUNsb3VkO1xuXG4gICAgdmFyIHByb3RvID0gRWRpdE1vZGVDbG91ZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXAsIGNhbnRVbmRvKSB7XG5cbiAgICAgICAgbWFya3VwID0gbWFya3VwIHx8IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLnR5cGUgPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlQ2xvdWQgPSBuZXcgbmFtZXNwYWNlLkRlbGV0ZUNsb3VkKHRoaXMuZWRpdG9yLCBtYXJrdXApO1xuICAgICAgICAgICAgZGVsZXRlQ2xvdWQuYWRkVG9IaXN0b3J5ID0gIWNhbnRVbmRvO1xuICAgICAgICAgICAgZGVsZXRlQ2xvdWQuZXhlY3V0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIG1vdmUgZXZlbnRzLCB1c2VkIHRvIGNyZWF0ZSBtYXJrdXBzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5vbk1vdXNlTW92ZS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG4gICAgICAgIHZhciBzZWxlY3RlZE1hcmt1cCA9IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmKCFzZWxlY3RlZE1hcmt1cCB8fCAhdGhpcy5jcmVhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgaW5pdGlhbFggPSB0aGlzLmluaXRpYWxYO1xuICAgICAgICB2YXIgaW5pdGlhbFkgPSB0aGlzLmluaXRpYWxZO1xuXG4gICAgICAgIHZhciBmaW5hbCA9IHRoaXMuZ2V0RmluYWxNb3VzZURyYWdnaW5nUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZWRpdG9yLmNsaWVudFRvTWFya3VwcygoaW5pdGlhbFggKyBmaW5hbC54KS8yLCAoaW5pdGlhbFkgKyBmaW5hbC55KS8yKTtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSBlZGl0b3Iuc2l6ZUZyb21DbGllbnRUb01hcmt1cHMoKGZpbmFsLnggLSBpbml0aWFsWCksIChmaW5hbC55IC0gaW5pdGlhbFkpKTtcblxuICAgICAgICB2YXIgc2V0Q2xvdWQgPSBuZXcgbmFtZXNwYWNlLlNldENsb3VkKFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgc2VsZWN0ZWRNYXJrdXAsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHNpemUpO1xuXG4gICAgICAgIHNldENsb3VkLmV4ZWN1dGUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciB0byBtb3VzZSBkb3duIGV2ZW50cywgdXNlZCB0byBzdGFydCBtYXJrdXBzIGNyZWF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8ub25Nb3VzZURvd24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUucHJvdG90eXBlLm9uTW91c2VEb3duLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNYXJrdXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBlZGl0b3IuZ2V0TW91c2VQb3NpdGlvbigpO1xuXG4gICAgICAgIHRoaXMuaW5pdGlhbFggPSBtb3VzZVBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuaW5pdGlhbFkgPSBtb3VzZVBvc2l0aW9uLnk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNlbnRlciBhbmQgc2l6ZS5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZWRpdG9yLmNsaWVudFRvTWFya3Vwcyh0aGlzLmluaXRpYWxYLCB0aGlzLmluaXRpYWxZKTtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSBlZGl0b3Iuc2l6ZUZyb21DbGllbnRUb01hcmt1cHMoMSwgMSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIENsb3VkLlxuICAgICAgICBlZGl0b3IuYmVnaW5BY3Rpb25Hcm91cCgpO1xuXG4gICAgICAgIHZhciBtYXJrdXBJZCA9IGVkaXRvci5nZXRJZCgpO1xuICAgICAgICB2YXIgY3JlYXRlID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVDbG91ZChcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIG1hcmt1cElkLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIGNyZWF0ZS5leGVjdXRlKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZE1hcmt1cCA9IGVkaXRvci5nZXRNYXJrdXAobWFya3VwSWQpO1xuICAgICAgICB0aGlzLmNyZWF0ZUJlZ2luKCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5FZGl0TW9kZUNsb3VkID0gRWRpdE1vZGVDbG91ZDtcblxufSkoKTtcclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWRpdE1vZGVGcmVlaGFuZChlZGl0b3IpIHtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5jYWxsKHRoaXMsIGVkaXRvciwgbmFtZXNwYWNlLk1BUktVUF9UWVBFX0ZSRUVIQU5ELCBzdHlsZUF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLnN0eWxlWydzdHJva2Utb3BhY2l0eSddID0gMC43NTtcbiAgICB9XG5cbiAgICBFZGl0TW9kZUZyZWVoYW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZSk7XG4gICAgRWRpdE1vZGVGcmVlaGFuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGl0TW9kZUZyZWVoYW5kO1xuXG4gICAgdmFyIHByb3RvID0gRWRpdE1vZGVGcmVlaGFuZC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXAsIGNhbnRVbmRvKSB7XG5cbiAgICAgICAgbWFya3VwID0gbWFya3VwIHx8IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLnR5cGUgPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlRnJlZWhhbmQgPSBuZXcgbmFtZXNwYWNlLkRlbGV0ZUZyZWVoYW5kKHRoaXMuZWRpdG9yLCBtYXJrdXApO1xuICAgICAgICAgICAgZGVsZXRlRnJlZWhhbmQuYWRkVG9IaXN0b3J5ID0gIWNhbnRVbmRvO1xuICAgICAgICAgICAgZGVsZXRlRnJlZWhhbmQuZXhlY3V0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIG1vdmUgZXZlbnRzLCB1c2VkIHRvIGNyZWF0ZSBtYXJrdXBzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgTW91c2UgZXZlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5vbk1vdXNlTW92ZS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG4gICAgICAgIHZhciBzZWxlY3RlZE1hcmt1cCA9IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmKCFzZWxlY3RlZE1hcmt1cCB8fCAhdGhpcy5jcmVhdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBtb3ZlbWVudHMgPSB0aGlzLm1vdmVtZW50cztcblxuICAgICAgICB2YXIgbG9jYXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55KTtcbiAgICAgICAgbW92ZW1lbnRzLnB1c2gobG9jYXRpb24pO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRvcC1sZWZ0IGFuZCBib3R0b20tcmlnaHQgcG9pbnRzXG4gICAgICAgIHZhciBtaW5GbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGtleSl7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGNvbGxlY3Rpb24ubWFwKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB0YXJnZXRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbWF4Rm4gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBrZXkpe1xuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBjb2xsZWN0aW9uLm1hcChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgdGFyZ2V0cyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgbCA9IG1pbkZuKG1vdmVtZW50cywgJ3gnKTtcbiAgICAgICAgdmFyIHQgPSBtaW5Gbihtb3ZlbWVudHMsICd5Jyk7XG4gICAgICAgIHZhciByID0gbWF4Rm4obW92ZW1lbnRzLCAneCcpO1xuICAgICAgICB2YXIgYiA9IG1heEZuKG1vdmVtZW50cywgJ3knKTtcblxuICAgICAgICB2YXIgd2lkdGggPSByIC0gbDsgIC8vIEFscmVhZHkgaW4gbWFya3VwIGNvb3JkcyBzcGFjZVxuICAgICAgICB2YXIgaGVpZ2h0ID0gYiAtIHQ7IC8vIEFscmVhZHkgaW4gbWFya3VwIGNvb3JkcyBzcGFjZVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IGwgKyB3aWR0aCAqIDAuNSxcbiAgICAgICAgICAgIHk6IHQgKyBoZWlnaHQgKiAwLjVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSB7eDogd2lkdGgsIHk6IGhlaWdodH07XG5cbiAgICAgICAgLy8gQWRqdXN0IHBvaW50cyB0byByZWxhdGUgZnJvbSB0aGUgc2hhcGUncyBjZW50ZXJcbiAgICAgICAgdmFyIGxvY2F0aW9ucyA9IG1vdmVtZW50cy5tYXAoZnVuY3Rpb24ocG9pbnQpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBwb2ludC54IC0gcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBwb2ludC55IC0gcG9zaXRpb24ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNldEZyZWVoYW5kID0gbmV3IG5hbWVzcGFjZS5TZXRGcmVlaGFuZChcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHNlbGVjdGVkTWFya3VwLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgbG9jYXRpb25zKTtcblxuICAgICAgICBzZXRGcmVlaGFuZC5leGVjdXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgZG93biBldmVudHMsIHVzZWQgdG8gc3RhcnQgbWFya3VwcyBjcmVhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLm9uTW91c2VEb3duID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5vbk1vdXNlRG93bi5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkTWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZWRpdG9yLmdldE1vdXNlUG9zaXRpb24oKTtcblxuICAgICAgICB0aGlzLmluaXRpYWxYID0gbW91c2VQb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmluaXRpYWxZID0gbW91c2VQb3NpdGlvbi55O1xuXG4gICAgICAgIC8vc2V0IHRoZSBzdGFydGluZyBwb2ludFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKHRoaXMuaW5pdGlhbFgsIHRoaXMuaW5pdGlhbFkpO1xuICAgICAgICB0aGlzLm1vdmVtZW50cyA9IFtwb3NpdGlvbl07XG5cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSBlZGl0b3Iuc2l6ZUZyb21DbGllbnRUb01hcmt1cHMoMSwgMSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFycm93LlxuICAgICAgICBlZGl0b3IuYmVnaW5BY3Rpb25Hcm91cCgpO1xuXG4gICAgICAgIHZhciBtYXJrdXBJZCA9IGVkaXRvci5nZXRJZCgpO1xuICAgICAgICB2YXIgY3JlYXRlID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVGcmVlaGFuZChcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIG1hcmt1cElkLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIFt7eDogMCwgeTogMCB9XSxcbiAgICAgICAgICAgIHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIGNyZWF0ZS5leGVjdXRlKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZE1hcmt1cCA9IGVkaXRvci5nZXRNYXJrdXAobWFya3VwSWQpO1xuICAgICAgICB0aGlzLmNyZWF0ZUJlZ2luKCk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5FZGl0TW9kZUZyZWVoYW5kID0gRWRpdE1vZGVGcmVlaGFuZDtcblxufSkoKTtcclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWRpdE1vZGVSZWN0YW5nbGUoZWRpdG9yKSB7XG5cbiAgICAgICAgdmFyIHN0eWxlQXR0cmlidXRlcyA9IFsnc3Ryb2tlLXdpZHRoJywgJ3N0cm9rZS1jb2xvcicsICdzdHJva2Utb3BhY2l0eScsICdmaWxsLWNvbG9yJywgJ2ZpbGwtb3BhY2l0eSddO1xuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUuY2FsbCh0aGlzLCBlZGl0b3IsIG5hbWVzcGFjZS5NQVJLVVBfVFlQRV9SRUNUQU5HTEUsIHN0eWxlQXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgRWRpdE1vZGVSZWN0YW5nbGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShuYW1lc3BhY2UuRWRpdE1vZGUucHJvdG90eXBlKTtcbiAgICBFZGl0TW9kZVJlY3RhbmdsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGl0TW9kZVJlY3RhbmdsZTtcblxuICAgIHZhciBwcm90byA9IEVkaXRNb2RlUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuICAgIHByb3RvLmRlbGV0ZU1hcmt1cCA9IGZ1bmN0aW9uKG1hcmt1cCwgY2FudFVuZG8pIHtcblxuICAgICAgICBtYXJrdXAgPSBtYXJrdXAgfHwgdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICAgICAgaWYgKG1hcmt1cCAmJiBtYXJrdXAudHlwZSA9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkZWxldGVSZWN0YW5nbGUgPSBuZXcgbmFtZXNwYWNlLkRlbGV0ZVJlY3RhbmdsZSh0aGlzLmVkaXRvciwgbWFya3VwKTtcbiAgICAgICAgICAgIGRlbGV0ZVJlY3RhbmdsZS5hZGRUb0hpc3RvcnkgPSAhY2FudFVuZG87XG4gICAgICAgICAgICBkZWxldGVSZWN0YW5nbGUuZXhlY3V0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG11bHRpcGxlIHRleHQgcHJvcGVydGllcyBhdCBvbmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICovXG4gICAgcHJvdG8uc2V0U3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUucHJvdG90eXBlLnNldFN0eWxlLmNhbGwodGhpcywgc3R5bGUpO1xuXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLnNlbGVjdGVkTWFya3VwO1xuICAgICAgICBpZighcmVjdGFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBDaGFuZ2UgdG8gdXNlIFNldFN0eWxlIC8vXG4gICAgICAgIHZhciBzZXRSZWN0YW5nbGUgPSBuZXcgbmFtZXNwYWNlLlNldFJlY3RhbmdsZShcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLnBvc2l0aW9uLFxuICAgICAgICAgICAgcmVjdGFuZ2xlLnNpemUpO1xuXG4gICAgICAgIHNldFJlY3RhbmdsZS5leGVjdXRlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgbW92ZSBldmVudHMsIHVzZWQgdG8gY3JlYXRlIG1hcmt1cHMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByb3RvLm9uTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBuYW1lc3BhY2UuRWRpdE1vZGUucHJvdG90eXBlLm9uTW91c2VNb3ZlLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTWFya3VwID0gdGhpcy5zZWxlY3RlZE1hcmt1cDtcbiAgICAgICAgaWYoIXNlbGVjdGVkTWFya3VwIHx8ICF0aGlzLmNyZWF0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIHZhciBpbml0aWFsWCA9IHRoaXMuaW5pdGlhbFg7XG4gICAgICAgIHZhciBpbml0aWFsWSA9IHRoaXMuaW5pdGlhbFk7XG5cbiAgICAgICAgdmFyIGZpbmFsID0gdGhpcy5nZXRGaW5hbE1vdXNlRHJhZ2dpbmdQb3NpdGlvbigpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKChpbml0aWFsWCArIGZpbmFsLngpLzIsIChpbml0aWFsWSArIGZpbmFsLnkpLzIpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSA9IGVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3VwcygoZmluYWwueCAtIGluaXRpYWxYKSwgKGZpbmFsLnkgLSBpbml0aWFsWSkpO1xuXG4gICAgICAgIHZhciBzZXRSZWN0YW5nbGUgPSBuZXcgbmFtZXNwYWNlLlNldFJlY3RhbmdsZShcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHNlbGVjdGVkTWFya3VwLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBzaXplKTtcblxuICAgICAgICBzZXRSZWN0YW5nbGUuZXhlY3V0ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIHRvIG1vdXNlIGRvd24gZXZlbnRzLCB1c2VkIHRvIHN0YXJ0IG1hcmt1cHMgY3JlYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5wcm90b3R5cGUub25Nb3VzZURvd24uY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsWCA9IG1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgdGhpcy5pbml0aWFsWSA9IG1vdXNlUG9zaXRpb24ueTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgY2VudGVyIGFuZCBzaXplLlxuICAgICAgICB2YXIgcG9zaXRpb24gPSBlZGl0b3IuY2xpZW50VG9NYXJrdXBzKHRoaXMuaW5pdGlhbFgsIHRoaXMuaW5pdGlhbFkpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSA9IGVkaXRvci5zaXplRnJvbUNsaWVudFRvTWFya3VwcygxLCAxKTtcblxuICAgICAgICAvLyBDcmVhdGUgcmVjdGFuZ2xlLlxuICAgICAgICBlZGl0b3IuYmVnaW5BY3Rpb25Hcm91cCgpO1xuXG4gICAgICAgIHZhciBtYXJrdXBJZCA9IGVkaXRvci5nZXRJZCgpO1xuICAgICAgICB2YXIgY3JlYXRlID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVSZWN0YW5nbGUoXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBtYXJrdXBJZCxcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB0aGlzLnN0eWxlKTtcblxuICAgICAgICBjcmVhdGUuZXhlY3V0ZSgpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNYXJrdXAgPSBlZGl0b3IuZ2V0TWFya3VwKG1hcmt1cElkKTtcbiAgICAgICAgdGhpcy5jcmVhdGVCZWdpbigpO1xuICAgIH07XG5cbiAgICBuYW1lc3BhY2UuRWRpdE1vZGVSZWN0YW5nbGUgPSBFZGl0TW9kZVJlY3RhbmdsZTtcblxufSkoKTtcclxuKGZ1bmN0aW9uKCl7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBuYW1lc3BhY2UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWRpdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWRpdE1vZGVUZXh0KGVkaXRvcikge1xuXG4gICAgICAgIHZhciBzdHlsZUF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICAgICAnZm9udC1zaXplJyxcbiAgICAgICAgICAgICdzdHJva2UtY29sb3InLCAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAgICAgJ2ZpbGwtY29sb3InLCAnZmlsbC1vcGFjaXR5JyxcbiAgICAgICAgICAgICdmb250LWZhbWlseScsXG4gICAgICAgICAgICAnZm9udC1zdHlsZScsXG4gICAgICAgICAgICAnZm9udC13ZWlnaHQnXG4gICAgICAgIF07XG4gICAgICAgIG5hbWVzcGFjZS5FZGl0TW9kZS5jYWxsKHRoaXMsIGVkaXRvciwgbmFtZXNwYWNlLk1BUktVUF9UWVBFX1RFWFQsIHN0eWxlQXR0cmlidXRlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVbJ2ZpbGwtY29sb3InXSA9ICcjZmZmZmZmJztcblxuICAgICAgICB2YXIgaGVscGVyID0gbmV3IG5hbWVzcGFjZS5FZGl0b3JUZXh0SW5wdXQodGhpcy52aWV3ZXIuY29udGFpbmVyLCB0aGlzLmVkaXRvcik7XG4gICAgICAgIGhlbHBlci5hZGRFdmVudExpc3RlbmVyKGhlbHBlci5FVkVOVF9URVhUX0NIQU5HRSwgdGhpcy5vbkhlbHBlclRleHRDaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlciA9IGhlbHBlcjtcbiAgICAgICAgdGhpcy5vbkhpc3RvcnlDaGFuZ2VCaW5kZWQgPSB0aGlzLm9uSGlzdG9yeUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1pblNpemUgPSAwOyAvLyBObyBuZWVkIHRvIHNpemUgaXQgaW5pdGlhbGx5XG4gICAgfVxuXG4gICAgRWRpdE1vZGVUZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZSk7XG4gICAgRWRpdE1vZGVUZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkaXRNb2RlVGV4dDtcblxuICAgIHZhciBwcm90byA9IEVkaXRNb2RlVGV4dC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5kZWxldGVNYXJrdXAgPSBmdW5jdGlvbihtYXJrdXAsIGNhbnRVbmRvKSB7XG5cbiAgICAgICAgbWFya3VwID0gbWFya3VwIHx8IHRoaXMuc2VsZWN0ZWRNYXJrdXA7XG4gICAgICAgIGlmIChtYXJrdXAgJiYgbWFya3VwLnR5cGUgPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlVGV4dCA9IG5ldyBuYW1lc3BhY2UuRGVsZXRlVGV4dCh0aGlzLmVkaXRvciwgbWFya3VwKTtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQuYWRkVG9IaXN0b3J5ID0gIWNhbnRVbmRvO1xuICAgICAgICAgICAgZGVsZXRlVGV4dC5leGVjdXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgdG8gbW91c2UgZG93biBldmVudHMsIHVzZWQgdG8gc3RhcnQgbWFya3VwcyBjcmVhdGlvbi5cbiAgICAgKi9cbiAgICBwcm90by5vbk1vdXNlRG93biA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnRleHRJbnB1dEhlbHBlci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlci5hY2NlcHRBbmRFeGl0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1hcmt1cCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGVkaXRvci5nZXRNb3VzZVBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBjbGllbnRGb250U2l6ZSA9IGVkaXRvci5zaXplRnJvbU1hcmt1cHNUb0NsaWVudCgwLCB0aGlzLnN0eWxlWydmb250LXNpemUnXSkueTtcbiAgICAgICAgdmFyIGluaXRpYWxXaWR0aCA9IGNsaWVudEZvbnRTaXplICogMTU7IC8vIEZpbmQgYmV0dGVyIHdheSB0byBpbml0aWFsaXplIHNpemUuXG4gICAgICAgIHZhciBpbml0aWFsSGVpZ2h0ID0gY2xpZW50Rm9udFNpemUgKiAzO1xuXG4gICAgICAgIC8vIENlbnRlciBwb3NpdGlvbi5cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUgPSBlZGl0b3Iuc2l6ZUZyb21DbGllbnRUb01hcmt1cHMoaW5pdGlhbFdpZHRoLCBpbml0aWFsSGVpZ2h0KTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZWRpdG9yLnBvc2l0aW9uRnJvbUNsaWVudFRvTWFya3VwcyhcbiAgICAgICAgICAgIG1vdXNlUG9zaXRpb24ueCArIChpbml0aWFsV2lkdGggKiAwLjUpLFxuICAgICAgICAgICAgbW91c2VQb3NpdGlvbi55ICsgKGluaXRpYWxIZWlnaHQgKiAwLjUpKTtcblxuICAgICAgICBlZGl0b3IuYmVnaW5BY3Rpb25Hcm91cCgpO1xuXG4gICAgICAgIC8vIEdpdmVuIHRoZSBpbml0aWFsIHdpZHRoIGFuZCBmb250IHNpemUsIHdlIGFzc3VtZSB0aGF0IHRoZSB0ZXh0IGZpdHMgaW4gb25lIGxpbmUuXG4gICAgICAgIHZhciBjcmVhdGVUZXh0ID0gbmV3IG5hbWVzcGFjZS5DcmVhdGVUZXh0KFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgZWRpdG9yLmdldElkKCksXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIHRoaXMuc3R5bGUpO1xuXG4gICAgICAgIGNyZWF0ZVRleHQuZXhlY3V0ZSgpO1xuXG4gICAgICAgIHRoaXMuY3JlYXRlQmVnaW4oKTtcbiAgICAgICAgdGhpcy5jcmVhdGVFbmQoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkTWFya3VwID0gZWRpdG9yLmdldE1hcmt1cChjcmVhdGVUZXh0LnRhcmdldElkKTtcbiAgICAgICAgdGhpcy50ZXh0SW5wdXRIZWxwZXIuc2V0QWN0aXZlKHRoaXMuc2VsZWN0ZWRNYXJrdXAsIHRydWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5hY3Rpb25NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlLkVWRU5UX0hJU1RPUllfQ0hBTkdFRCwgdGhpcy5vbkhpc3RvcnlDaGFuZ2VCaW5kZWQpO1xuICAgIH07XG5cbiAgICBwcm90by5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24obWFya3VwKSB7XG4gICAgICAgIGlmIChtYXJrdXAgPT09IHRoaXMuc2VsZWN0ZWRNYXJrdXApIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNlbGVjdE1hcmt1cChudWxsKTtcbiAgICAgICAgICAgIHRoaXMudGV4dElucHV0SGVscGVyLnNldEFjdGl2ZShtYXJrdXAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5vbkhlbHBlclRleHRDaGFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBkYXRhQmFnID0gZXZlbnQuZGF0YTtcbiAgICAgICAgdmFyIHRleHRNYXJrdXAgPSBkYXRhQmFnLm1hcmt1cDtcbiAgICAgICAgdmFyIHRleHRTdHlsZSA9IGRhdGFCYWcuc3R5bGU7XG5cbiAgICAgICAgdGhpcy5lZGl0b3IuYWN0aW9uTWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWVzcGFjZS5FVkVOVF9ISVNUT1JZX0NIQU5HRUQsIHRoaXMub25IaXN0b3J5Q2hhbmdlQmluZGVkKTtcblxuICAgICAgICAvLyBEZWFsIHdpdGggZWRnZSBjYXNlIGZpcnN0OiBDcmVhdGluZyBhIExhYmVsIHdpdGhvdXQgdGV4dFxuICAgICAgICBpZiAoZGF0YUJhZy5uZXdUZXh0ID09PSAnJykge1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBmaWVsZCBpcyBiZWluZyBjcmVhdGVkIGZvciB0aGUgZmlyc3QgdGltZSxcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgb25seSB0byBjYW5jZWwgdGhlIGFjdGlvbiBncm91cCBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgaWYgKGRhdGFCYWcuZmlyc3RFZGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuY2FuY2VsQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZWxlY3RNYXJrdXAobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWxzZSwgd2UgbXVzdCBwZXJmb3JtIGEgRGVsZXRlIGFjdGlvblxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkZWxldGVUZXh0ID0gbmV3IG5hbWVzcGFjZS5EZWxldGVUZXh0KHRoaXMuZWRpdG9yLCB0ZXh0TWFya3VwKTtcbiAgICAgICAgICAgICAgICBkZWxldGVUZXh0LmV4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZWxlY3RNYXJrdXAobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgdGV4dCBpcyBjcmVhdGVkIGZvciB0aGUgZmlyc3QgdGltZSwgYW4gYWN0aW9uIGdyb3VwXG4gICAgICAgIC8vIGlzIGFscmVhZHkgY3JlYXRlZCBhbmQgaXQgaW5jbHVkZXMgdGhlIENyZWF0ZVRleHQgYWN0aW9uLlxuICAgICAgICAvLyBUaHVzLCBubyBuZWVkIHRvIGJlZ2luIGFub3RoZXIgYWN0aW9uIGdyb3VwLlxuICAgICAgICBpZiAoIWRhdGFCYWcuZmlyc3RFZGl0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5iZWdpbkFjdGlvbkdyb3VwKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaXplIGNoYW5nZSBhY3Rpb24gLy9cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5lZGl0b3IucG9zaXRpb25Gcm9tQ2xpZW50VG9NYXJrdXBzKGRhdGFCYWcubmV3UG9zLngsIGRhdGFCYWcubmV3UG9zLnkpO1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZWRpdG9yLnNpemVGcm9tQ2xpZW50VG9NYXJrdXBzKGRhdGFCYWcud2lkdGgsIGRhdGFCYWcuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHNldFNpemUgPSBuZXcgbmFtZXNwYWNlLlNldFNpemUoXG4gICAgICAgICAgICB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHRleHRNYXJrdXAsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHNpemUueCxcbiAgICAgICAgICAgIHNpemUueSk7XG4gICAgICAgIHNldFNpemUuZXhlY3V0ZSgpO1xuXG4gICAgICAgIC8vIFRleHQgY2hhbmdlIGFjdGlvbiAvL1xuICAgICAgICB2YXIgc2V0VGV4dCA9IG5ldyBuYW1lc3BhY2UuU2V0VGV4dChcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdGV4dE1hcmt1cCxcbiAgICAgICAgICAgIHRleHRNYXJrdXAucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0TWFya3VwLnNpemUsXG4gICAgICAgICAgICBkYXRhQmFnLm5ld1RleHQpO1xuICAgICAgICBzZXRUZXh0LmV4ZWN1dGUoKTtcblxuICAgICAgICB2YXIgc2V0U3R5bGUgPSBuZXcgbmFtZXNwYWNlLlNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICB0ZXh0TWFya3VwLFxuICAgICAgICAgICAgdGV4dFN0eWxlXG4gICAgICAgICk7XG4gICAgICAgIHNldFN0eWxlLmV4ZWN1dGUoKTtcblxuICAgICAgICAvLyBIb3dldmVyLCB3ZSBkbyBuZWVkIHRvIGNsb3NlIHRoZSBhY3Rpb24gZ3JvdXAgYXQgdGhpcyBwb2ludC4gRm9yIGJvdGggY2FzZXMuXG4gICAgICAgIHRoaXMuZWRpdG9yLmNsb3NlQWN0aW9uR3JvdXAoKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2VsZWN0TWFya3VwKG51bGwpO1xuXG4gICAgICAgIC8vIFRoZXJlIHNlZW1zIHRvIGJlIHNvbWUgcmVuZGVyaW5nIGlzc3VlcyB3aGVuIGNvbWluZyBvdXQgb2YgdGhlIHRleHQtZWRpdCBtb2RlXG4gICAgICAgIHRleHRNYXJrdXAuZm9yY2VSZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3R5bGVcbiAgICAgKi9cbiAgICBwcm90by5zZXRTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMudGV4dElucHV0SGVscGVyLmlzQWN0aXZlKCkpIHtcblxuICAgICAgICAgICAgdGhpcy50ZXh0SW5wdXRIZWxwZXIuc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5zZXRTdHlsZS5jYWxsKHRoaXMsIHN0eWxlKTtcblxuICAgICAgICAgICAgLy8gQWZ0ZXIgY2hhbmdpbmcgc3R5bGVzLCB0aGUgdGV4dCBnZXRzIHNjcmV3ZWQgdXAuIEZpeCBieSByZS1yZW5kZXJpbmcgaXQuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRNYXJrdXAgPSB0aGlzLnNlbGVjdGVkTWFya3VwO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTWFya3VwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRNYXJrdXAuZm9yY2VSZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBJbnB1dCBIZWxwZXIgZ2V0cyByZW1vdmVkIGZyb20gdGhlIHNjcmVlblxuICAgICAqIHdoZW5ldmVyIHRoZSB1c2VyIGF0dGVtcHRzIHRvIHBlcmZvcm0gYW4gdW5kbyBvciByZWRvIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8ub25IaXN0b3J5Q2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dElucHV0SGVscGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmFjdGlvbk1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lc3BhY2UuRVZFTlRfSElTVE9SWV9DSEFOR0VELCB0aGlzLm9uSGlzdG9yeUNoYW5nZUJpbmRlZCk7XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlci5zZXRJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb3RvLm5vdGlmeUFsbG93TmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGFsbG93cykge1xuICAgICAgICBpZiAoYWxsb3dzICYmIHRoaXMudGV4dElucHV0SGVscGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dElucHV0SGVscGVyLmFjY2VwdEFuZEV4aXQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRJbnB1dEhlbHBlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dElucHV0SGVscGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlci5hY2NlcHRBbmRFeGl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnRleHRJbnB1dEhlbHBlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXNwYWNlLkVkaXRNb2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIG5hbWVzcGFjZS5FZGl0TW9kZVRleHQgPSBFZGl0TW9kZVRleHQ7XG5cbn0pKCk7XHJcbihmdW5jdGlvbigpeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbmFtZXNwYWNlID0gQXV0b2Rlc2suVmlld2luZy5FeHRlbnNpb25zLk1hcmt1cHMuQ29yZTtcbiAgICB2YXIgbmFtZXNwYWNlVXRpbHMgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuXG4gICAgLyoqXG4gICAgICogQXV4aWxpYXJ5IGNsYXNzIHRoYXQgaGFuZGxlcyBhbGwgaW5wdXQgZm9yIHRoZSBMYWJlbCBNYXJrdXAgKE1hcmt1cFRleHQuanMpXG4gICAgICogSXQgaW5zdGFudGlhdGVzIGEgVEVYVEFSRUEgd2hlcmUgdGhlIHVzZXIgY2FuIGlucHV0IHRleHQuIFdoZW4gdXNlciBpbnB1dCBpc1xuICAgICAqIGRpc2FibGVkLCB0aGUgdGV4dGFyZWEgZ2V0cyBoaWRkZW4gYW5kIGZ1cnRoZXIgcmVuZGVyaW5nIGlzIGRlbGVnYXRlZCB0b1xuICAgICAqIE1hcmt1cFRleHQuanNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudERpdlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgLSBDb3JlIEV4dGVuc2lvblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVkaXRvclRleHRJbnB1dChwYXJlbnREaXYsIGVkaXRvcikge1xuXG4gICAgICAgIHRoaXMucGFyZW50RGl2ID0gcGFyZW50RGl2O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAvLyBDb25zdGFudHNcbiAgICAgICAgdGhpcy5FVkVOVF9URVhUX0NIQU5HRSA9ICdFVkVOVF9DTzJfVEVYVF9DSEFOR0UnO1xuXG4gICAgICAgIC8vIFRoZSBhY3R1YWwgVGV4dEFyZWEgaW5wdXRcbiAgICAgICAgdGhpcy50ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIHRoaXMudGV4dEFyZWEuc2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnLCAnMjYwJyk7IC8vIFRPRE86IE1ha2UgY29uc3RhbnQ/IENoYW5nZSB2YWx1ZT9cbiAgICAgICAgdGhpcy50ZXh0QXJlYS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgbmFtZXNwYWNlVXRpbHMuTG9jYWxpemF0aW9uLk1BUktVUF9URVhUX0RFRkFVTFRfVEVYVCk7XG4gICAgICAgIHRoaXMub25LZXlIYW5kbGVyQmluZGVkID0gdGhpcy5vbktleUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50ZXh0QXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleUhhbmRsZXJCaW5kZWQpO1xuXG4gICAgICAgIHRoaXMuc3R5bGVUZXh0QXJlYSA9IG5ldyBuYW1lc3BhY2VVdGlscy5Eb21FbGVtZW50U3R5bGUoKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEVkaXRNb2RlLlxuICAgICAgICB0aGlzLnN0eWxlVGV4dEFyZWFcbiAgICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJylcbiAgICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ292ZXJmbG93LXknLCAnaGlkZGVuJyk7XG5cbiAgICAgICAgLy8gSGVscGVyIGRpdiB0byBtZWFzdXJlIHRleHQgd2lkdGhcbiAgICAgICAgdGhpcy5tZWFzdXJlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgLy8gQmVjb21lIGFuIGV2ZW50IGRpc3BhdGNoZXJcbiAgICAgICAgbmFtZXNwYWNlVXRpbHMuYWRkVHJhaXRFdmVudERpc3BhdGNoZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5vblJlc2l6ZUJpbmRlZCA9IHRoaXMub25XaW5kb3dSZXNpemUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBFZGl0b3JUZXh0SW5wdXQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudGV4dEFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMub25LZXlIYW5kbGVyQmluZGVkKTtcbiAgICAgICAgdGhpcy5zZXRJbmFjdGl2ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBpdHNlbGYgZ2l2ZW4gYW4gTGFiZWwgTWFya3VwICh0ZXh0TWFya3VwKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXh0TWFya3VwXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdEVkaXQgLSBXaGV0aGVyIHRoZSBtYXJrdXAgaXMgYmVpbmcgZWRpdGVkIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgKi9cbiAgICBwcm90by5zZXRBY3RpdmUgPSBmdW5jdGlvbih0ZXh0TWFya3VwLCBmaXJzdEVkaXQpIHtcblxuICAgICAgICBpZiAodGhpcy50ZXh0TWFya3VwID09PSB0ZXh0TWFya3VwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEluYWN0aXZlKCk7XG4gICAgICAgIHRoaXMucGFyZW50RGl2LmFwcGVuZENoaWxkKHRoaXMudGV4dEFyZWEpO1xuICAgICAgICB0aGlzLnRleHRNYXJrdXAgPSB0ZXh0TWFya3VwO1xuICAgICAgICB0aGlzLmZpcnN0RWRpdCA9IGZpcnN0RWRpdCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0RnJvbU1hcmt1cCgpO1xuXG4gICAgICAgIC8vIENvbXBvbmVudCBicmVha3Mgd2hlbiByZXNpemluZy4gVGh1cywgd2UgZm9yY2UgY2xvc2UgaXRcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMub25SZXNpemVCaW5kZWQpO1xuXG4gICAgICAgIC8vIEZvY3VzIG9uIG5leHQgZnJhbWVcbiAgICAgICAgdmFyIHR4dEFyZWEgPSB0aGlzLnRleHRBcmVhO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0eHRBcmVhLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGVkaXRvciB0ZXh0IGlucHV0IGFuZCBnb2VzIGJhY2sgaW50byBub3JtYWwgbWFya3VwIGVkaXRpb24gbW9kZS5cbiAgICAgKi9cbiAgICBwcm90by5zZXRJbmFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplQmluZGVkKTtcblxuICAgICAgICBpZiAodGhpcy50ZXh0TWFya3VwKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRNYXJrdXAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnREaXYucmVtb3ZlQ2hpbGQodGhpcy50ZXh0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgfTtcblxuICAgIHByb3RvLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy50ZXh0TWFya3VwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIE1hcmt1cCBzdHlsZXMgdG8gVGV4dEFyZWEgdXNlZCBmb3IgZWRpdGluZy5cbiAgICAgKiBJdCBhbHNvIHNhdmVzIGEgY29weSBvZiB0aGUgc3R5bGUgb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uaW5pdEZyb21NYXJrdXAgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbWFya3VwID0gdGhpcy50ZXh0TWFya3VwO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrdXAuZ2V0Q2xpZW50UG9zaXRpb24oKSxcbiAgICAgICAgICAgIHNpemUgPSBtYXJrdXAuZ2V0Q2xpZW50U2l6ZSgpO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ueCAtIHNpemUueCAqIDAuNTtcbiAgICAgICAgdmFyIHRvcCA9IHBvc2l0aW9uLnkgLSBzaXplLnkgKiAwLjU7XG5cbiAgICAgICAgdmFyIGxpbmVIZWlnaHRQZXJjZW50YWdlID0gbWFya3VwLmxpbmVIZWlnaHQgKyBcIiVcIjtcbiAgICAgICAgdGhpcy5zdHlsZVRleHRBcmVhLnNldEF0dHJpYnV0ZSgnbGluZS1oZWlnaHQnLCBsaW5lSGVpZ2h0UGVyY2VudGFnZSk7XG5cbiAgICAgICAgdGhpcy5zZXRQb3NBbmRTaXplKGxlZnQsIHRvcCwgc2l6ZS54LCBzaXplLnkpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKG1hcmt1cC5nZXRTdHlsZSgpKTtcbiAgICAgICAgdGhpcy50ZXh0QXJlYS52YWx1ZSA9IG1hcmt1cC5nZXRUZXh0KCk7XG4gICAgfTtcblxuICAgIHByb3RvLnNldFBvc0FuZFNpemUgPSBmdW5jdGlvbihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICAvLyBXZSBhbHNvIGNoZWNrIGhlcmUgdGhhdCBpdCBkb2Vzbid0IG92ZXJmbG93IG91dCBvZiB0aGUgY2FudmFzXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPj0gdGhpcy5lZGl0b3Iudmlld2VyLmNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMuZWRpdG9yLnZpZXdlci5jb250YWluZXIuY2xpZW50V2lkdGggLSAod2lkdGggKyAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+PSB0aGlzLmVkaXRvci52aWV3ZXIuY29udGFpbmVyLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdG9wID0gdGhpcy5lZGl0b3Iudmlld2VyLmNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSAoaGVpZ2h0ICsgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZVRleHRBcmVhXG4gICAgICAgICAgICAvLyBTaXplIGFuZCBwb3NpdGlvblxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgnbGVmdCcsIGxlZnQgKyAncHgnKVxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgndG9wJywgdG9wICsgJ3B4JylcbiAgICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGggKyAncHgnKVxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4Jyk7XG4gICAgfTtcblxuICAgIHByb3RvLnNldFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgICAgICAgIC8vIEFuIGFscmVhZHkgcHJlc2VudCBzdHlsZSBtZWFucyB0aGF0IHRoZSB1c2VyXG4gICAgICAgICAgICAvLyBoYXMgY2hhbmdlZCB0aGUgc3R5bGUgdXNpbmcgdGhlIFVJIGJ1dHRvbnMuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZSB1c2VyIGhhdmluZyBjaGFuZ2VkIHRoZVxuICAgICAgICAgICAgLy8gd2lkdGgvaGVpZ2h0IG9mIHRoZSBUZXh0QXJlYS4gU2luY2UgdGhlcmUgaXMgbm8gZXZlbnRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBkZXRlY3QgZm9yIGl0LCB3ZSBkbyBpdCBoZXJlLlxuICAgICAgICAgICAgdmFyIHRlbXAgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0U2l6ZVZhbHVlcyh0ZW1wKTtcbiAgICAgICAgICAgIHRoaXMuc2V0UG9zQW5kU2l6ZShcbiAgICAgICAgICAgICAgICB0ZW1wLm5ld1Bvcy54IC0gdGVtcC53aWR0aCAqIDAuNSxcbiAgICAgICAgICAgICAgICB0ZW1wLm5ld1Bvcy55IC0gdGVtcC5oZWlnaHQgKiAwLjUsXG4gICAgICAgICAgICAgICAgdGVtcC53aWR0aCwgdGVtcC5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250SGVpZ2h0ID0gdGhpcy5lZGl0b3Iuc2l6ZUZyb21NYXJrdXBzVG9DbGllbnQoMCwgc3R5bGVbJ2ZvbnQtc2l6ZSddKS55O1xuICAgICAgICB2YXIgdGV4dEFyZWFTdHlsZSA9IHRoaXMuc3R5bGVUZXh0QXJlYVxuICAgICAgICAgICAgLy8gVmlzdWFsc1xuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgnY29sb3InLCBzdHlsZVsnc3Ryb2tlLWNvbG9yJ10pXG4gICAgICAgICAgICAuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIHN0eWxlWydmb250LWZhbWlseSddKVxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgZm9udEhlaWdodCArICdweCcpXG4gICAgICAgICAgICAuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIHN0eWxlWydmb250LXdlaWdodCddID8gJ2JvbGQnIDogJycpXG4gICAgICAgICAgICAuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgc3R5bGVbJ2ZvbnQtc3R5bGUnXSA/ICdpdGFsaWMnIDogJycpXG4gICAgICAgICAgICAuZ2V0U3R5bGVTdHJpbmcoKTtcbiAgICAgICAgdGhpcy50ZXh0QXJlYS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGV4dEFyZWFTdHlsZSk7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBuYW1lc3BhY2VVdGlscy5jbG9uZVN0eWxlKHN0eWxlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQsIGZvciBhIGdpdmVuIG1hcmt1cCB3aXRoIHNvbWUgdGV4dCBpbiBpdFxuICAgICAqIHJldHVybnMgYW4gQXJyYXkgb2YgbGluZXMgaW4gaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcmt1cFxuICAgICAqIEByZXR1cm5zIHt7dGV4dCwgbGluZXN9fHt0ZXh0OiBTdHJpbmcsIGxpbmVzOiBBcnJheS48U3RyaW5nPn19XG4gICAgICovXG4gICAgcHJvdG8uZ2V0VGV4dFZhbHVlc0Zvck1hcmt1cCA9IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlKG1hcmt1cCwgZmFsc2UpO1xuICAgICAgICB2YXIgdGV4dFZhbHVlcyA9IHRoaXMuZ2V0VGV4dFZhbHVlcygpO1xuICAgICAgICB0aGlzLnNldEluYWN0aXZlKCk7XG4gICAgICAgIHJldHVybiB0ZXh0VmFsdWVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHQgYXMgb25lIHN0cmluZyBhbmQgYW4gYXJyYXkgb2YgbGluZXNcbiAgICAgKiBvZiBob3cgdGhlIHRleHQgaXMgYmVpbmcgcmVuZGVyZWQgKDEgc3RyaW5nIHBlciBsaW5lKVxuICAgICAqIEByZXR1cm5zIHt7dGV4dDogU3RyaW5nLCBsaW5lczogQXJyYXkuPFN0cmluZz59fVxuICAgICAqL1xuICAgIHByb3RvLmdldFRleHRWYWx1ZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbmV3VGV4dCA9IHRoaXMudGV4dEFyZWEudmFsdWU7XG4gICAgICAgIGlmIChuZXdUZXh0ID09PSBuYW1lc3BhY2VVdGlscy5Mb2NhbGl6YXRpb24uTUFSS1VQX1RFWFRfREVGQVVMVF9URVhUKSB7XG4gICAgICAgICAgICBuZXdUZXh0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IG5ld1RleHQsXG4gICAgICAgICAgICBsaW5lczogdGhpcy5nZW5lcmF0ZUxpbmVzKClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY2FsbGVkIGJ5IFVJXG4gICAgICovXG4gICAgcHJvdG8uYWNjZXB0QW5kRXhpdCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIElmIHBsYWNlaG9sZGVyIHRleHQsIHRoZW4gcmVtb3ZlLlxuICAgICAgICB2YXIgdGV4dFZhbHVlcyA9IHRoaXMuZ2V0VGV4dFZhbHVlcygpO1xuXG4gICAgICAgIHZhciBkYXRhQmFnID0ge1xuICAgICAgICAgICAgbWFya3VwOiB0aGlzLnRleHRNYXJrdXAsXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgICAgICAgIGZpcnN0RWRpdDogdGhpcy5maXJzdEVkaXQsXG4gICAgICAgICAgICBuZXdUZXh0OiB0ZXh0VmFsdWVzLnRleHQsXG4gICAgICAgICAgICBuZXdMaW5lczogdGV4dFZhbHVlcy5saW5lc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluamVjdFNpemVWYWx1ZXMoZGF0YUJhZyk7XG4gICAgICAgIHRoaXMuZmlyZUV2ZW50KHsgdHlwZTogdGhpcy5FVkVOVF9URVhUX0NIQU5HRSwgZGF0YTogZGF0YUJhZyB9KTtcbiAgICAgICAgdGhpcy5zZXRJbmFjdGl2ZSgpOyAvLyBEbyB0aGlzIGxhc3QgLy9cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdGV4dGFyZWEgcmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhQmFnXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5pbmplY3RTaXplVmFsdWVzID0gZnVuY3Rpb24oZGF0YUJhZykge1xuXG4gICAgICAgIC8vIEV4cGxpY2l0IHVzYWdlIG9mIHBhcnNlRmxvYXQgdG8gcmVtb3ZlIHRoZSAncHgnIHN1ZmZpeC5cbiAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLnRleHRBcmVhLnN0eWxlLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQodGhpcy50ZXh0QXJlYS5zdHlsZS5oZWlnaHQpO1xuICAgICAgICB2YXIgb3ggPSBwYXJzZUZsb2F0KHRoaXMudGV4dEFyZWEuc3R5bGUubGVmdCk7XG4gICAgICAgIHZhciBveSA9IHBhcnNlRmxvYXQodGhpcy50ZXh0QXJlYS5zdHlsZS50b3ApO1xuXG4gICAgICAgIGRhdGFCYWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgZGF0YUJhZy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGRhdGFCYWcubmV3UG9zID0ge1xuICAgICAgICAgICAgeDogb3ggKyAod2lkdGggKiAwLjUpLFxuICAgICAgICAgICAgeTogb3kgKyAoaGVpZ2h0ICogMC41KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciB3aGVuIHRoZSB3aW5kb3cgZ2V0cyByZXNpemVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gV2luZG93IHJlc2l6ZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8ub25XaW5kb3dSZXNpemUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgc3RyID0gdGhpcy50ZXh0QXJlYS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUgPSBudWxsOyAvLyBUT0RPOiBSZXZpc2l0IHRoaXMgY29kZSBiZWNhdXNlIHN0eWxlIGNoYW5nZXMgYXJlIGxvc3QgYnkgZG9pbmcgdGhpcy5cbiAgICAgICAgICAgIHRoaXMuaW5pdEZyb21NYXJrdXAoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dEFyZWEudmFsdWUgPSBzdHI7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfTtcblxuICAgIHByb3RvLm9uS2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgdmFyIHNoaWZ0RG93biA9IGV2ZW50LnNoaWZ0S2V5O1xuXG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgUkVUVVJOIHdoZW4gdXNlZCBhbG9uZyB3aXRoIFNISUZUXG4gICAgICAgIGlmICghc2hpZnREb3duICYmIGtleUNvZGUgPT09IDEzKSB7IC8vIFJldHVyblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuYWNjZXB0QW5kRXhpdCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdyYWJzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHRleHRhcmVhIGFuZCByZXR1cm5zXG4gICAgICogYW4gQXJyYXkgb2YgbGluZXMuICBXcmFwcGVkIGxpbmVzIGFyZSByZXR1cm5lZCBhcyAyIGxpbmVzLlxuICAgICAqL1xuICAgIHByb3RvLmdlbmVyYXRlTGluZXMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBGaXJzdCwgZ2V0IGxpbmVzIHNlcGFyYXRlZCBieSBsaW5lIGJyZWFrczpcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy50ZXh0QXJlYS52YWx1ZTtcbiAgICAgICAgdmFyIGxpbmVzQnJlYWtzID0gdGV4dENvbnRlbnQuc3BsaXQoL1xccipcXG4vKTtcblxuICAgICAgICB2YXIgc3R5bGVNZWFzdXJlU3RyID0gdGhpcy5zdHlsZVRleHRBcmVhLmNsb25lKClcbiAgICAgICAgICAgIC5yZW1vdmVBdHRyaWJ1dGUoWyd0b3AnLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnb3ZlcmZsb3cteSddKVxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCdhYnNvbHV0ZScpXG4gICAgICAgICAgICAuc2V0QXR0cmlidXRlKCd3aGl0ZS1zcGFjZScsJ25vd3JhcCcpXG4gICAgICAgICAgICAuc2V0QXR0cmlidXRlKCdmbG9hdCcsJ2xlZnQnKVxuICAgICAgICAgICAgLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpXG4gICAgICAgICAgICAuZ2V0U3R5bGVTdHJpbmcoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlRGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZU1lYXN1cmVTdHIpO1xuICAgICAgICB0aGlzLnBhcmVudERpdi5hcHBlbmRDaGlsZCh0aGlzLm1lYXN1cmVEaXYpO1xuXG4gICAgICAgIHZhciBtYXhMaW5lTGVuZ3RoID0gcGFyc2VGbG9hdCh0aGlzLnRleHRBcmVhLnN0eWxlLndpZHRoKTtcblxuICAgICAgICAvLyBOb3cgY2hlY2sgd2hldGhlciB0aGUgbGluZXMgYXJlIHdyYXBwZWQuXG4gICAgICAgIC8vIElmIHNvLCBzdWJkaXZpZGUgaW50byBvdGhlciBsaW5lcy5cbiAgICAgICAgdmFyIGxpbmVzT3V0cHV0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaT0gMCwgbGVuID0gbGluZXNCcmVha3MubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHRyaW1SaWdodChsaW5lc0JyZWFrc1tpXSk7XG4gICAgICAgICAgICB0aGlzLnNwbGl0TGluZShsaW5lLCBtYXhMaW5lTGVuZ3RoLCBsaW5lc091dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcmVudERpdi5yZW1vdmVDaGlsZCh0aGlzLm1lYXN1cmVEaXYpO1xuICAgICAgICByZXR1cm4gbGluZXNPdXRwdXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyBvbmUgbGluZSBvZiB0ZXh0IHRoYXQgaXNcbiAgICAgKiBsb25nZXIgdGhhbiB0aGUgbWF4IGxlbmd0aCBhIGxpbmUgaXMgYWxsb3dlZCwgdGhpcyBtZXRob2RcbiAgICAgKiBjdXRzIHRleHQgaW50byBzZXZlcmFsIG9uZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHRoYW4gdGhlIG1heFxuICAgICAqIGxlbmd0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heExlbmd0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uc3BsaXRMaW5lID0gZnVuY3Rpb24odGV4dCwgbWF4TGVuZ3RoLCBvdXRwdXQpIHtcblxuICAgICAgICAvLyBFbmQgY29uZGl0aW9uXG4gICAgICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9ICcnO1xuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlICghZG9uZSl7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVEaXYuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgICAgIHZhciBsaW5lTGVuID0gdGhpcy5tZWFzdXJlRGl2LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKGxpbmVMZW4gPD0gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGxpdExpbmUodHJpbUxlZnQocmVtYWluaW5nKSwgbWF4TGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHRyeSB3aXRoIGEgc2hvcnRlciB3b3JkIVxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuZ2V0U2hvcnRlckxpbmUodGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IGlzIG9ubHkgb25lIHdvcmQgdGhhdCBpcyB3YXkgdG9vIGxvbmcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRXb3JkKHRleHQsIHJlbWFpbmluZywgbWF4TGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHBhcnRzWzFdICsgcmVtYWluaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGxpbmUgb2YgdGV4dCBzdWNoIGFzIFwiaGkgdGhlcmUgcHJvZ3JhbW1lclwiLCBpdCByZXR1cm5zXG4gICAgICogYW4gYXJyYXkgd2l0aCAyIHBhcnRzOiBbXCJoaSB0aGVyZVwiLCBcIiBwcm9ncmFtbWVyXCJdLlxuICAgICAqXG4gICAgICogSXQgYWNjb3VudHMgZm9yIHNwZWNpYWwgY2FzZXMgd2l0aCBtdWx0aS1zcGFjZXMsIHN1Y2ggYXMgZm9yXG4gICAgICogXCJoaSB0aGVyZSAgdHdvLXNwYWNlc1wiIHJldHVybnMgW1wiaGkgdGhlcmVcIiwgXCIgIHR3by1zcGFjZXNcIl1cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgd29yZCwgaXQgcmV0dXJucyB0aGUgd2hvbGUgd29yZDpcbiAgICAgKiBcIkp1c3RPbmVXb3JkXCIgcmV0dXJucyBbXCJKdXN0T25lV29yZFwiXSAoYW4gYXJyYXkgb2YgMSBlbGVtZW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgcHJvdG8uZ2V0U2hvcnRlckxpbmUgPSBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICAgICAgLy8gVE9ETzogQWNjb3VudCBmb3IgVEFCc1xuICAgICAgICAvLyBXaWxsIHByb2JhYmx5IG5ldmVyIGRvIHVubGVzcyBhIGJ1ZyBpcyByZXBvcnRlZC5cblxuICAgICAgICB2YXIgaUxhc3RTcGFjZSA9IGxpbmUubGFzdEluZGV4T2YoJyAnKTtcbiAgICAgICAgaWYgKGlMYXN0U3BhY2UgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVdOyAvLyBUaGlzIGlzIGEgc2luZ2xlIHdvcmRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVsc2VcbiAgICAgICAgLy8gSXRlcmF0ZSBiYWNrIHJlbW92aW5nIGFkZGl0aW9uYWwgc3BhY2VzIChtdWx0aSBzcGFjZXMpXG4gICAgICAgIHdoaWxlIChsaW5lLmNoYXJBdChpTGFzdFNwYWNlLTEpID09PSAnICcpIHtcbiAgICAgICAgICAgIGlMYXN0U3BhY2UtLVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nV29yZCA9IGxpbmUuc3Vic3RyKGlMYXN0U3BhY2UpOyAvLyBDb250YWlucyB0aGUgc3BhY2VzXG4gICAgICAgIHZhciBzaG9ydGVyTGluZSA9IGxpbmUuc3Vic3RyKDAsaUxhc3RTcGFjZSk7XG4gICAgICAgIHJldHVybiBbc2hvcnRlckxpbmUsIHRyYWlsaW5nV29yZF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2luZ2xlIHdvcmQsIHNwbGl0cyBpdCBpbnRvIG11bHRpcGxlIGxpbmVzIHRoYXQgZml0cyBpbiBtYXhXaWR0aFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3b3JkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlbWFpbmluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMZW5ndGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXRwdXRcbiAgICAgKi9cbiAgICBwcm90by5zcGxpdFdvcmQgPSBmdW5jdGlvbih3b3JkLCByZW1haW5pbmcsIG1heExlbmd0aCwgb3V0cHV0KSB7XG5cbiAgICAgICAgdmFyIGxlblNvRmFyID0gMTtcbiAgICAgICAgdmFyIGZpdHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoZml0cykge1xuXG4gICAgICAgICAgICB2YXIgcGFydCA9IHdvcmQuc3Vic3RyKDAsbGVuU29GYXIpO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlRGl2LmlubmVySFRNTCA9IHBhcnQ7XG4gICAgICAgICAgICB2YXIgbGluZUxlbiA9IHRoaXMubWVhc3VyZURpdi5jbGllbnRXaWR0aDtcblxuICAgICAgICAgICAgaWYgKGxpbmVMZW4gPiBtYXhMZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIGlmIChsZW5Tb0ZhciA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBzcGxpdCAxIGNoYXJhY3RlciBhbnkgbG9uZ2VyLlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdFdvcmQod29yZC5zdWJzdHIoMSksIHJlbWFpbmluZywgbWF4TGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSXQgd2FzIGZpbmUgdW50aWwgb25lIGxlc3MgY2hhciAvL1xuICAgICAgICAgICAgICAgIHZhciBva2F5V29yZCA9IHdvcmQuc3Vic3RyKDAsbGVuU29GYXItMSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob2theVdvcmQpO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYVdvcmQgPSB3b3JkLnN1YnN0cihsZW5Tb0Zhci0xKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0TGluZShleHRyYVdvcmQgKyByZW1haW5pbmcsIG1heExlbmd0aCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyeSBvbmUgbW9yZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGxlblNvRmFyKys7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkb25lIHdpdGggYWxsIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmIChsZW5Tb0ZhciA+IHdvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gT2theSBpdCBmaXRzXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2god29yZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyaW1SaWdodCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3ROb25TcGFjZSA9IHRleHQubGVuZ3RoLTE7XG4gICAgICAgIGZvciAodmFyIGk9bGFzdE5vblNwYWNlOyBpPj0wOyAtLWkpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChpKSAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vblNwYWNlID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHIoMCwgbGFzdE5vblNwYWNlKzEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaW1MZWZ0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3ROb25TcGFjZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx0ZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGZpcnN0Tm9uU3BhY2UgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cihmaXJzdE5vblNwYWNlKTtcbiAgICB9XG5cbiAgICBuYW1lc3BhY2UuRWRpdG9yVGV4dElucHV0ID0gRWRpdG9yVGV4dElucHV0O1xuXG59KSgpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9WaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRC9NYXJrdXBzQ29yZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");
},146:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function($) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Markup2DPanel;\n\nvar _SwitchButton = __webpack_require__(30);\n\nvar _SwitchButton2 = _interopRequireDefault(_SwitchButton);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/////////////////////////////////////////////////////////////////\n// MarkupPanel\n//\n/////////////////////////////////////////////////////////////////\nfunction Markup2DPanel(viewer, panelId, btnElement) {\n\n  /////////////////////////////////////////////////////////////////\n  // Base class constructor\n  //\n  /////////////////////////////////////////////////////////////////\n  Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, panelId, 'Markup 2D', { shadow: true });\n\n  /////////////////////////////////////////////////////////////////\n  // \"Private\" members\n  //\n  /////////////////////////////////////////////////////////////////\n  var _thisPanel = this;\n\n  var _viewMode = true;\n\n  var _controlIds = [];\n\n  var _layerItems = {};\n\n  var MarkupsCore = null;\n\n  var _isVisible = false;\n\n  var _isMinimized = false;\n\n  var _markupsExtension = null;\n\n  /////////////////////////////////////////////////////////////\n  // Custom html\n  //\n  /////////////////////////////////////////////////////////////\n  function generateHtml(id) {\n\n    var html = '\\n\\n      <div class=\"container\">\\n\\n        <div class=\"switch-container\" id=\"' + id + '-switch-container\"\\n             data-placement=\"bottom\"\\n             data-toggle=\"tooltip\"\\n             title=\"Switch between Edit/View Mode\">\\n        </div>\\n\\n        <div id=\"' + id + '-dropdown-mode-container\"\\n             class=\"dropdown-mode-container\">\\n        </div>\\n\\n        <hr class=\"v-spacer\">\\n\\n        <div style=\"clear: left;\">\\n\\n          <input type=\"text\" id=\"' + id + '-spectrum\"/>\\n\\n          <input id=\"' + id + '-style\" type=\"text\"\\n              class=\"input styles\"\\n              value=\\'\"stroke-width\":0.1, \"stroke-opacity\":1\\'\\n              data-placement=\"bottom\"\\n              data-toggle=\"tooltip\"\\n              title=\"Set svg style properties\">\\n\\n        </div>\\n\\n        <hr class=\"v-spacer-large\">\\n\\n        <div style=\"clear: left;\">\\n\\n          <button class=\"btn btn-info btn-row\"\\n                  id=\"' + id + '-btn-undo\"\\n                  data-placement=\"bottom\"\\n                  data-toggle=\"tooltip\"\\n                  title=\"Undo last markup action\"\\n                  disabled>\\n           <span class=\"fa fa-undo btn-span\">\\n           </span>\\n              Undo\\n          </button>\\n\\n          <button class=\"btn btn-info btn-row\"\\n                  id=\"' + id + '-btn-redo\"\\n                  data-placement=\"bottom\"\\n                  data-toggle=\"tooltip\"\\n                  title=\"Redo last markup action\"\\n                  disabled>\\n           <span class=\"fa fa-repeat btn-span\">\\n           </span>\\n              Redo\\n          </button>\\n\\n          <button class=\"btn btn-info btn-row\"\\n                  id=\"' + id + '-btn-clear-all\"\\n                  data-placement=\"bottom\"\\n                  data-toggle=\"tooltip\"\\n                  title=\"Clear All current markups\"\\n                  disabled>\\n           <span class=\"glyphicon glyphicon-trash btn-span\">\\n           </span>\\n              Clear\\n          </button>\\n        </div>\\n\\n        <hr class=\"v-spacer-large\">\\n\\n        <div class=\"layer-container\">\\n\\n          <button class=\"btn btn-info\"\\n                  id=\"' + id + '-btn-save\"\\n                  data-placement=\"bottom\"\\n                  data-toggle=\"tooltip\"\\n                  title=\"Save current markups as layer\"\\n                  disabled>\\n            <span class=\"glyphicon glyphicon-floppy-open btn-span\"\\n                  aria-hidden=\"true\">\\n            </span>\\n            Save\\n          </button>\\n\\n          <input id=\"' + id + '-layer-name\" type=\"text\"\\n            class=\"input\"\\n            placeholder=\" Layer Name ...\">\\n\\n          <hr class=\"v-spacer-large\">\\n\\n          <div class=\"layer-list\" id=\"' + id + '-layer-list\">\\n\\n          </div>\\n\\n        </div>\\n\\n      </div>';\n\n    return html;\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function initialize() {\n\n    _thisPanel.content = document.createElement('div');\n\n    $(_thisPanel.container).addClass('markup');\n\n    $(_thisPanel.container).append(generateHtml(panelId));\n\n    //$('[data-toggle=\"tooltip\"]').tooltip();\n\n    var modes = [{\n      label: 'Arrow',\n      handler: function handler() {\n        setEditMode('arrow');\n      }\n    }, {\n      label: 'Circle',\n      handler: function handler() {\n        setEditMode('circle');\n      }\n    }, {\n      label: 'Cloud',\n      handler: function handler() {\n        setEditMode('cloud');\n      }\n    }, {\n      label: 'Free Hand',\n      handler: function handler() {\n        setEditMode('freehand');\n      }\n    }, {\n      label: 'Rectangle',\n      handler: function handler() {\n        setEditMode('rectangle');\n      }\n    }, {\n      label: 'Text',\n      handler: function handler() {\n        setEditMode('text');\n      }\n    }];\n\n    var dropdown = createDropdownMenu('#' + panelId + '-dropdown-mode-container', 'Markup Mode', modes);\n\n    $('#' + panelId + '-spectrum').spectrum({\n      color: '#FF0000',\n      change: function change(color) {\n\n        var clr = color.toHexString();\n      }\n    });\n\n    _controlIds = ['#' + dropdown.buttonId, '#' + panelId + '-btn-undo', '#' + panelId + '-btn-redo', '#' + panelId + '-btn-clear-all', '#' + panelId + '-btn-save'];\n\n    _thisPanel.switchMode = new _SwitchButton2.default('#' + panelId + '-switch-container', false);\n\n    _thisPanel.switchMode.on('checked', function (checked) {\n\n      checked ? enterEditMode() : enterViewMode();\n    });\n\n    $('#' + panelId + '-btn-undo').click(onUndo);\n    $('#' + panelId + '-btn-redo').click(onRedo);\n    $('#' + panelId + '-btn-clear-all').click(onClearMarkups);\n    $('#' + panelId + '-btn-save').click(onSaveLayer);\n\n    $('#' + panelId + '-style').focusout(setMarkupStyle);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////\n  // Creates dropdown menu from input\n  //\n  ///////////////////////////////////////////////////////////////////////////\n  function createDropdownMenu(parent, title, menuItems, selectedItemIdx) {\n\n    var buttonId = guid();\n\n    var labelId = guid();\n\n    var menuId = guid();\n\n    var listId = guid();\n\n    var html = '\\n        <div id=\"' + menuId + '\" class=\"dropdown chart-dropdown\">\\n          <button id=\"' + buttonId + '\"\\n                  class=\"btn btn-default btn-dropdown dropdown-toggle\"\\n                  type=\"button\"\\n                  data-toggle=\"dropdown\"\\n                  disabled>\\n          <label id=\"' + labelId + '\"\\n                 style=\"font: normal 14px Times New Roman; margin-top:-4px;\">\\n            ' + title + '\\n          </label>\\n          <span class=\"caret btn-span\"></span>\\n          </button>\\n          <ul id=\"' + listId + '\" class=\"dropdown-menu scrollable-menu\">\\n          </ul>\\n        </div>\\n      ';\n\n    $(parent).append(html);\n\n    $('#' + labelId).text(title + ': ' + menuItems[selectedItemIdx || 0].label);\n\n    menuItems.forEach(function (menuItem) {\n\n      var itemId = guid();\n\n      var itemHtml = '\\n          <li id=\"' + itemId + '\">\\n            <a href=\"\">' + menuItem.label + '</a>\\n          </li>';\n\n      $('#' + listId).append(itemHtml);\n\n      $('#' + itemId).click(function (event) {\n\n        event.preventDefault();\n\n        menuItem.handler();\n\n        $('#' + labelId).text(title + ': ' + menuItem.label);\n      });\n    });\n\n    return {\n      menuId: menuId,\n      buttonId: buttonId\n    };\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function enterEditMode() {\n\n    _viewMode = false;\n\n    _markupsExtension.hide();\n\n    _markupsExtension.enterEditMode();\n\n    _controlIds.forEach(function (id) {\n\n      $(id).prop('disabled', false);\n    });\n\n    $('#' + panelId + '-layer-list').removeClass('view-mode');\n\n    setMarkupStyle();\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function enterViewMode() {\n\n    _viewMode = true;\n\n    _markupsExtension.leaveEditMode();\n\n    _markupsExtension.show();\n\n    _controlIds.forEach(function (id) {\n\n      $(id).prop('disabled', true);\n    });\n\n    $('#' + panelId + '-layer-list').addClass('view-mode');\n\n    loadMarkups();\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function onUndo() {\n\n    _markupsExtension.undo();\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function onRedo() {\n\n    _markupsExtension.redo();\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function onClearMarkups() {\n\n    _markupsExtension.clear();\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function onSaveLayer() {\n\n    var $input = $('#' + panelId + '-layer-name');\n\n    var name = $input.val();\n\n    $input.val('');\n\n    name = name.length ? name : new Date().toString('d/M/yyyy H:mm:ss').split('GMT')[0];\n\n    var item = {\n      name: name,\n      id: guid(),\n      enabled: false,\n      markupData: _markupsExtension.generateData()\n    };\n\n    _layerItems[item.id] = item;\n\n    addLayerItem(item);\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function addLayerItem(item) {\n\n    var itemHtml = '\\n\\n        <div id=\"' + item.id + '\"\\n             class=\"list-group-item ' + (item.enabled ? 'enabled' : '') + '\">\\n\\n            ' + item.name + '\\n\\n            <button id=\"' + item.id + '-delete-btn\"\\n                    class=\"btn btn-danger btn-list\">\\n              <span class=\"glyphicon glyphicon-remove-sign btn-span-list\">\\n              </span>\\n            </button>\\n        </div>\\n      ';\n\n    $('#' + panelId + '-layer-list').append(itemHtml);\n\n    var $item = $('#' + item.id);\n\n    $item.click(function () {\n\n      if (_viewMode) {\n\n        $item.toggleClass('enabled');\n\n        if ($item.hasClass('enabled')) {\n\n          _markupsExtension.loadMarkups(item.markupData, item.id);\n\n          //_markupsExtension.showMarkups(item.id);\n        } else {\n\n          _markupsExtension.unloadMarkups(item.id);\n\n          //_markupsExtension.hideMarkups(item.id);\n        }\n      }\n    });\n\n    $('#' + item.id + '-delete-btn').click(function () {\n\n      _markupsExtension.unloadMarkups(item.id);\n\n      delete _layerItems[item.id];\n\n      $item.remove();\n    });\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function loadMarkups() {\n\n    $('.markup .list-group-item').each(function () {\n\n      var $item = $(this);\n\n      if ($item.hasClass('enabled')) {\n\n        var item = _layerItems[this.id];\n\n        _markupsExtension.loadMarkups(item.markupData, item.id);\n      }\n    });\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function setEditMode(mode) {\n\n    switch (mode) {\n\n      case 'arrow':\n\n        var mode = new MarkupsCore.EditModeArrow(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n\n      case 'circle':\n\n        var mode = new MarkupsCore.EditModeCircle(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n\n      case 'cloud':\n\n        var mode = new MarkupsCore.EditModeCloud(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n\n      case 'freehand':\n\n        var mode = new MarkupsCore.EditModeFreehand(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n\n      case 'rectangle':\n\n        var mode = new MarkupsCore.EditModeRectangle(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n\n      case 'text':\n\n        var mode = new MarkupsCore.EditModeText(_markupsExtension);\n        _markupsExtension.changeEditMode(mode);\n        break;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////\n  //\n  //\n  /////////////////////////////////////////////////////////////\n  function setMarkupStyle() {\n\n    if (!_viewMode) {\n\n      try {\n\n        var styleStr = '{' + $('#' + panelId + '-style').val() + '}';\n\n        var style = JSON.parse(styleStr);\n\n        var styleAttributes = ['stroke-width', 'stroke-color', 'stroke-opacity'];\n        var nsu = Autodesk.Viewing.Extensions.Markups.Core.Utils;\n        var styleObject = nsu.createStyle(styleAttributes, viewer);\n        console.log(JSON.stringify(styleObject));\n        console.log(style);\n\n        _markupsExtension.setStyle(style);\n      } catch (ex) {\n\n        console.log(ex);\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////\n  // unload extension\n  //\n  /////////////////////////////////////////////////////////////\n  _thisPanel.unload = function () {\n\n    _thisPanel.setVisible(false);\n\n    deactivateMarkups();\n  };\n\n  /////////////////////////////////////////////////////////////\n  // setVisible override\n  //\n  /////////////////////////////////////////////////////////////\n  _thisPanel.setVisible = function (show) {\n\n    _isVisible = show;\n\n    Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call(this, show);\n\n    if (show) {\n\n      btnElement.classList.add('active');\n\n      viewer.loadExtension(\"Autodesk.Viewing.MarkupsCore\");\n\n      _markupsExtension = viewer.getExtension(\"Autodesk.Viewing.MarkupsCore\");\n\n      MarkupsCore = Autodesk.Viewing.Extensions.Markups.Core;\n\n      enterViewMode();\n    } else {\n\n      btnElement.classList.remove('active');\n\n      viewer.unloadExtension(\"Autodesk.Viewing.MarkupsCore\");\n\n      _markupsExtension = null;\n    }\n  };\n\n  /////////////////////////////////////////////////////////////\n  // Toggles panel visibility\n  //\n  /////////////////////////////////////////////////////////////\n  _thisPanel.toggleVisibility = function () {\n\n    _thisPanel.setVisible(!_isVisible);\n  };\n\n  /////////////////////////////////////////////////////////////\n  // initialize override\n  //\n  /////////////////////////////////////////////////////////////\n  _thisPanel.initialize = function () {\n\n    this.title = this.createTitleBar(this.titleLabel || this.container.id);\n\n    this.closer = this.createCloseButton();\n\n    this.container.appendChild(this.title);\n    this.title.appendChild(this.closer);\n    this.container.appendChild(this.content);\n\n    this.initializeMoveHandlers(this.title);\n    this.initializeCloseHandler(this.closer);\n  };\n\n  /////////////////////////////////////////////////////////////\n  // onTitleDoubleClick override\n  //\n  /////////////////////////////////////////////////////////////\n  _thisPanel.onTitleDoubleClick = function (event) {\n\n    _isMinimized = !_isMinimized;\n\n    if (_isMinimized) {\n\n      $(_thisPanel.container).addClass('minimized');\n    } else {\n      $(_thisPanel.container).removeClass('minimized');\n    }\n  };\n\n  // Initializes the panel\n  initialize();\n}\n\n/////////////////////////////////////////////////////////////\n// Set up JS inheritance\n//\n/////////////////////////////////////////////////////////////\nMarkup2DPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);\n\nMarkup2DPanel.prototype.constructor = Markup2DPanel;\n\n///////////////////////////////////////////////////////////////////\n//\n//\n///////////////////////////////////////////////////////////////////\nfunction guid() {\n  var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'xxxxxxxxxx';\n\n\n  var d = new Date().getTime();\n\n  var guid = format.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : r & 0x7 | 0x8).toString(16);\n  });\n\n  return guid;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuUGFuZWwuanM/YWYyOSJdLCJuYW1lcyI6WyJNYXJrdXAyRFBhbmVsIiwidmlld2VyIiwicGFuZWxJZCIsImJ0bkVsZW1lbnQiLCJBdXRvZGVzayIsIlZpZXdpbmciLCJVSSIsIkRvY2tpbmdQYW5lbCIsImNhbGwiLCJjb250YWluZXIiLCJzaGFkb3ciLCJfdGhpc1BhbmVsIiwiX3ZpZXdNb2RlIiwiX2NvbnRyb2xJZHMiLCJfbGF5ZXJJdGVtcyIsIk1hcmt1cHNDb3JlIiwiX2lzVmlzaWJsZSIsIl9pc01pbmltaXplZCIsIl9tYXJrdXBzRXh0ZW5zaW9uIiwiZ2VuZXJhdGVIdG1sIiwiaWQiLCJodG1sIiwiaW5pdGlhbGl6ZSIsImNvbnRlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCIkIiwiYWRkQ2xhc3MiLCJhcHBlbmQiLCJtb2RlcyIsImxhYmVsIiwiaGFuZGxlciIsInNldEVkaXRNb2RlIiwiZHJvcGRvd24iLCJjcmVhdGVEcm9wZG93bk1lbnUiLCJzcGVjdHJ1bSIsImNvbG9yIiwiY2hhbmdlIiwiY2xyIiwidG9IZXhTdHJpbmciLCJidXR0b25JZCIsInN3aXRjaE1vZGUiLCJvbiIsImNoZWNrZWQiLCJlbnRlckVkaXRNb2RlIiwiZW50ZXJWaWV3TW9kZSIsImNsaWNrIiwib25VbmRvIiwib25SZWRvIiwib25DbGVhck1hcmt1cHMiLCJvblNhdmVMYXllciIsImZvY3Vzb3V0Iiwic2V0TWFya3VwU3R5bGUiLCJwYXJlbnQiLCJ0aXRsZSIsIm1lbnVJdGVtcyIsInNlbGVjdGVkSXRlbUlkeCIsImd1aWQiLCJsYWJlbElkIiwibWVudUlkIiwibGlzdElkIiwidGV4dCIsImZvckVhY2giLCJtZW51SXRlbSIsIml0ZW1JZCIsIml0ZW1IdG1sIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImhpZGUiLCJwcm9wIiwicmVtb3ZlQ2xhc3MiLCJsZWF2ZUVkaXRNb2RlIiwic2hvdyIsImxvYWRNYXJrdXBzIiwidW5kbyIsInJlZG8iLCJjbGVhciIsIiRpbnB1dCIsIm5hbWUiLCJ2YWwiLCJsZW5ndGgiLCJEYXRlIiwidG9TdHJpbmciLCJzcGxpdCIsIml0ZW0iLCJlbmFibGVkIiwibWFya3VwRGF0YSIsImdlbmVyYXRlRGF0YSIsImFkZExheWVySXRlbSIsIiRpdGVtIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsInVubG9hZE1hcmt1cHMiLCJyZW1vdmUiLCJlYWNoIiwibW9kZSIsIkVkaXRNb2RlQXJyb3ciLCJjaGFuZ2VFZGl0TW9kZSIsIkVkaXRNb2RlQ2lyY2xlIiwiRWRpdE1vZGVDbG91ZCIsIkVkaXRNb2RlRnJlZWhhbmQiLCJFZGl0TW9kZVJlY3RhbmdsZSIsIkVkaXRNb2RlVGV4dCIsInN0eWxlU3RyIiwic3R5bGUiLCJKU09OIiwicGFyc2UiLCJzdHlsZUF0dHJpYnV0ZXMiLCJuc3UiLCJFeHRlbnNpb25zIiwiTWFya3VwcyIsIkNvcmUiLCJVdGlscyIsInN0eWxlT2JqZWN0IiwiY3JlYXRlU3R5bGUiLCJjb25zb2xlIiwibG9nIiwic3RyaW5naWZ5Iiwic2V0U3R5bGUiLCJleCIsInVubG9hZCIsInNldFZpc2libGUiLCJkZWFjdGl2YXRlTWFya3VwcyIsInByb3RvdHlwZSIsImNsYXNzTGlzdCIsImFkZCIsImxvYWRFeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJ1bmxvYWRFeHRlbnNpb24iLCJ0b2dnbGVWaXNpYmlsaXR5IiwiY3JlYXRlVGl0bGVCYXIiLCJ0aXRsZUxhYmVsIiwiY2xvc2VyIiwiY3JlYXRlQ2xvc2VCdXR0b24iLCJhcHBlbmRDaGlsZCIsImluaXRpYWxpemVNb3ZlSGFuZGxlcnMiLCJpbml0aWFsaXplQ2xvc2VIYW5kbGVyIiwib25UaXRsZURvdWJsZUNsaWNrIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJmb3JtYXQiLCJkIiwiZ2V0VGltZSIsInJlcGxhY2UiLCJj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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3lELElBQVQsR0FBcUM7QUFBQSxNQUF2Qm9GLE1BQXVCLHVFQUFkLFlBQWM7OztBQUVuQyxNQUFJQyxJQUFJLElBQUk3RCxJQUFKLEdBQVc4RCxPQUFYLEVBQVI7O0FBRUEsTUFBSXRGLE9BQU9vRixPQUFPRyxPQUFQLENBQ1QsT0FEUyxFQUVULFVBQVVDLENBQVYsRUFBYTtBQUNYLFFBQUlDLElBQUksQ0FBQ0osSUFBSUssS0FBS0MsTUFBTCxLQUFnQixFQUFyQixJQUEyQixFQUEzQixHQUFnQyxDQUF4QztBQUNBTixRQUFJSyxLQUFLRSxLQUFMLENBQVdQLElBQUksRUFBZixDQUFKO0FBQ0EsV0FBTyxDQUFDRyxLQUFLLEdBQUwsR0FBV0MsQ0FBWCxHQUFnQkEsSUFBSSxHQUFKLEdBQVUsR0FBM0IsRUFBaUNoRSxRQUFqQyxDQUEwQyxFQUExQyxDQUFQO0FBQ0QsR0FOUSxDQUFYOztBQVFBLFNBQU96QixJQUFQO0FBQ0QsQyIsImZpbGUiOiIxNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3dpdGNoQnV0dG9uIGZyb20gJ1N3aXRjaEJ1dHRvbidcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1hcmt1cFBhbmVsXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1hcmt1cDJEUGFuZWwoXG4gIHZpZXdlcixcbiAgcGFuZWxJZCxcbiAgYnRuRWxlbWVudCkge1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEJhc2UgY2xhc3MgY29uc3RydWN0b3JcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgQXV0b2Rlc2suVmlld2luZy5VSS5Eb2NraW5nUGFuZWwuY2FsbChcbiAgICB0aGlzLFxuICAgIHZpZXdlci5jb250YWluZXIsXG4gICAgcGFuZWxJZCxcbiAgICAnTWFya3VwIDJEJyxcbiAgICB7c2hhZG93OiB0cnVlfSk7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gXCJQcml2YXRlXCIgbWVtYmVyc1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICB2YXIgX3RoaXNQYW5lbCA9IHRoaXM7XG5cbiAgdmFyIF92aWV3TW9kZSA9IHRydWU7XG5cbiAgdmFyIF9jb250cm9sSWRzID0gW107XG5cbiAgdmFyIF9sYXllckl0ZW1zID0ge307XG5cbiAgdmFyIE1hcmt1cHNDb3JlID0gbnVsbDtcblxuICB2YXIgX2lzVmlzaWJsZSA9IGZhbHNlO1xuXG4gIHZhciBfaXNNaW5pbWl6ZWQgPSBmYWxzZTtcblxuICB2YXIgX21hcmt1cHNFeHRlbnNpb24gPSBudWxsO1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gQ3VzdG9tIGh0bWxcbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmdW5jdGlvbiBnZW5lcmF0ZUh0bWwoaWQpIHtcblxuICAgIHZhciBodG1sID0gYFxuXG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN3aXRjaC1jb250YWluZXJcIiBpZD1cIiR7aWR9LXN3aXRjaC1jb250YWluZXJcIlxuICAgICAgICAgICAgIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIlxuICAgICAgICAgICAgIHRpdGxlPVwiU3dpdGNoIGJldHdlZW4gRWRpdC9WaWV3IE1vZGVcIj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBpZD1cIiR7aWR9LWRyb3Bkb3duLW1vZGUtY29udGFpbmVyXCJcbiAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1vZGUtY29udGFpbmVyXCI+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxociBjbGFzcz1cInYtc3BhY2VyXCI+XG5cbiAgICAgICAgPGRpdiBzdHlsZT1cImNsZWFyOiBsZWZ0O1wiPlxuXG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCIke2lkfS1zcGVjdHJ1bVwiLz5cblxuICAgICAgICAgIDxpbnB1dCBpZD1cIiR7aWR9LXN0eWxlXCIgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICBjbGFzcz1cImlucHV0IHN0eWxlc1wiXG4gICAgICAgICAgICAgIHZhbHVlPSdcInN0cm9rZS13aWR0aFwiOjAuMSwgXCJzdHJva2Utb3BhY2l0eVwiOjEnXG4gICAgICAgICAgICAgIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgZGF0YS10b2dnbGU9XCJ0b29sdGlwXCJcbiAgICAgICAgICAgICAgdGl0bGU9XCJTZXQgc3ZnIHN0eWxlIHByb3BlcnRpZXNcIj5cblxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8aHIgY2xhc3M9XCJ2LXNwYWNlci1sYXJnZVwiPlxuXG4gICAgICAgIDxkaXYgc3R5bGU9XCJjbGVhcjogbGVmdDtcIj5cblxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLWluZm8gYnRuLXJvd1wiXG4gICAgICAgICAgICAgICAgICBpZD1cIiR7aWR9LWJ0bi11bmRvXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIlVuZG8gbGFzdCBtYXJrdXAgYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPlxuICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhIGZhLXVuZG8gYnRuLXNwYW5cIj5cbiAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICBVbmRvXG4gICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1pbmZvIGJ0bi1yb3dcIlxuICAgICAgICAgICAgICAgICAgaWQ9XCIke2lkfS1idG4tcmVkb1wiXG4gICAgICAgICAgICAgICAgICBkYXRhLXBsYWNlbWVudD1cImJvdHRvbVwiXG4gICAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIlxuICAgICAgICAgICAgICAgICAgdGl0bGU9XCJSZWRvIGxhc3QgbWFya3VwIGFjdGlvblwiXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlZD5cbiAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYSBmYS1yZXBlYXQgYnRuLXNwYW5cIj5cbiAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICBSZWRvXG4gICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1pbmZvIGJ0bi1yb3dcIlxuICAgICAgICAgICAgICAgICAgaWQ9XCIke2lkfS1idG4tY2xlYXItYWxsXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIkNsZWFyIEFsbCBjdXJyZW50IG1hcmt1cHNcIlxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ+XG4gICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ2x5cGhpY29uIGdseXBoaWNvbi10cmFzaCBidG4tc3BhblwiPlxuICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIENsZWFyXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxociBjbGFzcz1cInYtc3BhY2VyLWxhcmdlXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImxheWVyLWNvbnRhaW5lclwiPlxuXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4taW5mb1wiXG4gICAgICAgICAgICAgICAgICBpZD1cIiR7aWR9LWJ0bi1zYXZlXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtcGxhY2VtZW50PVwiYm90dG9tXCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIlNhdmUgY3VycmVudCBtYXJrdXBzIGFzIGxheWVyXCJcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLWZsb3BweS1vcGVuIGJ0bi1zcGFuXCJcbiAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgU2F2ZVxuICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgPGlucHV0IGlkPVwiJHtpZH0tbGF5ZXItbmFtZVwiIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaW5wdXRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCIgTGF5ZXIgTmFtZSAuLi5cIj5cblxuICAgICAgICAgIDxociBjbGFzcz1cInYtc3BhY2VyLWxhcmdlXCI+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGF5ZXItbGlzdFwiIGlkPVwiJHtpZH0tbGF5ZXItbGlzdFwiPlxuXG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgIDwvZGl2PmA7XG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuXG4gICAgX3RoaXNQYW5lbC5jb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAkKF90aGlzUGFuZWwuY29udGFpbmVyKS5hZGRDbGFzcygnbWFya3VwJyk7XG5cbiAgICAkKF90aGlzUGFuZWwuY29udGFpbmVyKS5hcHBlbmQoZ2VuZXJhdGVIdG1sKHBhbmVsSWQpKTtcblxuICAgIC8vJCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLnRvb2x0aXAoKTtcblxuICAgIHZhciBtb2RlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgbGFiZWw6ICdBcnJvdycsXG4gICAgICAgIGhhbmRsZXI6ICgpPT57XG4gICAgICAgICAgc2V0RWRpdE1vZGUoJ2Fycm93Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiAnQ2lyY2xlJyxcbiAgICAgICAgaGFuZGxlcjogKCk9PntcbiAgICAgICAgICBzZXRFZGl0TW9kZSgnY2lyY2xlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiAnQ2xvdWQnLFxuICAgICAgICBoYW5kbGVyOiAoKT0+e1xuICAgICAgICAgIHNldEVkaXRNb2RlKCdjbG91ZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBsYWJlbDogJ0ZyZWUgSGFuZCcsXG4gICAgICAgIGhhbmRsZXI6ICgpPT57XG4gICAgICAgICAgc2V0RWRpdE1vZGUoJ2ZyZWVoYW5kJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiAnUmVjdGFuZ2xlJyxcbiAgICAgICAgaGFuZGxlcjogKCk9PntcbiAgICAgICAgICBzZXRFZGl0TW9kZSgncmVjdGFuZ2xlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGxhYmVsOiAnVGV4dCcsXG4gICAgICAgIGhhbmRsZXI6ICgpPT57XG4gICAgICAgICAgc2V0RWRpdE1vZGUoJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG5cbiAgICB2YXIgZHJvcGRvd24gPSBjcmVhdGVEcm9wZG93bk1lbnUoXG4gICAgICBgIyR7cGFuZWxJZH0tZHJvcGRvd24tbW9kZS1jb250YWluZXJgLFxuICAgICAgJ01hcmt1cCBNb2RlJyxcbiAgICAgIG1vZGVzKTtcblxuICAgICQoYCMke3BhbmVsSWR9LXNwZWN0cnVtYCkuc3BlY3RydW0oe1xuICAgICAgY29sb3I6ICcjRkYwMDAwJyxcbiAgICAgIGNoYW5nZTogZnVuY3Rpb24gKGNvbG9yKSB7XG5cbiAgICAgICAgdmFyIGNsciA9IGNvbG9yLnRvSGV4U3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBfY29udHJvbElkcyA9IFtcbiAgICAgIGAjJHtkcm9wZG93bi5idXR0b25JZH1gLFxuICAgICAgYCMke3BhbmVsSWR9LWJ0bi11bmRvYCxcbiAgICAgIGAjJHtwYW5lbElkfS1idG4tcmVkb2AsXG4gICAgICBgIyR7cGFuZWxJZH0tYnRuLWNsZWFyLWFsbGAsXG4gICAgICBgIyR7cGFuZWxJZH0tYnRuLXNhdmVgXG4gICAgXTtcblxuICAgIF90aGlzUGFuZWwuc3dpdGNoTW9kZSA9IG5ldyBTd2l0Y2hCdXR0b24oXG4gICAgICBgIyR7cGFuZWxJZH0tc3dpdGNoLWNvbnRhaW5lcmAsIGZhbHNlKVxuXG4gICAgX3RoaXNQYW5lbC5zd2l0Y2hNb2RlLm9uKCdjaGVja2VkJywgKGNoZWNrZWQpID0+IHtcblxuICAgICAgY2hlY2tlZCA/IGVudGVyRWRpdE1vZGUoKSA6IGVudGVyVmlld01vZGUoKVxuICAgIH0pXG5cbiAgICAkKGAjJHtwYW5lbElkfS1idG4tdW5kb2ApLmNsaWNrKG9uVW5kbyk7XG4gICAgJChgIyR7cGFuZWxJZH0tYnRuLXJlZG9gKS5jbGljayhvblJlZG8pO1xuICAgICQoYCMke3BhbmVsSWR9LWJ0bi1jbGVhci1hbGxgKS5jbGljayhvbkNsZWFyTWFya3Vwcyk7XG4gICAgJChgIyR7cGFuZWxJZH0tYnRuLXNhdmVgKS5jbGljayhvblNhdmVMYXllcik7XG5cbiAgICAkKGAjJHtwYW5lbElkfS1zdHlsZWApLmZvY3Vzb3V0KHNldE1hcmt1cFN0eWxlKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBDcmVhdGVzIGRyb3Bkb3duIG1lbnUgZnJvbSBpbnB1dFxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gY3JlYXRlRHJvcGRvd25NZW51KHBhcmVudCwgdGl0bGUsIG1lbnVJdGVtcywgc2VsZWN0ZWRJdGVtSWR4KSB7XG5cbiAgICB2YXIgYnV0dG9uSWQgPSBndWlkKCk7XG5cbiAgICB2YXIgbGFiZWxJZCA9IGd1aWQoKTtcblxuICAgIHZhciBtZW51SWQgPSBndWlkKCk7XG5cbiAgICB2YXIgbGlzdElkID0gZ3VpZCgpO1xuXG4gICAgdmFyIGh0bWwgPSBgXG4gICAgICAgIDxkaXYgaWQ9XCIke21lbnVJZH1cIiBjbGFzcz1cImRyb3Bkb3duIGNoYXJ0LWRyb3Bkb3duXCI+XG4gICAgICAgICAgPGJ1dHRvbiBpZD1cIiR7YnV0dG9uSWR9XCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1kcm9wZG93biBkcm9wZG93bi10b2dnbGVcIlxuICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCJcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkPlxuICAgICAgICAgIDxsYWJlbCBpZD1cIiR7bGFiZWxJZH1cIlxuICAgICAgICAgICAgICAgICBzdHlsZT1cImZvbnQ6IG5vcm1hbCAxNHB4IFRpbWVzIE5ldyBSb21hbjsgbWFyZ2luLXRvcDotNHB4O1wiPlxuICAgICAgICAgICAgJHt0aXRsZX1cbiAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2FyZXQgYnRuLXNwYW5cIj48L3NwYW4+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPHVsIGlkPVwiJHtsaXN0SWR9XCIgY2xhc3M9XCJkcm9wZG93bi1tZW51IHNjcm9sbGFibGUtbWVudVwiPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYDtcblxuICAgICQocGFyZW50KS5hcHBlbmQoaHRtbCk7XG5cbiAgICAkKCcjJyArIGxhYmVsSWQpLnRleHQoXG4gICAgICB0aXRsZSArICc6ICcgKyBtZW51SXRlbXNbc2VsZWN0ZWRJdGVtSWR4IHx8IDBdLmxhYmVsKTtcblxuICAgIG1lbnVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKG1lbnVJdGVtKXtcblxuICAgICAgdmFyIGl0ZW1JZCA9IGd1aWQoKTtcblxuICAgICAgdmFyIGl0ZW1IdG1sID0gYFxuICAgICAgICAgIDxsaSBpZD1cIiR7aXRlbUlkfVwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cIlwiPiR7bWVudUl0ZW0ubGFiZWx9PC9hPlxuICAgICAgICAgIDwvbGk+YDtcblxuICAgICAgJCgnIycgKyBsaXN0SWQpLmFwcGVuZChpdGVtSHRtbCk7XG5cbiAgICAgICQoJyMnICsgaXRlbUlkKS5jbGljayhmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbWVudUl0ZW0uaGFuZGxlcigpO1xuXG4gICAgICAgICQoJyMnICsgbGFiZWxJZCkudGV4dChcbiAgICAgICAgICB0aXRsZSArICc6ICcgKyBtZW51SXRlbS5sYWJlbCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBtZW51SWQ6IG1lbnVJZCxcbiAgICAgIGJ1dHRvbklkOiBidXR0b25JZFxuICAgIH07XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gZW50ZXJFZGl0TW9kZSgpIHtcblxuICAgIF92aWV3TW9kZSA9IGZhbHNlO1xuXG4gICAgX21hcmt1cHNFeHRlbnNpb24uaGlkZSgpO1xuXG4gICAgX21hcmt1cHNFeHRlbnNpb24uZW50ZXJFZGl0TW9kZSgpO1xuXG4gICAgX2NvbnRyb2xJZHMuZm9yRWFjaCgoaWQpPT4ge1xuXG4gICAgICAkKGlkKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgICQoYCMke3BhbmVsSWR9LWxheWVyLWxpc3RgKS5yZW1vdmVDbGFzcyhcbiAgICAgICd2aWV3LW1vZGUnKTtcblxuICAgIHNldE1hcmt1cFN0eWxlKCk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gZW50ZXJWaWV3TW9kZSgpIHtcblxuICAgIF92aWV3TW9kZSA9IHRydWU7XG5cbiAgICBfbWFya3Vwc0V4dGVuc2lvbi5sZWF2ZUVkaXRNb2RlKCk7XG5cbiAgICBfbWFya3Vwc0V4dGVuc2lvbi5zaG93KCk7XG5cbiAgICBfY29udHJvbElkcy5mb3JFYWNoKChpZCk9PiB7XG5cbiAgICAgICQoaWQpLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICAkKGAjJHtwYW5lbElkfS1sYXllci1saXN0YCkuYWRkQ2xhc3MoXG4gICAgICAndmlldy1tb2RlJyk7XG5cbiAgICBsb2FkTWFya3VwcygpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGZ1bmN0aW9uIG9uVW5kbygpIHtcblxuICAgIF9tYXJrdXBzRXh0ZW5zaW9uLnVuZG8oKTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmdW5jdGlvbiBvblJlZG8oKSB7XG5cbiAgICBfbWFya3Vwc0V4dGVuc2lvbi5yZWRvKCk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gb25DbGVhck1hcmt1cHMoKSB7XG5cbiAgICBfbWFya3Vwc0V4dGVuc2lvbi5jbGVhcigpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGZ1bmN0aW9uIG9uU2F2ZUxheWVyKCkge1xuXG4gICAgdmFyICRpbnB1dCA9ICQoYCMke3BhbmVsSWR9LWxheWVyLW5hbWVgKTtcblxuICAgIHZhciBuYW1lID0gJGlucHV0LnZhbCgpO1xuXG4gICAgJGlucHV0LnZhbCgnJyk7XG5cbiAgICBuYW1lID0gKG5hbWUubGVuZ3RoID9cbiAgICAgIG5hbWUgOlxuICAgICAgKG5ldyBEYXRlKCkudG9TdHJpbmcoJ2QvTS95eXl5IEg6bW06c3MnKSkuc3BsaXQoJ0dNVCcpWzBdKTtcblxuICAgIHZhciBpdGVtID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGlkOiBndWlkKCksXG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIG1hcmt1cERhdGE6IF9tYXJrdXBzRXh0ZW5zaW9uLmdlbmVyYXRlRGF0YSgpXG4gICAgfVxuXG4gICAgX2xheWVySXRlbXNbaXRlbS5pZF0gPSBpdGVtO1xuXG4gICAgYWRkTGF5ZXJJdGVtKGl0ZW0pO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvL1xuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGZ1bmN0aW9uIGFkZExheWVySXRlbShpdGVtKSB7XG5cbiAgICB2YXIgaXRlbUh0bWwgPSBgXG5cbiAgICAgICAgPGRpdiBpZD1cIiR7aXRlbS5pZH1cIlxuICAgICAgICAgICAgIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtICR7aXRlbS5lbmFibGVkID8gJ2VuYWJsZWQnIDogJyd9XCI+XG5cbiAgICAgICAgICAgICR7aXRlbS5uYW1lfVxuXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVwiJHtpdGVtLmlkfS1kZWxldGUtYnRuXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLWRhbmdlciBidG4tbGlzdFwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlLXNpZ24gYnRuLXNwYW4tbGlzdFwiPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICBgO1xuXG4gICAgJChgIyR7cGFuZWxJZH0tbGF5ZXItbGlzdGApLmFwcGVuZChpdGVtSHRtbCk7XG5cbiAgICB2YXIgJGl0ZW0gPSAkKGAjJHtpdGVtLmlkfWApO1xuXG4gICAgJGl0ZW0uY2xpY2soKCk9PntcblxuICAgICAgaWYoX3ZpZXdNb2RlKSB7XG5cbiAgICAgICAgJGl0ZW0udG9nZ2xlQ2xhc3MoJ2VuYWJsZWQnKTtcblxuICAgICAgICBpZiAoJGl0ZW0uaGFzQ2xhc3MoJ2VuYWJsZWQnKSkge1xuXG4gICAgICAgICAgX21hcmt1cHNFeHRlbnNpb24ubG9hZE1hcmt1cHMoXG4gICAgICAgICAgICBpdGVtLm1hcmt1cERhdGEsXG4gICAgICAgICAgICBpdGVtLmlkKTtcblxuICAgICAgICAgIC8vX21hcmt1cHNFeHRlbnNpb24uc2hvd01hcmt1cHMoaXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICBfbWFya3Vwc0V4dGVuc2lvbi51bmxvYWRNYXJrdXBzKGl0ZW0uaWQpO1xuXG4gICAgICAgICAgLy9fbWFya3Vwc0V4dGVuc2lvbi5oaWRlTWFya3VwcyhpdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJChgIyR7aXRlbS5pZH0tZGVsZXRlLWJ0bmApLmNsaWNrKCgpPT57XG5cbiAgICAgIF9tYXJrdXBzRXh0ZW5zaW9uLnVubG9hZE1hcmt1cHMoaXRlbS5pZCk7XG5cbiAgICAgIGRlbGV0ZSBfbGF5ZXJJdGVtc1tpdGVtLmlkXTtcblxuICAgICAgJGl0ZW0ucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gbG9hZE1hcmt1cHMoKSB7XG5cbiAgICAkKCcubWFya3VwIC5saXN0LWdyb3VwLWl0ZW0nKS5lYWNoKGZ1bmN0aW9uKCl7XG5cbiAgICAgIHZhciAkaXRlbSA9ICQodGhpcyk7XG5cbiAgICAgIGlmKCRpdGVtLmhhc0NsYXNzKCdlbmFibGVkJykpIHtcblxuICAgICAgICB2YXIgaXRlbSA9IF9sYXllckl0ZW1zW3RoaXMuaWRdO1xuXG4gICAgICAgIF9tYXJrdXBzRXh0ZW5zaW9uLmxvYWRNYXJrdXBzKFxuICAgICAgICAgIGl0ZW0ubWFya3VwRGF0YSxcbiAgICAgICAgICBpdGVtLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy9cbiAgLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBmdW5jdGlvbiBzZXRFZGl0TW9kZShtb2RlKSB7XG5cbiAgICBzd2l0Y2gobW9kZSl7XG5cbiAgICAgIGNhc2UgJ2Fycm93JzpcblxuICAgICAgICB2YXIgbW9kZSA9IG5ldyBNYXJrdXBzQ29yZS5FZGl0TW9kZUFycm93KF9tYXJrdXBzRXh0ZW5zaW9uKTtcbiAgICAgICAgX21hcmt1cHNFeHRlbnNpb24uY2hhbmdlRWRpdE1vZGUobW9kZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjaXJjbGUnOlxuXG4gICAgICAgIHZhciBtb2RlID0gbmV3IE1hcmt1cHNDb3JlLkVkaXRNb2RlQ2lyY2xlKF9tYXJrdXBzRXh0ZW5zaW9uKTtcbiAgICAgICAgX21hcmt1cHNFeHRlbnNpb24uY2hhbmdlRWRpdE1vZGUobW9kZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjbG91ZCc6XG5cbiAgICAgICAgdmFyIG1vZGUgPSBuZXcgTWFya3Vwc0NvcmUuRWRpdE1vZGVDbG91ZChfbWFya3Vwc0V4dGVuc2lvbik7XG4gICAgICAgIF9tYXJrdXBzRXh0ZW5zaW9uLmNoYW5nZUVkaXRNb2RlKG1vZGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZnJlZWhhbmQnOlxuXG4gICAgICAgIHZhciBtb2RlID0gbmV3IE1hcmt1cHNDb3JlLkVkaXRNb2RlRnJlZWhhbmQoX21hcmt1cHNFeHRlbnNpb24pO1xuICAgICAgICBfbWFya3Vwc0V4dGVuc2lvbi5jaGFuZ2VFZGl0TW9kZShtb2RlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JlY3RhbmdsZSc6XG5cbiAgICAgICAgdmFyIG1vZGUgPSBuZXcgTWFya3Vwc0NvcmUuRWRpdE1vZGVSZWN0YW5nbGUoX21hcmt1cHNFeHRlbnNpb24pO1xuICAgICAgICBfbWFya3Vwc0V4dGVuc2lvbi5jaGFuZ2VFZGl0TW9kZShtb2RlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RleHQnOlxuXG4gICAgICAgIHZhciBtb2RlID0gbmV3IE1hcmt1cHNDb3JlLkVkaXRNb2RlVGV4dChfbWFya3Vwc0V4dGVuc2lvbik7XG4gICAgICAgIF9tYXJrdXBzRXh0ZW5zaW9uLmNoYW5nZUVkaXRNb2RlKG1vZGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZnVuY3Rpb24gc2V0TWFya3VwU3R5bGUoKSB7XG5cbiAgICBpZighX3ZpZXdNb2RlKSB7XG5cbiAgICAgIHRyeSB7XG5cbiAgICAgICAgdmFyIHN0eWxlU3RyID0gJ3snICsgJChgIyR7cGFuZWxJZH0tc3R5bGVgKS52YWwoKSArICd9JztcblxuICAgICAgICB2YXIgc3R5bGUgPSBKU09OLnBhcnNlKHN0eWxlU3RyKTtcblxuICAgICAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gWydzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLWNvbG9yJywgJ3N0cm9rZS1vcGFjaXR5J107XG4gICAgICAgIHZhciBuc3UgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlLlV0aWxzO1xuICAgICAgICB2YXIgc3R5bGVPYmplY3QgPSBuc3UuY3JlYXRlU3R5bGUoc3R5bGVBdHRyaWJ1dGVzLCB2aWV3ZXIpO1xuICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShzdHlsZU9iamVjdCkpXG4gICAgICAgIGNvbnNvbGUubG9nKHN0eWxlKVxuXG4gICAgICAgIF9tYXJrdXBzRXh0ZW5zaW9uLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoKGV4KXtcblxuICAgICAgICBjb25zb2xlLmxvZyhleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyB1bmxvYWQgZXh0ZW5zaW9uXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgX3RoaXNQYW5lbC51bmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgIF90aGlzUGFuZWwuc2V0VmlzaWJsZShmYWxzZSk7XG5cbiAgICBkZWFjdGl2YXRlTWFya3VwcygpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBzZXRWaXNpYmxlIG92ZXJyaWRlXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgX3RoaXNQYW5lbC5zZXRWaXNpYmxlID0gZnVuY3Rpb24oc2hvdykge1xuXG4gICAgX2lzVmlzaWJsZSA9IHNob3c7XG5cbiAgICBBdXRvZGVzay5WaWV3aW5nLlVJLkRvY2tpbmdQYW5lbC5wcm90b3R5cGUuXG4gICAgICBzZXRWaXNpYmxlLmNhbGwodGhpcywgc2hvdyk7XG5cbiAgICBpZihzaG93KXtcblxuICAgICAgYnRuRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgICAgdmlld2VyLmxvYWRFeHRlbnNpb24oXCJBdXRvZGVzay5WaWV3aW5nLk1hcmt1cHNDb3JlXCIpO1xuXG4gICAgICBfbWFya3Vwc0V4dGVuc2lvbiA9IHZpZXdlci5nZXRFeHRlbnNpb24oXG4gICAgICAgIFwiQXV0b2Rlc2suVmlld2luZy5NYXJrdXBzQ29yZVwiKTtcblxuICAgICAgTWFya3Vwc0NvcmUgPSBBdXRvZGVzay5WaWV3aW5nLkV4dGVuc2lvbnMuTWFya3Vwcy5Db3JlO1xuXG4gICAgICBlbnRlclZpZXdNb2RlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICBidG5FbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuXG4gICAgICB2aWV3ZXIudW5sb2FkRXh0ZW5zaW9uKFwiQXV0b2Rlc2suVmlld2luZy5NYXJrdXBzQ29yZVwiKTtcblxuICAgICAgX21hcmt1cHNFeHRlbnNpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gVG9nZ2xlcyBwYW5lbCB2aXNpYmlsaXR5XG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgX3RoaXNQYW5lbC50b2dnbGVWaXNpYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBfdGhpc1BhbmVsLnNldFZpc2libGUoIV9pc1Zpc2libGUpO1xuICB9XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBpbml0aWFsaXplIG92ZXJyaWRlXG4gIC8vXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgX3RoaXNQYW5lbC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLnRpdGxlID0gdGhpcy5jcmVhdGVUaXRsZUJhcihcbiAgICAgIHRoaXMudGl0bGVMYWJlbCB8fFxuICAgICAgdGhpcy5jb250YWluZXIuaWQpO1xuXG4gICAgdGhpcy5jbG9zZXIgPSB0aGlzLmNyZWF0ZUNsb3NlQnV0dG9uKCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlKTtcbiAgICB0aGlzLnRpdGxlLmFwcGVuZENoaWxkKHRoaXMuY2xvc2VyKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplTW92ZUhhbmRsZXJzKHRoaXMudGl0bGUpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNsb3NlSGFuZGxlcih0aGlzLmNsb3Nlcik7XG4gIH1cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIG9uVGl0bGVEb3VibGVDbGljayBvdmVycmlkZVxuICAvL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIF90aGlzUGFuZWwub25UaXRsZURvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICBfaXNNaW5pbWl6ZWQgPSAhX2lzTWluaW1pemVkO1xuXG4gICAgaWYoX2lzTWluaW1pemVkKSB7XG5cbiAgICAgICQoX3RoaXNQYW5lbC5jb250YWluZXIpLmFkZENsYXNzKFxuICAgICAgICAnbWluaW1pemVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJChfdGhpc1BhbmVsLmNvbnRhaW5lcikucmVtb3ZlQ2xhc3MoXG4gICAgICAgICdtaW5pbWl6ZWQnKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyB0aGUgcGFuZWxcbiAgaW5pdGlhbGl6ZSgpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTZXQgdXAgSlMgaW5oZXJpdGFuY2Vcbi8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5NYXJrdXAyRFBhbmVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG4gIEF1dG9kZXNrLlZpZXdpbmcuVUkuRG9ja2luZ1BhbmVsLnByb3RvdHlwZSlcblxuTWFya3VwMkRQYW5lbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXJrdXAyRFBhbmVsXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ3VpZChmb3JtYXQgPSAneHh4eHh4eHh4eCcpIHtcblxuICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIHZhciBndWlkID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgL1t4eV0vZyxcbiAgICBmdW5jdGlvbiAoYykge1xuICAgICAgdmFyIHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4NyB8IDB4OCkpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcblxuICByZXR1cm4gZ3VpZDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuUGFuZWwuanMiXSwic291cmNlUm9vdCI6IiJ9");
},147:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(jQuery) {"use strict";\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\n// Spectrum Colorpicker v1.5.1\n// https://github.com/bgrins/spectrum\n// Author: Brian Grinstead\n// License: MIT\n\n(function (window, $, undefined) {\n    "use strict";\n\n    var defaultOpts = {\n\n        // Callbacks\n        beforeShow: noop,\n        move: noop,\n        change: noop,\n        show: noop,\n        hide: noop,\n\n        // Options\n        color: false,\n        flat: false,\n        showInput: false,\n        allowEmpty: false,\n        showButtons: true,\n        clickoutFiresChange: false,\n        showInitial: false,\n        showPalette: false,\n        showPaletteOnly: false,\n        hideAfterPaletteSelect: false,\n        togglePaletteOnly: false,\n        showSelectionPalette: true,\n        localStorageKey: false,\n        appendTo: "body",\n        maxSelectionSize: 7,\n        cancelText: "cancel",\n        chooseText: "choose",\n        togglePaletteMoreText: "more",\n        togglePaletteLessText: "less",\n        clearText: "Clear Color Selection",\n        noColorSelectedText: "No Color Selected",\n        preferredFormat: false,\n        className: "", // Deprecated - use containerClassName and replacerClassName instead.\n        containerClassName: "",\n        replacerClassName: "",\n        showAlpha: false,\n        theme: "sp-light",\n        palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],\n        selectionPalette: [],\n        disabled: false\n    },\n        spectrums = [],\n        IE = !!/msie/i.exec(window.navigator.userAgent),\n        rgbaSupport = function () {\n        function contains(str, substr) {\n            return !!~(\'\' + str).indexOf(substr);\n        }\n\n        var elem = document.createElement(\'div\');\n        var style = elem.style;\n        style.cssText = \'background-color:rgba(0,0,0,.5)\';\n        return contains(style.backgroundColor, \'rgba\') || contains(style.backgroundColor, \'hsla\');\n    }(),\n        inputTypeColorSupport = function () {\n        var colorInput = $("<input type=\'color\' value=\'!\' />")[0];\n        return colorInput.type === "color" && colorInput.value !== "!";\n    }(),\n        replaceInput = ["<div class=\'sp-replacer\'>", "<div class=\'sp-preview\'><div class=\'sp-preview-inner\'></div></div>", "<div class=\'sp-dd\'>&#9660;</div>", "</div>"].join(\'\'),\n        markup = function () {\n\n        // IE does not support gradients with multiple stops, so we need to simulate\n        //  that for the rainbow slider with 8 divs that each have a single gradient\n        var gradientFix = "";\n        if (IE) {\n            for (var i = 1; i <= 6; i++) {\n                gradientFix += "<div class=\'sp-" + i + "\'></div>";\n            }\n        }\n\n        return ["<div class=\'sp-container sp-hidden\'>", "<div class=\'sp-palette-container\'>", "<div class=\'sp-palette sp-thumb sp-cf\'></div>", "<div class=\'sp-palette-button-container sp-cf\'>", "<button type=\'button\' class=\'sp-palette-toggle\'></button>", "</div>", "</div>", "<div class=\'sp-picker-container\'>", "<div class=\'sp-top sp-cf\'>", "<div class=\'sp-fill\'></div>", "<div class=\'sp-top-inner\'>", "<div class=\'sp-color\'>", "<div class=\'sp-sat\'>", "<div class=\'sp-val\'>", "<div class=\'sp-dragger\'></div>", "</div>", "</div>", "</div>", "<div class=\'sp-clear sp-clear-display\'>", "</div>", "<div class=\'sp-hue\'>", "<div class=\'sp-slider\'></div>", gradientFix, "</div>", "</div>", "<div class=\'sp-alpha\'><div class=\'sp-alpha-inner\'><div class=\'sp-alpha-handle\'></div></div></div>", "</div>", "<div class=\'sp-input-container sp-cf\'>", "<input class=\'sp-input\' type=\'text\' spellcheck=\'false\'  />", "</div>", "<div class=\'sp-initial sp-thumb sp-cf\'></div>", "<div class=\'sp-button-container sp-cf\'>", "<a class=\'sp-cancel\' href=\'#\'></a>", "<button type=\'button\' class=\'sp-choose\'></button>", "</div>", "</div>", "</div>"].join("");\n    }();\n\n    function paletteTemplate(p, color, className, opts) {\n        var html = [];\n        for (var i = 0; i < p.length; i++) {\n            var current = p[i];\n            if (current) {\n                var tiny = tinycolor(current);\n                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";\n                c += tinycolor.equals(color, current) ? " sp-thumb-active" : "";\n                var formattedString = tiny.toString(opts.preferredFormat || "rgb");\n                var swatchStyle = rgbaSupport ? "background-color:" + tiny.toRgbString() : "filter:" + tiny.toFilter();\n                html.push(\'<span title="\' + formattedString + \'" data-color="\' + tiny.toRgbString() + \'" class="\' + c + \'"><span class="sp-thumb-inner" style="\' + swatchStyle + \';" /></span>\');\n            } else {\n                var cls = \'sp-clear-display\';\n                html.push($(\'<div />\').append($(\'<span data-color="" style="background-color:transparent;" class="\' + cls + \'"></span>\').attr(\'title\', opts.noColorSelectedText)).html());\n            }\n        }\n        return "<div class=\'sp-cf " + className + "\'>" + html.join(\'\') + "</div>";\n    }\n\n    function hideAll() {\n        for (var i = 0; i < spectrums.length; i++) {\n            if (spectrums[i]) {\n                spectrums[i].hide();\n            }\n        }\n    }\n\n    function instanceOptions(o, callbackContext) {\n        var opts = $.extend({}, defaultOpts, o);\n        opts.callbacks = {\n            \'move\': bind(opts.move, callbackContext),\n            \'change\': bind(opts.change, callbackContext),\n            \'show\': bind(opts.show, callbackContext),\n            \'hide\': bind(opts.hide, callbackContext),\n            \'beforeShow\': bind(opts.beforeShow, callbackContext)\n        };\n\n        return opts;\n    }\n\n    function spectrum(element, o) {\n\n        var opts = instanceOptions(o, element),\n            flat = opts.flat,\n            showSelectionPalette = opts.showSelectionPalette,\n            localStorageKey = opts.localStorageKey,\n            theme = opts.theme,\n            callbacks = opts.callbacks,\n            resize = throttle(reflow, 10),\n            visible = false,\n            dragWidth = 0,\n            dragHeight = 0,\n            dragHelperHeight = 0,\n            slideHeight = 0,\n            slideWidth = 0,\n            alphaWidth = 0,\n            alphaSlideHelperWidth = 0,\n            slideHelperHeight = 0,\n            currentHue = 0,\n            currentSaturation = 0,\n            currentValue = 0,\n            currentAlpha = 1,\n            palette = [],\n            paletteArray = [],\n            paletteLookup = {},\n            selectionPalette = opts.selectionPalette.slice(0),\n            maxSelectionSize = opts.maxSelectionSize,\n            draggingClass = "sp-dragging",\n            shiftMovementDirection = null;\n\n        var doc = element.ownerDocument,\n            body = doc.body,\n            boundElement = $(element),\n            disabled = false,\n            container = $(markup, doc).addClass(theme),\n            pickerContainer = container.find(".sp-picker-container"),\n            dragger = container.find(".sp-color"),\n            dragHelper = container.find(".sp-dragger"),\n            slider = container.find(".sp-hue"),\n            slideHelper = container.find(".sp-slider"),\n            alphaSliderInner = container.find(".sp-alpha-inner"),\n            alphaSlider = container.find(".sp-alpha"),\n            alphaSlideHelper = container.find(".sp-alpha-handle"),\n            textInput = container.find(".sp-input"),\n            paletteContainer = container.find(".sp-palette"),\n            initialColorContainer = container.find(".sp-initial"),\n            cancelButton = container.find(".sp-cancel"),\n            clearButton = container.find(".sp-clear"),\n            chooseButton = container.find(".sp-choose"),\n            toggleButton = container.find(".sp-palette-toggle"),\n            isInput = boundElement.is("input"),\n            isInputTypeColor = isInput && inputTypeColorSupport && boundElement.attr("type") === "color",\n            shouldReplace = isInput && !flat,\n            replacer = shouldReplace ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),\n            offsetElement = shouldReplace ? replacer : boundElement,\n            previewElement = replacer.find(".sp-preview-inner"),\n            initialColor = opts.color || isInput && boundElement.val(),\n            colorOnShow = false,\n            preferredFormat = opts.preferredFormat,\n            currentPreferredFormat = preferredFormat,\n            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,\n            isEmpty = !initialColor,\n            allowEmpty = opts.allowEmpty && !isInputTypeColor;\n\n        function applyOptions() {\n\n            if (opts.showPaletteOnly) {\n                opts.showPalette = true;\n            }\n\n            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);\n\n            if (opts.palette) {\n                palette = opts.palette.slice(0);\n                paletteArray = $.isArray(palette[0]) ? palette : [palette];\n                paletteLookup = {};\n                for (var i = 0; i < paletteArray.length; i++) {\n                    for (var j = 0; j < paletteArray[i].length; j++) {\n                        var rgb = tinycolor(paletteArray[i][j]).toRgbString();\n                        paletteLookup[rgb] = true;\n                    }\n                }\n            }\n\n            container.toggleClass("sp-flat", flat);\n            container.toggleClass("sp-input-disabled", !opts.showInput);\n            container.toggleClass("sp-alpha-enabled", opts.showAlpha);\n            container.toggleClass("sp-clear-enabled", allowEmpty);\n            container.toggleClass("sp-buttons-disabled", !opts.showButtons);\n            container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);\n            container.toggleClass("sp-palette-disabled", !opts.showPalette);\n            container.toggleClass("sp-palette-only", opts.showPaletteOnly);\n            container.toggleClass("sp-initial-disabled", !opts.showInitial);\n            container.addClass(opts.className).addClass(opts.containerClassName);\n\n            reflow();\n        }\n\n        function initialize() {\n\n            if (IE) {\n                container.find("*:not(input)").attr("unselectable", "on");\n            }\n\n            applyOptions();\n\n            if (shouldReplace) {\n                boundElement.after(replacer).hide();\n            }\n\n            if (!allowEmpty) {\n                clearButton.hide();\n            }\n\n            if (flat) {\n                boundElement.after(container).hide();\n            } else {\n\n                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);\n                if (appendTo.length !== 1) {\n                    appendTo = $("body");\n                }\n\n                appendTo.append(container);\n            }\n\n            updateSelectionPaletteFromStorage();\n\n            offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {\n                if (!disabled) {\n                    toggle();\n                }\n\n                e.stopPropagation();\n\n                if (!$(e.target).is("input")) {\n                    e.preventDefault();\n                }\n            });\n\n            if (boundElement.is(":disabled") || opts.disabled === true) {\n                disable();\n            }\n\n            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.\n            container.click(stopPropagation);\n\n            // Handle user typed input\n            textInput.change(setFromTextInput);\n            textInput.bind("paste", function () {\n                setTimeout(setFromTextInput, 1);\n            });\n            textInput.keydown(function (e) {\n                if (e.keyCode == 13) {\n                    setFromTextInput();\n                }\n            });\n\n            cancelButton.text(opts.cancelText);\n            cancelButton.bind("click.spectrum", function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                revert();\n                hide();\n            });\n\n            clearButton.attr("title", opts.clearText);\n            clearButton.bind("click.spectrum", function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                isEmpty = true;\n                move();\n\n                if (flat) {\n                    //for the flat style, this is a change event\n                    updateOriginalInput(true);\n                }\n            });\n\n            chooseButton.text(opts.chooseText);\n            chooseButton.bind("click.spectrum", function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n\n                if (isValid()) {\n                    updateOriginalInput(true);\n                    hide();\n                }\n            });\n\n            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);\n            toggleButton.bind("click.spectrum", function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n\n                opts.showPaletteOnly = !opts.showPaletteOnly;\n\n                // To make sure the Picker area is drawn on the right, next to the\n                // Palette area (and not below the palette), first move the Palette\n                // to the left to make space for the picker, plus 5px extra.\n                // The \'applyOptions\' function puts the whole container back into place\n                // and takes care of the button-text and the sp-palette-only CSS class.\n                if (!opts.showPaletteOnly && !flat) {\n                    container.css(\'left\', \'-=\' + (pickerContainer.outerWidth(true) + 5));\n                }\n                applyOptions();\n            });\n\n            draggable(alphaSlider, function (dragX, dragY, e) {\n                currentAlpha = dragX / alphaWidth;\n                isEmpty = false;\n                if (e.shiftKey) {\n                    currentAlpha = Math.round(currentAlpha * 10) / 10;\n                }\n\n                move();\n            }, dragStart, dragStop);\n\n            draggable(slider, function (dragX, dragY) {\n                currentHue = parseFloat(dragY / slideHeight);\n                isEmpty = false;\n                if (!opts.showAlpha) {\n                    currentAlpha = 1;\n                }\n                move();\n            }, dragStart, dragStop);\n\n            draggable(dragger, function (dragX, dragY, e) {\n\n                // shift+drag should snap the movement to either the x or y axis.\n                if (!e.shiftKey) {\n                    shiftMovementDirection = null;\n                } else if (!shiftMovementDirection) {\n                    var oldDragX = currentSaturation * dragWidth;\n                    var oldDragY = dragHeight - currentValue * dragHeight;\n                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);\n\n                    shiftMovementDirection = furtherFromX ? "x" : "y";\n                }\n\n                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";\n                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";\n\n                if (setSaturation) {\n                    currentSaturation = parseFloat(dragX / dragWidth);\n                }\n                if (setValue) {\n                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);\n                }\n\n                isEmpty = false;\n                if (!opts.showAlpha) {\n                    currentAlpha = 1;\n                }\n\n                move();\n            }, dragStart, dragStop);\n\n            if (!!initialColor) {\n                _set(initialColor);\n\n                // In case color was black - update the preview UI and set the format\n                // since the set function will not run (default color is black).\n                updateUI();\n                currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;\n\n                addColorToSelectionPalette(initialColor);\n            } else {\n                updateUI();\n            }\n\n            if (flat) {\n                show();\n            }\n\n            function paletteElementClick(e) {\n                if (e.data && e.data.ignore) {\n                    _set($(e.target).closest(".sp-thumb-el").data("color"));\n                    move();\n                } else {\n                    _set($(e.target).closest(".sp-thumb-el").data("color"));\n                    move();\n                    updateOriginalInput(true);\n                    if (opts.hideAfterPaletteSelect) {\n                        hide();\n                    }\n                }\n\n                return false;\n            }\n\n            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";\n            paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);\n            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, paletteElementClick);\n        }\n\n        function updateSelectionPaletteFromStorage() {\n\n            if (localStorageKey && window.localStorage) {\n\n                // Migrate old palettes over to new format.  May want to remove this eventually.\n                try {\n                    var oldPalette = window.localStorage[localStorageKey].split(",#");\n                    if (oldPalette.length > 1) {\n                        delete window.localStorage[localStorageKey];\n                        $.each(oldPalette, function (i, c) {\n                            addColorToSelectionPalette(c);\n                        });\n                    }\n                } catch (e) {}\n\n                try {\n                    selectionPalette = window.localStorage[localStorageKey].split(";");\n                } catch (e) {}\n            }\n        }\n\n        function addColorToSelectionPalette(color) {\n            if (showSelectionPalette) {\n                var rgb = tinycolor(color).toRgbString();\n                if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {\n                    selectionPalette.push(rgb);\n                    while (selectionPalette.length > maxSelectionSize) {\n                        selectionPalette.shift();\n                    }\n                }\n\n                if (localStorageKey && window.localStorage) {\n                    try {\n                        window.localStorage[localStorageKey] = selectionPalette.join(";");\n                    } catch (e) {}\n                }\n            }\n        }\n\n        function getUniqueSelectionPalette() {\n            var unique = [];\n            if (opts.showPalette) {\n                for (var i = 0; i < selectionPalette.length; i++) {\n                    var rgb = tinycolor(selectionPalette[i]).toRgbString();\n\n                    if (!paletteLookup[rgb]) {\n                        unique.push(selectionPalette[i]);\n                    }\n                }\n            }\n\n            return unique.reverse().slice(0, opts.maxSelectionSize);\n        }\n\n        function drawPalette() {\n\n            var currentColor = get();\n\n            var html = $.map(paletteArray, function (palette, i) {\n                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);\n            });\n\n            updateSelectionPaletteFromStorage();\n\n            if (selectionPalette) {\n                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));\n            }\n\n            paletteContainer.html(html.join(""));\n        }\n\n        function drawInitial() {\n            if (opts.showInitial) {\n                var initial = colorOnShow;\n                var current = get();\n                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));\n            }\n        }\n\n        function dragStart() {\n            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {\n                reflow();\n            }\n            container.addClass(draggingClass);\n            shiftMovementDirection = null;\n            boundElement.trigger(\'dragstart.spectrum\', [get()]);\n        }\n\n        function dragStop() {\n            container.removeClass(draggingClass);\n            boundElement.trigger(\'dragstop.spectrum\', [get()]);\n        }\n\n        function setFromTextInput() {\n\n            var value = textInput.val();\n\n            if ((value === null || value === "") && allowEmpty) {\n                _set(null);\n                updateOriginalInput(true);\n            } else {\n                var tiny = tinycolor(value);\n                if (tiny.isValid()) {\n                    _set(tiny);\n                    updateOriginalInput(true);\n                } else {\n                    textInput.addClass("sp-validation-error");\n                }\n            }\n        }\n\n        function toggle() {\n            if (visible) {\n                hide();\n            } else {\n                show();\n            }\n        }\n\n        function show() {\n            var event = $.Event(\'beforeShow.spectrum\');\n\n            if (visible) {\n                reflow();\n                return;\n            }\n\n            boundElement.trigger(event, [get()]);\n\n            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {\n                return;\n            }\n\n            hideAll();\n            visible = true;\n\n            $(doc).bind("click.spectrum", clickout);\n            $(window).bind("resize.spectrum", resize);\n            replacer.addClass("sp-active");\n            container.removeClass("sp-hidden");\n\n            reflow();\n            updateUI();\n\n            colorOnShow = get();\n\n            drawInitial();\n            callbacks.show(colorOnShow);\n            boundElement.trigger(\'show.spectrum\', [colorOnShow]);\n        }\n\n        function clickout(e) {\n            // Return on right click.\n            if (e && e.type == "click" && e.button == 2) {\n                return;\n            }\n\n            if (clickoutFiresChange) {\n                updateOriginalInput(true);\n            } else {\n                revert();\n            }\n            hide();\n        }\n\n        function hide() {\n            // Return if hiding is unnecessary\n            if (!visible || flat) {\n                return;\n            }\n            visible = false;\n\n            $(doc).unbind("click.spectrum", clickout);\n            $(window).unbind("resize.spectrum", resize);\n\n            replacer.removeClass("sp-active");\n            container.addClass("sp-hidden");\n\n            callbacks.hide(get());\n            boundElement.trigger(\'hide.spectrum\', [get()]);\n        }\n\n        function revert() {\n            _set(colorOnShow, true);\n        }\n\n        function _set(color, ignoreFormatChange) {\n            if (tinycolor.equals(color, get())) {\n                // Update UI just in case a validation error needs\n                // to be cleared.\n                updateUI();\n                return;\n            }\n\n            var newColor, newHsv;\n            if (!color && allowEmpty) {\n                isEmpty = true;\n            } else {\n                isEmpty = false;\n                newColor = tinycolor(color);\n                newHsv = newColor.toHsv();\n\n                currentHue = newHsv.h % 360 / 360;\n                currentSaturation = newHsv.s;\n                currentValue = newHsv.v;\n                currentAlpha = newHsv.a;\n            }\n            updateUI();\n\n            if (newColor && newColor.isValid() && !ignoreFormatChange) {\n                currentPreferredFormat = preferredFormat || newColor.getFormat();\n            }\n        }\n\n        function get(opts) {\n            opts = opts || {};\n\n            if (allowEmpty && isEmpty) {\n                return null;\n            }\n\n            return tinycolor.fromRatio({\n                h: currentHue,\n                s: currentSaturation,\n                v: currentValue,\n                a: Math.round(currentAlpha * 100) / 100\n            }, { format: opts.format || currentPreferredFormat });\n        }\n\n        function isValid() {\n            return !textInput.hasClass("sp-validation-error");\n        }\n\n        function move() {\n            updateUI();\n\n            callbacks.move(get());\n            boundElement.trigger(\'move.spectrum\', [get()]);\n        }\n\n        function updateUI() {\n\n            textInput.removeClass("sp-validation-error");\n\n            updateHelperLocations();\n\n            // Update dragger background color (gradients take care of saturation and value).\n            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });\n            dragger.css("background-color", flatColor.toHexString());\n\n            // Get a format that alpha will be included in (hex and names ignore alpha)\n            var format = currentPreferredFormat;\n            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {\n                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {\n                    format = "rgb";\n                }\n            }\n\n            var realColor = get({ format: format }),\n                displayColor = \'\';\n\n            //reset background info for preview element\n            previewElement.removeClass("sp-clear-display");\n            previewElement.css(\'background-color\', \'transparent\');\n\n            if (!realColor && allowEmpty) {\n                // Update the replaced elements background with icon indicating no color selection\n                previewElement.addClass("sp-clear-display");\n            } else {\n                var realHex = realColor.toHexString(),\n                    realRgb = realColor.toRgbString();\n\n                // Update the replaced elements background color (with actual selected color)\n                if (rgbaSupport || realColor.alpha === 1) {\n                    previewElement.css("background-color", realRgb);\n                } else {\n                    previewElement.css("background-color", "transparent");\n                    previewElement.css("filter", realColor.toFilter());\n                }\n\n                if (opts.showAlpha) {\n                    var rgb = realColor.toRgb();\n                    rgb.a = 0;\n                    var realAlpha = tinycolor(rgb).toRgbString();\n                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";\n\n                    if (IE) {\n                        alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));\n                    } else {\n                        alphaSliderInner.css("background", "-webkit-" + gradient);\n                        alphaSliderInner.css("background", "-moz-" + gradient);\n                        alphaSliderInner.css("background", "-ms-" + gradient);\n                        // Use current syntax gradient on unprefixed property.\n                        alphaSliderInner.css("background", "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");\n                    }\n                }\n\n                displayColor = realColor.toString(format);\n            }\n\n            // Update the text entry input as it changes happen\n            if (opts.showInput) {\n                textInput.val(displayColor);\n            }\n\n            if (opts.showPalette) {\n                drawPalette();\n            }\n\n            drawInitial();\n        }\n\n        function updateHelperLocations() {\n            var s = currentSaturation;\n            var v = currentValue;\n\n            if (allowEmpty && isEmpty) {\n                //if selected color is empty, hide the helpers\n                alphaSlideHelper.hide();\n                slideHelper.hide();\n                dragHelper.hide();\n            } else {\n                //make sure helpers are visible\n                alphaSlideHelper.show();\n                slideHelper.show();\n                dragHelper.show();\n\n                // Where to show the little circle in that displays your current selected color\n                var dragX = s * dragWidth;\n                var dragY = dragHeight - v * dragHeight;\n                dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));\n                dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));\n                dragHelper.css({\n                    "top": dragY + "px",\n                    "left": dragX + "px"\n                });\n\n                var alphaX = currentAlpha * alphaWidth;\n                alphaSlideHelper.css({\n                    "left": alphaX - alphaSlideHelperWidth / 2 + "px"\n                });\n\n                // Where to show the bar that displays your current selected hue\n                var slideY = currentHue * slideHeight;\n                slideHelper.css({\n                    "top": slideY - slideHelperHeight + "px"\n                });\n            }\n        }\n\n        function updateOriginalInput(fireCallback) {\n            var color = get(),\n                displayColor = \'\',\n                hasChanged = !tinycolor.equals(color, colorOnShow);\n\n            if (color) {\n                displayColor = color.toString(currentPreferredFormat);\n                // Update the selection palette with the current color\n                addColorToSelectionPalette(color);\n            }\n\n            if (isInput) {\n                boundElement.val(displayColor);\n            }\n\n            if (fireCallback && hasChanged) {\n                callbacks.change(color);\n                boundElement.trigger(\'change\', [color]);\n            }\n        }\n\n        function reflow() {\n            dragWidth = dragger.width();\n            dragHeight = dragger.height();\n            dragHelperHeight = dragHelper.height();\n            slideWidth = slider.width();\n            slideHeight = slider.height();\n            slideHelperHeight = slideHelper.height();\n            alphaWidth = alphaSlider.width();\n            alphaSlideHelperWidth = alphaSlideHelper.width();\n\n            if (!flat) {\n                container.css("position", "absolute");\n                container.offset(getOffset(container, offsetElement));\n            }\n\n            updateHelperLocations();\n\n            if (opts.showPalette) {\n                drawPalette();\n            }\n\n            boundElement.trigger(\'reflow.spectrum\');\n        }\n\n        function destroy() {\n            boundElement.show();\n            offsetElement.unbind("click.spectrum touchstart.spectrum");\n            container.remove();\n            replacer.remove();\n            spectrums[spect.id] = null;\n        }\n\n        function option(optionName, optionValue) {\n            if (optionName === undefined) {\n                return $.extend({}, opts);\n            }\n            if (optionValue === undefined) {\n                return opts[optionName];\n            }\n\n            opts[optionName] = optionValue;\n            applyOptions();\n        }\n\n        function enable() {\n            disabled = false;\n            boundElement.attr("disabled", false);\n            offsetElement.removeClass("sp-disabled");\n        }\n\n        function disable() {\n            hide();\n            disabled = true;\n            boundElement.attr("disabled", true);\n            offsetElement.addClass("sp-disabled");\n        }\n\n        initialize();\n\n        var spect = {\n            show: show,\n            hide: hide,\n            toggle: toggle,\n            reflow: reflow,\n            option: option,\n            enable: enable,\n            disable: disable,\n            set: function set(c) {\n                _set(c);\n                updateOriginalInput();\n            },\n            get: get,\n            destroy: destroy,\n            container: container\n        };\n\n        spect.id = spectrums.push(spect) - 1;\n\n        return spect;\n    }\n\n    /**\n    * checkOffset - get the offset below/above and left/right element depending on screen position\n    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js\n    */\n    function getOffset(picker, input) {\n        var extraY = 0;\n        var dpWidth = picker.outerWidth();\n        var dpHeight = picker.outerHeight();\n        var inputHeight = input.outerHeight();\n        var doc = picker[0].ownerDocument;\n        var docElem = doc.documentElement;\n        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();\n        var viewHeight = docElem.clientHeight + $(doc).scrollTop();\n        var offset = input.offset();\n        offset.top += inputHeight;\n\n        offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);\n\n        offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);\n\n        return offset;\n    }\n\n    /**\n    * noop - do nothing\n    */\n    function noop() {}\n\n    /**\n    * stopPropagation - makes the code only doing this a little easier to read in line\n    */\n    function stopPropagation(e) {\n        e.stopPropagation();\n    }\n\n    /**\n    * Create a function bound to a given object\n    * Thanks to underscore.js\n    */\n    function bind(func, obj) {\n        var slice = Array.prototype.slice;\n        var args = slice.call(arguments, 2);\n        return function () {\n            return func.apply(obj, args.concat(slice.call(arguments)));\n        };\n    }\n\n    /**\n    * Lightweight drag helper.  Handles containment within the element, so that\n    * when dragging, the x is within [0,element.width] and y is within [0,element.height]\n    */\n    function draggable(element, onmove, onstart, onstop) {\n        onmove = onmove || function () {};\n        onstart = onstart || function () {};\n        onstop = onstop || function () {};\n        var doc = document;\n        var dragging = false;\n        var offset = {};\n        var maxHeight = 0;\n        var maxWidth = 0;\n        var hasTouch = \'ontouchstart\' in window;\n\n        var duringDragEvents = {};\n        duringDragEvents["selectstart"] = prevent;\n        duringDragEvents["dragstart"] = prevent;\n        duringDragEvents["touchmove mousemove"] = move;\n        duringDragEvents["touchend mouseup"] = stop;\n\n        function prevent(e) {\n            if (e.stopPropagation) {\n                e.stopPropagation();\n            }\n            if (e.preventDefault) {\n                e.preventDefault();\n            }\n            e.returnValue = false;\n        }\n\n        function move(e) {\n            if (dragging) {\n                // Mouseup happened outside of window\n                if (IE && doc.documentMode < 9 && !e.button) {\n                    return stop();\n                }\n\n                var touches = e.originalEvent.touches;\n                var pageX = touches ? touches[0].pageX : e.pageX;\n                var pageY = touches ? touches[0].pageY : e.pageY;\n\n                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));\n                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));\n\n                if (hasTouch) {\n                    // Stop scrolling in iOS\n                    prevent(e);\n                }\n\n                onmove.apply(element, [dragX, dragY, e]);\n            }\n        }\n\n        function start(e) {\n            var rightclick = e.which ? e.which == 3 : e.button == 2;\n\n            if (!rightclick && !dragging) {\n                if (onstart.apply(element, arguments) !== false) {\n                    dragging = true;\n                    maxHeight = $(element).height();\n                    maxWidth = $(element).width();\n                    offset = $(element).offset();\n\n                    $(doc).bind(duringDragEvents);\n                    $(doc.body).addClass("sp-dragging");\n\n                    if (!hasTouch) {\n                        move(e);\n                    }\n\n                    prevent(e);\n                }\n            }\n        }\n\n        function stop() {\n            if (dragging) {\n                $(doc).unbind(duringDragEvents);\n                $(doc.body).removeClass("sp-dragging");\n                onstop.apply(element, arguments);\n            }\n            dragging = false;\n        }\n\n        $(element).bind("touchstart mousedown", start);\n    }\n\n    function throttle(func, wait, debounce) {\n        var timeout;\n        return function () {\n            var context = this,\n                args = arguments;\n            var throttler = function throttler() {\n                timeout = null;\n                func.apply(context, args);\n            };\n            if (debounce) clearTimeout(timeout);\n            if (debounce || !timeout) timeout = setTimeout(throttler, wait);\n        };\n    }\n\n    /**\n    * Define a jQuery plugin\n    */\n    var dataID = "spectrum.id";\n    $.fn.spectrum = function (opts, extra) {\n\n        if (typeof opts == "string") {\n\n            var returnValue = this;\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            this.each(function () {\n                var spect = spectrums[$(this).data(dataID)];\n                if (spect) {\n                    var method = spect[opts];\n                    if (!method) {\n                        throw new Error("Spectrum: no such method: \'" + opts + "\'");\n                    }\n\n                    if (opts == "get") {\n                        returnValue = spect.get();\n                    } else if (opts == "container") {\n                        returnValue = spect.container;\n                    } else if (opts == "option") {\n                        returnValue = spect.option.apply(spect, args);\n                    } else if (opts == "destroy") {\n                        spect.destroy();\n                        $(this).removeData(dataID);\n                    } else {\n                        method.apply(spect, args);\n                    }\n                }\n            });\n\n            return returnValue;\n        }\n\n        // Initializing a new instance of spectrum\n        return this.spectrum("destroy").each(function () {\n            var options = $.extend({}, opts, $(this).data());\n            var spect = spectrum(this, options);\n            $(this).data(dataID, spect.id);\n        });\n    };\n\n    $.fn.spectrum.load = true;\n    $.fn.spectrum.loadOpts = {};\n    $.fn.spectrum.draggable = draggable;\n    $.fn.spectrum.defaults = defaultOpts;\n\n    $.spectrum = {};\n    $.spectrum.localization = {};\n    $.spectrum.palettes = {};\n\n    $.fn.spectrum.processNativeColorInputs = function () {\n        if (!inputTypeColorSupport) {\n            $("input[type=color]").spectrum({\n                preferredFormat: "hex6"\n            });\n        }\n    };\n\n    // TinyColor v1.0.0\n    // https://github.com/bgrins/TinyColor\n    // Brian Grinstead, MIT License\n\n    (function () {\n\n        var trimLeft = /^[\\s,#]+/,\n            trimRight = /\\s+$/,\n            tinyCounter = 0,\n            math = Math,\n            mathRound = math.round,\n            mathMin = math.min,\n            mathMax = math.max,\n            mathRandom = math.random;\n\n        var tinycolor = function tinycolor(color, opts) {\n\n            color = color ? color : \'\';\n            opts = opts || {};\n\n            // If input is already a tinycolor, return itself\n            if (color instanceof tinycolor) {\n                return color;\n            }\n            // If we are called as a function, call using new instead\n            if (!(this instanceof tinycolor)) {\n                return new tinycolor(color, opts);\n            }\n\n            var rgb = inputToRGB(color);\n            this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;\n            this._gradientType = opts.gradientType;\n\n            // Don\'t let the range of [0,255] come back in [0,1].\n            // Potentially lose a little bit of precision here, but will fix issues where\n            // .5 gets interpreted as half of the total, instead of half of 1\n            // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n            if (this._r < 1) {\n                this._r = mathRound(this._r);\n            }\n            if (this._g < 1) {\n                this._g = mathRound(this._g);\n            }\n            if (this._b < 1) {\n                this._b = mathRound(this._b);\n            }\n\n            this._ok = rgb.ok;\n            this._tc_id = tinyCounter++;\n        };\n\n        tinycolor.prototype = {\n            isDark: function isDark() {\n                return this.getBrightness() < 128;\n            },\n            isLight: function isLight() {\n                return !this.isDark();\n            },\n            isValid: function isValid() {\n                return this._ok;\n            },\n            getFormat: function getFormat() {\n                return this._format;\n            },\n            getAlpha: function getAlpha() {\n                return this._a;\n            },\n            getBrightness: function getBrightness() {\n                var rgb = this.toRgb();\n                return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n            },\n            setAlpha: function setAlpha(value) {\n                this._a = boundAlpha(value);\n                this._roundA = mathRound(100 * this._a) / 100;\n                return this;\n            },\n            toHsv: function toHsv() {\n                var hsv = rgbToHsv(this._r, this._g, this._b);\n                return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };\n            },\n            toHsvString: function toHsvString() {\n                var hsv = rgbToHsv(this._r, this._g, this._b);\n                var h = mathRound(hsv.h * 360),\n                    s = mathRound(hsv.s * 100),\n                    v = mathRound(hsv.v * 100);\n                return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";\n            },\n            toHsl: function toHsl() {\n                var hsl = rgbToHsl(this._r, this._g, this._b);\n                return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };\n            },\n            toHslString: function toHslString() {\n                var hsl = rgbToHsl(this._r, this._g, this._b);\n                var h = mathRound(hsl.h * 360),\n                    s = mathRound(hsl.s * 100),\n                    l = mathRound(hsl.l * 100);\n                return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";\n            },\n            toHex: function toHex(allow3Char) {\n                return rgbToHex(this._r, this._g, this._b, allow3Char);\n            },\n            toHexString: function toHexString(allow3Char) {\n                return \'#\' + this.toHex(allow3Char);\n            },\n            toHex8: function toHex8() {\n                return rgbaToHex(this._r, this._g, this._b, this._a);\n            },\n            toHex8String: function toHex8String() {\n                return \'#\' + this.toHex8();\n            },\n            toRgb: function toRgb() {\n                return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };\n            },\n            toRgbString: function toRgbString() {\n                return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";\n            },\n            toPercentageRgb: function toPercentageRgb() {\n                return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };\n            },\n            toPercentageRgbString: function toPercentageRgbString() {\n                return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";\n            },\n            toName: function toName() {\n                if (this._a === 0) {\n                    return "transparent";\n                }\n\n                if (this._a < 1) {\n                    return false;\n                }\n\n                return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n            },\n            toFilter: function toFilter(secondColor) {\n                var hex8String = \'#\' + rgbaToHex(this._r, this._g, this._b, this._a);\n                var secondHex8String = hex8String;\n                var gradientType = this._gradientType ? "GradientType = 1, " : "";\n\n                if (secondColor) {\n                    var s = tinycolor(secondColor);\n                    secondHex8String = s.toHex8String();\n                }\n\n                return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";\n            },\n            toString: function toString(format) {\n                var formatSet = !!format;\n                format = format || this._format;\n\n                var formattedString = false;\n                var hasAlpha = this._a < 1 && this._a >= 0;\n                var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");\n\n                if (needsAlphaFormat) {\n                    // Special case for "transparent", all other non-alpha formats\n                    // will return rgba when there is transparency.\n                    if (format === "name" && this._a === 0) {\n                        return this.toName();\n                    }\n                    return this.toRgbString();\n                }\n                if (format === "rgb") {\n                    formattedString = this.toRgbString();\n                }\n                if (format === "prgb") {\n                    formattedString = this.toPercentageRgbString();\n                }\n                if (format === "hex" || format === "hex6") {\n                    formattedString = this.toHexString();\n                }\n                if (format === "hex3") {\n                    formattedString = this.toHexString(true);\n                }\n                if (format === "hex8") {\n                    formattedString = this.toHex8String();\n                }\n                if (format === "name") {\n                    formattedString = this.toName();\n                }\n                if (format === "hsl") {\n                    formattedString = this.toHslString();\n                }\n                if (format === "hsv") {\n                    formattedString = this.toHsvString();\n                }\n\n                return formattedString || this.toHexString();\n            },\n\n            _applyModification: function _applyModification(fn, args) {\n                var color = fn.apply(null, [this].concat([].slice.call(args)));\n                this._r = color._r;\n                this._g = color._g;\n                this._b = color._b;\n                this.setAlpha(color._a);\n                return this;\n            },\n            lighten: function lighten() {\n                return this._applyModification(_lighten, arguments);\n            },\n            brighten: function brighten() {\n                return this._applyModification(_brighten, arguments);\n            },\n            darken: function darken() {\n                return this._applyModification(_darken, arguments);\n            },\n            desaturate: function desaturate() {\n                return this._applyModification(_desaturate, arguments);\n            },\n            saturate: function saturate() {\n                return this._applyModification(_saturate, arguments);\n            },\n            greyscale: function greyscale() {\n                return this._applyModification(_greyscale, arguments);\n            },\n            spin: function spin() {\n                return this._applyModification(_spin, arguments);\n            },\n\n            _applyCombination: function _applyCombination(fn, args) {\n                return fn.apply(null, [this].concat([].slice.call(args)));\n            },\n            analogous: function analogous() {\n                return this._applyCombination(_analogous, arguments);\n            },\n            complement: function complement() {\n                return this._applyCombination(_complement, arguments);\n            },\n            monochromatic: function monochromatic() {\n                return this._applyCombination(_monochromatic, arguments);\n            },\n            splitcomplement: function splitcomplement() {\n                return this._applyCombination(_splitcomplement, arguments);\n            },\n            triad: function triad() {\n                return this._applyCombination(_triad, arguments);\n            },\n            tetrad: function tetrad() {\n                return this._applyCombination(_tetrad, arguments);\n            }\n        };\n\n        // If input is an object, force 1 into "1.0" to handle ratios properly\n        // String input requires "1.0" as input, so 1 will be treated as 1\n        tinycolor.fromRatio = function (color, opts) {\n            if ((typeof color === "undefined" ? "undefined" : _typeof(color)) == "object") {\n                var newColor = {};\n                for (var i in color) {\n                    if (color.hasOwnProperty(i)) {\n                        if (i === "a") {\n                            newColor[i] = color[i];\n                        } else {\n                            newColor[i] = convertToPercentage(color[i]);\n                        }\n                    }\n                }\n                color = newColor;\n            }\n\n            return tinycolor(color, opts);\n        };\n\n        // Given a string or object, convert that input to RGB\n        // Possible string inputs:\n        //\n        //     "red"\n        //     "#f00" or "f00"\n        //     "#ff0000" or "ff0000"\n        //     "#ff000000" or "ff000000"\n        //     "rgb 255 0 0" or "rgb (255, 0, 0)"\n        //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"\n        //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"\n        //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"\n        //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"\n        //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"\n        //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"\n        //\n        function inputToRGB(color) {\n\n            var rgb = { r: 0, g: 0, b: 0 };\n            var a = 1;\n            var ok = false;\n            var format = false;\n\n            if (typeof color == "string") {\n                color = stringInputToObject(color);\n            }\n\n            if ((typeof color === "undefined" ? "undefined" : _typeof(color)) == "object") {\n                if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {\n                    rgb = rgbToRgb(color.r, color.g, color.b);\n                    ok = true;\n                    format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";\n                } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {\n                    color.s = convertToPercentage(color.s);\n                    color.v = convertToPercentage(color.v);\n                    rgb = hsvToRgb(color.h, color.s, color.v);\n                    ok = true;\n                    format = "hsv";\n                } else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {\n                    color.s = convertToPercentage(color.s);\n                    color.l = convertToPercentage(color.l);\n                    rgb = hslToRgb(color.h, color.s, color.l);\n                    ok = true;\n                    format = "hsl";\n                }\n\n                if (color.hasOwnProperty("a")) {\n                    a = color.a;\n                }\n            }\n\n            a = boundAlpha(a);\n\n            return {\n                ok: ok,\n                format: color.format || format,\n                r: mathMin(255, mathMax(rgb.r, 0)),\n                g: mathMin(255, mathMax(rgb.g, 0)),\n                b: mathMin(255, mathMax(rgb.b, 0)),\n                a: a\n            };\n        }\n\n        // Conversion Functions\n        // --------------------\n\n        // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n        // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n        // `rgbToRgb`\n        // Handle bounds / percentage checking to conform to CSS color spec\n        // <http://www.w3.org/TR/css3-color/>\n        // *Assumes:* r, g, b in [0, 255] or [0, 1]\n        // *Returns:* { r, g, b } in [0, 255]\n        function rgbToRgb(r, g, b) {\n            return {\n                r: bound01(r, 255) * 255,\n                g: bound01(g, 255) * 255,\n                b: bound01(b, 255) * 255\n            };\n        }\n\n        // `rgbToHsl`\n        // Converts an RGB color value to HSL.\n        // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n        // *Returns:* { h, s, l } in [0,1]\n        function rgbToHsl(r, g, b) {\n\n            r = bound01(r, 255);\n            g = bound01(g, 255);\n            b = bound01(b, 255);\n\n            var max = mathMax(r, g, b),\n                min = mathMin(r, g, b);\n            var h,\n                s,\n                l = (max + min) / 2;\n\n            if (max == min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch (max) {\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);break;\n                    case g:\n                        h = (b - r) / d + 2;break;\n                    case b:\n                        h = (r - g) / d + 4;break;\n                }\n\n                h /= 6;\n            }\n\n            return { h: h, s: s, l: l };\n        }\n\n        // `hslToRgb`\n        // Converts an HSL color value to RGB.\n        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n        // *Returns:* { r, g, b } in the set [0, 255]\n        function hslToRgb(h, s, l) {\n            var r, g, b;\n\n            h = bound01(h, 360);\n            s = bound01(s, 100);\n            l = bound01(l, 100);\n\n            function hue2rgb(p, q, t) {\n                if (t < 0) t += 1;\n                if (t > 1) t -= 1;\n                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                if (t < 1 / 2) return q;\n                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                return p;\n            }\n\n            if (s === 0) {\n                r = g = b = l; // achromatic\n            } else {\n                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                var p = 2 * l - q;\n                r = hue2rgb(p, q, h + 1 / 3);\n                g = hue2rgb(p, q, h);\n                b = hue2rgb(p, q, h - 1 / 3);\n            }\n\n            return { r: r * 255, g: g * 255, b: b * 255 };\n        }\n\n        // `rgbToHsv`\n        // Converts an RGB color value to HSV\n        // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n        // *Returns:* { h, s, v } in [0,1]\n        function rgbToHsv(r, g, b) {\n\n            r = bound01(r, 255);\n            g = bound01(g, 255);\n            b = bound01(b, 255);\n\n            var max = mathMax(r, g, b),\n                min = mathMin(r, g, b);\n            var h,\n                s,\n                v = max;\n\n            var d = max - min;\n            s = max === 0 ? 0 : d / max;\n\n            if (max == min) {\n                h = 0; // achromatic\n            } else {\n                switch (max) {\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);break;\n                    case g:\n                        h = (b - r) / d + 2;break;\n                    case b:\n                        h = (r - g) / d + 4;break;\n                }\n                h /= 6;\n            }\n            return { h: h, s: s, v: v };\n        }\n\n        // `hsvToRgb`\n        // Converts an HSV color value to RGB.\n        // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n        // *Returns:* { r, g, b } in the set [0, 255]\n        function hsvToRgb(h, s, v) {\n\n            h = bound01(h, 360) * 6;\n            s = bound01(s, 100);\n            v = bound01(v, 100);\n\n            var i = math.floor(h),\n                f = h - i,\n                p = v * (1 - s),\n                q = v * (1 - f * s),\n                t = v * (1 - (1 - f) * s),\n                mod = i % 6,\n                r = [v, q, p, p, t, v][mod],\n                g = [t, v, v, q, p, p][mod],\n                b = [p, p, t, v, v, q][mod];\n\n            return { r: r * 255, g: g * 255, b: b * 255 };\n        }\n\n        // `rgbToHex`\n        // Converts an RGB color to hex\n        // Assumes r, g, and b are contained in the set [0, 255]\n        // Returns a 3 or 6 character hex\n        function rgbToHex(r, g, b, allow3Char) {\n\n            var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];\n\n            // Return a 3 character hex if possible\n            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n                return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n            }\n\n            return hex.join("");\n        }\n        // `rgbaToHex`\n        // Converts an RGBA color plus alpha transparency to hex\n        // Assumes r, g, b and a are contained in the set [0, 255]\n        // Returns an 8 character hex\n        function rgbaToHex(r, g, b, a) {\n\n            var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];\n\n            return hex.join("");\n        }\n\n        // `equals`\n        // Can be called with any tinycolor input\n        tinycolor.equals = function (color1, color2) {\n            if (!color1 || !color2) {\n                return false;\n            }\n            return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n        };\n        tinycolor.random = function () {\n            return tinycolor.fromRatio({\n                r: mathRandom(),\n                g: mathRandom(),\n                b: mathRandom()\n            });\n        };\n\n        // Modification Functions\n        // ----------------------\n        // Thanks to less.js for some of the basics here\n        // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\n        function _desaturate(color, amount) {\n            amount = amount === 0 ? 0 : amount || 10;\n            var hsl = tinycolor(color).toHsl();\n            hsl.s -= amount / 100;\n            hsl.s = clamp01(hsl.s);\n            return tinycolor(hsl);\n        }\n\n        function _saturate(color, amount) {\n            amount = amount === 0 ? 0 : amount || 10;\n            var hsl = tinycolor(color).toHsl();\n            hsl.s += amount / 100;\n            hsl.s = clamp01(hsl.s);\n            return tinycolor(hsl);\n        }\n\n        function _greyscale(color) {\n            return tinycolor(color).desaturate(100);\n        }\n\n        function _lighten(color, amount) {\n            amount = amount === 0 ? 0 : amount || 10;\n            var hsl = tinycolor(color).toHsl();\n            hsl.l += amount / 100;\n            hsl.l = clamp01(hsl.l);\n            return tinycolor(hsl);\n        }\n\n        function _brighten(color, amount) {\n            amount = amount === 0 ? 0 : amount || 10;\n            var rgb = tinycolor(color).toRgb();\n            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));\n            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));\n            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));\n            return tinycolor(rgb);\n        }\n\n        function _darken(color, amount) {\n            amount = amount === 0 ? 0 : amount || 10;\n            var hsl = tinycolor(color).toHsl();\n            hsl.l -= amount / 100;\n            hsl.l = clamp01(hsl.l);\n            return tinycolor(hsl);\n        }\n\n        // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n        // Values outside of this range will be wrapped into this range.\n        function _spin(color, amount) {\n            var hsl = tinycolor(color).toHsl();\n            var hue = (mathRound(hsl.h) + amount) % 360;\n            hsl.h = hue < 0 ? 360 + hue : hue;\n            return tinycolor(hsl);\n        }\n\n        // Combination Functions\n        // ---------------------\n        // Thanks to jQuery xColor for some of the ideas behind these\n        // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\n        function _complement(color) {\n            var hsl = tinycolor(color).toHsl();\n            hsl.h = (hsl.h + 180) % 360;\n            return tinycolor(hsl);\n        }\n\n        function _triad(color) {\n            var hsl = tinycolor(color).toHsl();\n            var h = hsl.h;\n            return [tinycolor(color), tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })];\n        }\n\n        function _tetrad(color) {\n            var hsl = tinycolor(color).toHsl();\n            var h = hsl.h;\n            return [tinycolor(color), tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })];\n        }\n\n        function _splitcomplement(color) {\n            var hsl = tinycolor(color).toHsl();\n            var h = hsl.h;\n            return [tinycolor(color), tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })];\n        }\n\n        function _analogous(color, results, slices) {\n            results = results || 6;\n            slices = slices || 30;\n\n            var hsl = tinycolor(color).toHsl();\n            var part = 360 / slices;\n            var ret = [tinycolor(color)];\n\n            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {\n                hsl.h = (hsl.h + part) % 360;\n                ret.push(tinycolor(hsl));\n            }\n            return ret;\n        }\n\n        function _monochromatic(color, results) {\n            results = results || 6;\n            var hsv = tinycolor(color).toHsv();\n            var h = hsv.h,\n                s = hsv.s,\n                v = hsv.v;\n            var ret = [];\n            var modification = 1 / results;\n\n            while (results--) {\n                ret.push(tinycolor({ h: h, s: s, v: v }));\n                v = (v + modification) % 1;\n            }\n\n            return ret;\n        }\n\n        // Utility Functions\n        // ---------------------\n\n        tinycolor.mix = function (color1, color2, amount) {\n            amount = amount === 0 ? 0 : amount || 50;\n\n            var rgb1 = tinycolor(color1).toRgb();\n            var rgb2 = tinycolor(color2).toRgb();\n\n            var p = amount / 100;\n            var w = p * 2 - 1;\n            var a = rgb2.a - rgb1.a;\n\n            var w1;\n\n            if (w * a == -1) {\n                w1 = w;\n            } else {\n                w1 = (w + a) / (1 + w * a);\n            }\n\n            w1 = (w1 + 1) / 2;\n\n            var w2 = 1 - w1;\n\n            var rgba = {\n                r: rgb2.r * w1 + rgb1.r * w2,\n                g: rgb2.g * w1 + rgb1.g * w2,\n                b: rgb2.b * w1 + rgb1.b * w2,\n                a: rgb2.a * p + rgb1.a * (1 - p)\n            };\n\n            return tinycolor(rgba);\n        };\n\n        // Readability Functions\n        // ---------------------\n        // <http://www.w3.org/TR/AERT#color-contrast>\n\n        // `readability`\n        // Analyze the 2 colors and returns an object with the following properties:\n        //    `brightness`: difference in brightness between the two colors\n        //    `color`: difference in color/hue between the two colors\n        tinycolor.readability = function (color1, color2) {\n            var c1 = tinycolor(color1);\n            var c2 = tinycolor(color2);\n            var rgb1 = c1.toRgb();\n            var rgb2 = c2.toRgb();\n            var brightnessA = c1.getBrightness();\n            var brightnessB = c2.getBrightness();\n            var colorDiff = Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) + Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) + Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b);\n\n            return {\n                brightness: Math.abs(brightnessA - brightnessB),\n                color: colorDiff\n            };\n        };\n\n        // `readable`\n        // http://www.w3.org/TR/AERT#color-contrast\n        // Ensure that foreground and background color combinations provide sufficient contrast.\n        // *Example*\n        //    tinycolor.isReadable("#000", "#111") => false\n        tinycolor.isReadable = function (color1, color2) {\n            var readability = tinycolor.readability(color1, color2);\n            return readability.brightness > 125 && readability.color > 500;\n        };\n\n        // `mostReadable`\n        // Given a base color and a list of possible foreground or background\n        // colors for that base, returns the most readable color.\n        // *Example*\n        //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"\n        tinycolor.mostReadable = function (baseColor, colorList) {\n            var bestColor = null;\n            var bestScore = 0;\n            var bestIsReadable = false;\n            for (var i = 0; i < colorList.length; i++) {\n\n                // We normalize both around the "acceptable" breaking point,\n                // but rank brightness constrast higher than hue.\n\n                var readability = tinycolor.readability(baseColor, colorList[i]);\n                var readable = readability.brightness > 125 && readability.color > 500;\n                var score = 3 * (readability.brightness / 125) + readability.color / 500;\n\n                if (readable && !bestIsReadable || readable && bestIsReadable && score > bestScore || !readable && !bestIsReadable && score > bestScore) {\n                    bestIsReadable = readable;\n                    bestScore = score;\n                    bestColor = tinycolor(colorList[i]);\n                }\n            }\n            return bestColor;\n        };\n\n        // Big List of Colors\n        // ------------------\n        // <http://www.w3.org/TR/css3-color/#svg-color>\n        var names = tinycolor.names = {\n            aliceblue: "f0f8ff",\n            antiquewhite: "faebd7",\n            aqua: "0ff",\n            aquamarine: "7fffd4",\n            azure: "f0ffff",\n            beige: "f5f5dc",\n            bisque: "ffe4c4",\n            black: "000",\n            blanchedalmond: "ffebcd",\n            blue: "00f",\n            blueviolet: "8a2be2",\n            brown: "a52a2a",\n            burlywood: "deb887",\n            burntsienna: "ea7e5d",\n            cadetblue: "5f9ea0",\n            chartreuse: "7fff00",\n            chocolate: "d2691e",\n            coral: "ff7f50",\n            cornflowerblue: "6495ed",\n            cornsilk: "fff8dc",\n            crimson: "dc143c",\n            cyan: "0ff",\n            darkblue: "00008b",\n            darkcyan: "008b8b",\n            darkgoldenrod: "b8860b",\n            darkgray: "a9a9a9",\n            darkgreen: "006400",\n            darkgrey: "a9a9a9",\n            darkkhaki: "bdb76b",\n            darkmagenta: "8b008b",\n            darkolivegreen: "556b2f",\n            darkorange: "ff8c00",\n            darkorchid: "9932cc",\n            darkred: "8b0000",\n            darksalmon: "e9967a",\n            darkseagreen: "8fbc8f",\n            darkslateblue: "483d8b",\n            darkslategray: "2f4f4f",\n            darkslategrey: "2f4f4f",\n            darkturquoise: "00ced1",\n            darkviolet: "9400d3",\n            deeppink: "ff1493",\n            deepskyblue: "00bfff",\n            dimgray: "696969",\n            dimgrey: "696969",\n            dodgerblue: "1e90ff",\n            firebrick: "b22222",\n            floralwhite: "fffaf0",\n            forestgreen: "228b22",\n            fuchsia: "f0f",\n            gainsboro: "dcdcdc",\n            ghostwhite: "f8f8ff",\n            gold: "ffd700",\n            goldenrod: "daa520",\n            gray: "808080",\n            green: "008000",\n            greenyellow: "adff2f",\n            grey: "808080",\n            honeydew: "f0fff0",\n            hotpink: "ff69b4",\n            indianred: "cd5c5c",\n            indigo: "4b0082",\n            ivory: "fffff0",\n            khaki: "f0e68c",\n            lavender: "e6e6fa",\n            lavenderblush: "fff0f5",\n            lawngreen: "7cfc00",\n            lemonchiffon: "fffacd",\n            lightblue: "add8e6",\n            lightcoral: "f08080",\n            lightcyan: "e0ffff",\n            lightgoldenrodyellow: "fafad2",\n            lightgray: "d3d3d3",\n            lightgreen: "90ee90",\n            lightgrey: "d3d3d3",\n            lightpink: "ffb6c1",\n            lightsalmon: "ffa07a",\n            lightseagreen: "20b2aa",\n            lightskyblue: "87cefa",\n            lightslategray: "789",\n            lightslategrey: "789",\n            lightsteelblue: "b0c4de",\n            lightyellow: "ffffe0",\n            lime: "0f0",\n            limegreen: "32cd32",\n            linen: "faf0e6",\n            magenta: "f0f",\n            maroon: "800000",\n            mediumaquamarine: "66cdaa",\n            mediumblue: "0000cd",\n            mediumorchid: "ba55d3",\n            mediumpurple: "9370db",\n            mediumseagreen: "3cb371",\n            mediumslateblue: "7b68ee",\n            mediumspringgreen: "00fa9a",\n            mediumturquoise: "48d1cc",\n            mediumvioletred: "c71585",\n            midnightblue: "191970",\n            mintcream: "f5fffa",\n            mistyrose: "ffe4e1",\n            moccasin: "ffe4b5",\n            navajowhite: "ffdead",\n            navy: "000080",\n            oldlace: "fdf5e6",\n            olive: "808000",\n            olivedrab: "6b8e23",\n            orange: "ffa500",\n            orangered: "ff4500",\n            orchid: "da70d6",\n            palegoldenrod: "eee8aa",\n            palegreen: "98fb98",\n            paleturquoise: "afeeee",\n            palevioletred: "db7093",\n            papayawhip: "ffefd5",\n            peachpuff: "ffdab9",\n            peru: "cd853f",\n            pink: "ffc0cb",\n            plum: "dda0dd",\n            powderblue: "b0e0e6",\n            purple: "800080",\n            red: "f00",\n            rosybrown: "bc8f8f",\n            royalblue: "4169e1",\n            saddlebrown: "8b4513",\n            salmon: "fa8072",\n            sandybrown: "f4a460",\n            seagreen: "2e8b57",\n            seashell: "fff5ee",\n            sienna: "a0522d",\n            silver: "c0c0c0",\n            skyblue: "87ceeb",\n            slateblue: "6a5acd",\n            slategray: "708090",\n            slategrey: "708090",\n            snow: "fffafa",\n            springgreen: "00ff7f",\n            steelblue: "4682b4",\n            tan: "d2b48c",\n            teal: "008080",\n            thistle: "d8bfd8",\n            tomato: "ff6347",\n            turquoise: "40e0d0",\n            violet: "ee82ee",\n            wheat: "f5deb3",\n            white: "fff",\n            whitesmoke: "f5f5f5",\n            yellow: "ff0",\n            yellowgreen: "9acd32"\n        };\n\n        // Make it easy to access colors via `hexNames[hex]`\n        var hexNames = tinycolor.hexNames = flip(names);\n\n        // Utilities\n        // ---------\n\n        // `{ \'name1\': \'val1\' }` becomes `{ \'val1\': \'name1\' }`\n        function flip(o) {\n            var flipped = {};\n            for (var i in o) {\n                if (o.hasOwnProperty(i)) {\n                    flipped[o[i]] = i;\n                }\n            }\n            return flipped;\n        }\n\n        // Return a valid alpha value [0,1] with all invalid values being set to 1\n        function boundAlpha(a) {\n            a = parseFloat(a);\n\n            if (isNaN(a) || a < 0 || a > 1) {\n                a = 1;\n            }\n\n            return a;\n        }\n\n        // Take input from [0, n] and return it as [0, 1]\n        function bound01(n, max) {\n            if (isOnePointZero(n)) {\n                n = "100%";\n            }\n\n            var processPercent = isPercentage(n);\n            n = mathMin(max, mathMax(0, parseFloat(n)));\n\n            // Automatically convert percentage into number\n            if (processPercent) {\n                n = parseInt(n * max, 10) / 100;\n            }\n\n            // Handle floating point rounding errors\n            if (math.abs(n - max) < 0.000001) {\n                return 1;\n            }\n\n            // Convert into [0, 1] range if it isn\'t already\n            return n % max / parseFloat(max);\n        }\n\n        // Force a number between 0 and 1\n        function clamp01(val) {\n            return mathMin(1, mathMax(0, val));\n        }\n\n        // Parse a base-16 hex value into a base-10 integer\n        function parseIntFromHex(val) {\n            return parseInt(val, 16);\n        }\n\n        // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n        // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\n        function isOnePointZero(n) {\n            return typeof n == "string" && n.indexOf(\'.\') != -1 && parseFloat(n) === 1;\n        }\n\n        // Check to see if string passed in is a percentage\n        function isPercentage(n) {\n            return typeof n === "string" && n.indexOf(\'%\') != -1;\n        }\n\n        // Force a hex value to have 2 characters\n        function pad2(c) {\n            return c.length == 1 ? \'0\' + c : \'\' + c;\n        }\n\n        // Replace a decimal with it\'s percentage value\n        function convertToPercentage(n) {\n            if (n <= 1) {\n                n = n * 100 + "%";\n            }\n\n            return n;\n        }\n\n        // Converts a decimal to a hex value\n        function convertDecimalToHex(d) {\n            return Math.round(parseFloat(d) * 255).toString(16);\n        }\n        // Converts a hex value to a decimal\n        function convertHexToDecimal(h) {\n            return parseIntFromHex(h) / 255;\n        }\n\n        var matchers = function () {\n\n            // <http://www.w3.org/TR/css3-values/#integers>\n            var CSS_INTEGER = "[-\\\\+]?\\\\d+%?";\n\n            // <http://www.w3.org/TR/css3-values/#number-value>\n            var CSS_NUMBER = "[-\\\\+]?\\\\d*\\\\.\\\\d+%?";\n\n            // Allow positive/negative integer/number.  Don\'t capture the either/or, just the entire outcome.\n            var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";\n\n            // Actual matching.\n            // Parentheses and commas are optional, but not required.\n            // Whitespace can take the place of commas or opening paren\n            var PERMISSIVE_MATCH3 = "[\\\\s|\\\\(]+(" + CSS_UNIT + ")[,|\\\\s]+(" + CSS_UNIT + ")[,|\\\\s]+(" + CSS_UNIT + ")\\\\s*\\\\)?";\n            var PERMISSIVE_MATCH4 = "[\\\\s|\\\\(]+(" + CSS_UNIT + ")[,|\\\\s]+(" + CSS_UNIT + ")[,|\\\\s]+(" + CSS_UNIT + ")[,|\\\\s]+(" + CSS_UNIT + ")\\\\s*\\\\)?";\n\n            return {\n                rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),\n                rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),\n                hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),\n                hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),\n                hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),\n                hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n                hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n                hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n            };\n        }();\n\n        // `stringInputToObject`\n        // Permissive string parsing.  Take in a number of formats, and output an object\n        // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\n        function stringInputToObject(color) {\n\n            color = color.replace(trimLeft, \'\').replace(trimRight, \'\').toLowerCase();\n            var named = false;\n            if (names[color]) {\n                color = names[color];\n                named = true;\n            } else if (color == \'transparent\') {\n                return { r: 0, g: 0, b: 0, a: 0, format: "name" };\n            }\n\n            // Try to match string input using regular expressions.\n            // Keep most of the number bounding out of this function - don\'t worry about [0,1] or [0,100] or [0,360]\n            // Just return an object and let the conversion functions handle that.\n            // This way the result will be the same whether the tinycolor is initialized with string or object.\n            var match;\n            if (match = matchers.rgb.exec(color)) {\n                return { r: match[1], g: match[2], b: match[3] };\n            }\n            if (match = matchers.rgba.exec(color)) {\n                return { r: match[1], g: match[2], b: match[3], a: match[4] };\n            }\n            if (match = matchers.hsl.exec(color)) {\n                return { h: match[1], s: match[2], l: match[3] };\n            }\n            if (match = matchers.hsla.exec(color)) {\n                return { h: match[1], s: match[2], l: match[3], a: match[4] };\n            }\n            if (match = matchers.hsv.exec(color)) {\n                return { h: match[1], s: match[2], v: match[3] };\n            }\n            if (match = matchers.hex8.exec(color)) {\n                return {\n                    a: convertHexToDecimal(match[1]),\n                    r: parseIntFromHex(match[2]),\n                    g: parseIntFromHex(match[3]),\n                    b: parseIntFromHex(match[4]),\n                    format: named ? "name" : "hex8"\n                };\n            }\n            if (match = matchers.hex6.exec(color)) {\n                return {\n                    r: parseIntFromHex(match[1]),\n                    g: parseIntFromHex(match[2]),\n                    b: parseIntFromHex(match[3]),\n                    format: named ? "name" : "hex"\n                };\n            }\n            if (match = matchers.hex3.exec(color)) {\n                return {\n                    r: parseIntFromHex(match[1] + \'\' + match[1]),\n                    g: parseIntFromHex(match[2] + \'\' + match[2]),\n                    b: parseIntFromHex(match[3] + \'\' + match[3]),\n                    format: named ? "name" : "hex"\n                };\n            }\n\n            return false;\n        }\n\n        window.tinycolor = tinycolor;\n    })();\n\n    $(function () {\n        if ($.fn.spectrum.load) {\n            $.fn.spectrum.processNativeColorInputs();\n        }\n    });\n})(window, jQuery);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvc3BlY3RydW0uanM/MjU0NSJdLCJuYW1lcyI6WyJ3aW5kb3ciLCIkIiwidW5kZWZpbmVkIiwiZGVmYXVsdE9wdHMiLCJiZWZvcmVTaG93Iiwibm9vcCIsIm1vdmUiLCJjaGFuZ2UiLCJzaG93IiwiaGlkZSIsImNvbG9yIiwiZmxhdCIsInNob3dJbnB1dCIsImFsbG93RW1wdHkiLCJzaG93QnV0dG9ucyIsImNsaWNrb3V0RmlyZXNDaGFuZ2UiLCJzaG93SW5pdGlhbCIsInNob3dQYWxldHRlIiwic2hvd1BhbGV0dGVPbmx5IiwiaGlkZUFmdGVyUGFsZXR0ZVNlbGVjdCIsInRvZ2dsZVBhbGV0dGVPbmx5Iiwic2hvd1NlbGVjdGlvblBhbGV0dGUiLCJsb2NhbFN0b3JhZ2VLZXkiLCJhcHBlbmRUbyIsIm1heFNlbGVjdGlvblNpemUiLCJjYW5jZWxUZXh0IiwiY2hvb3NlVGV4dCIsInRvZ2dsZVBhbGV0dGVNb3JlVGV4dCIsInRvZ2dsZVBhbGV0dGVMZXNzVGV4dCIsImNsZWFyVGV4dCIsIm5vQ29sb3JTZWxlY3RlZFRleHQiLCJwcmVmZXJyZWRGb3JtYXQiLCJjbGFzc05hbWUiLCJjb250YWluZXJDbGFzc05hbWUiLCJyZXBsYWNlckNsYXNzTmFtZSIsInNob3dBbHBoYSIsInRoZW1lIiwicGFsZXR0ZSIsInNlbGVjdGlvblBhbGV0dGUiLCJkaXNhYmxlZCIsInNwZWN0cnVtcyIsIklFIiwiZXhlYyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInJnYmFTdXBwb3J0IiwiY29udGFpbnMiLCJzdHIiLCJzdWJzdHIiLCJpbmRleE9mIiwiZWxlbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImJhY2tncm91bmRDb2xvciIsImlucHV0VHlwZUNvbG9yU3VwcG9ydCIsImNvbG9ySW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJyZXBsYWNlSW5wdXQiLCJqb2luIiwibWFya3VwIiwiZ3JhZGllbnRGaXgiLCJpIiwicGFsZXR0ZVRlbXBsYXRlIiwicCIsIm9wdHMiLCJodG1sIiwibGVuZ3RoIiwiY3VycmVudCIsInRpbnkiLCJ0aW55Y29sb3IiLCJjIiwidG9Ic2wiLCJsIiwiZXF1YWxzIiwiZm9ybWF0dGVkU3RyaW5nIiwidG9TdHJpbmciLCJzd2F0Y2hTdHlsZSIsInRvUmdiU3RyaW5nIiwidG9GaWx0ZXIiLCJwdXNoIiwiY2xzIiwiYXBwZW5kIiwiYXR0ciIsImhpZGVBbGwiLCJpbnN0YW5jZU9wdGlvbnMiLCJvIiwiY2FsbGJhY2tDb250ZXh0IiwiZXh0ZW5kIiwiY2FsbGJhY2tzIiwiYmluZCIsInNwZWN0cnVtIiwiZWxlbWVudCIsInJlc2l6ZSIsInRocm90dGxlIiwicmVmbG93IiwidmlzaWJsZSIsImRyYWdXaWR0aCIsImRyYWdIZWlnaHQiLCJkcmFnSGVscGVySGVpZ2h0Iiwic2xpZGVIZWlnaHQiLCJzbGlkZVdpZHRoIiwiYWxwaGFXaWR0aCIsImFscGhhU2xpZGVIZWxwZXJXaWR0aCIsInNsaWRlSGVscGVySGVpZ2h0IiwiY3VycmVudEh1ZSIsImN1cnJlbnRTYXR1cmF0aW9uIiwiY3VycmVudFZhbHVlIiwiY3VycmVudEFscGhhIiwicGFsZXR0ZUFycmF5IiwicGFsZXR0ZUxvb2t1cCIsInNsaWNlIiwiZHJhZ2dpbmdDbGFzcyIsInNoaWZ0TW92ZW1lbnREaXJlY3Rpb24iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiYm9keSIsImJvdW5kRWxlbWVudCIsImNvbnRhaW5lciIsImFkZENsYXNzIiwicGlja2VyQ29udGFpbmVyIiwiZmluZCIsImRyYWdnZXIiLCJkcmFnSGVscGVyIiwic2xpZGVyIiwic2xpZGVIZWxwZXIiLCJhbHBoYVNsaWRlcklubmVyIiwiYWxwaGFTbGlkZXIiLCJhbHBoYVNsaWRlSGVscGVyIiwidGV4dElucHV0IiwicGFsZXR0ZUNvbnRhaW5lciIsImluaXRpYWxDb2xvckNvbnRhaW5lciIsImNhbmNlbEJ1dHRvbiIsImNsZWFyQnV0dG9uIiwiY2hvb3NlQnV0dG9uIiwidG9nZ2xlQnV0dG9uIiwiaXNJbnB1dCIsImlzIiwiaXNJbnB1dFR5cGVDb2xvciIsInNob3VsZFJlcGxhY2UiLCJyZXBsYWNlciIsIm9mZnNldEVsZW1lbnQiLCJwcmV2aWV3RWxlbWVudCIsImluaXRpYWxDb2xvciIsInZhbCIsImNvbG9yT25TaG93IiwiY3VycmVudFByZWZlcnJlZEZvcm1hdCIsImlzRW1wdHkiLCJhcHBseU9wdGlvbnMiLCJ0ZXh0IiwiaXNBcnJheSIsImoiLCJyZ2IiLCJ0b2dnbGVDbGFzcyIsImluaXRpYWxpemUiLCJhZnRlciIsInBhcmVudCIsInVwZGF0ZVNlbGVjdGlvblBhbGV0dGVGcm9tU3RvcmFnZSIsImUiLCJ0b2dnbGUiLCJzdG9wUHJvcGFnYXRpb24iLCJ0YXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImRpc2FibGUiLCJjbGljayIsInNldEZyb21UZXh0SW5wdXQiLCJzZXRUaW1lb3V0Iiwia2V5ZG93biIsImtleUNvZGUiLCJyZXZlcnQiLCJ1cGRhdGVPcmlnaW5hbElucHV0IiwiaXNWYWxpZCIsImNzcyIsIm91dGVyV2lkdGgiLCJkcmFnZ2FibGUiLCJkcmFnWCIsImRyYWdZIiwic2hpZnRLZXkiLCJNYXRoIiwicm91bmQiLCJkcmFnU3RhcnQiLCJkcmFnU3RvcCIsInBhcnNlRmxvYXQiLCJvbGREcmFnWCIsIm9sZERyYWdZIiwiZnVydGhlckZyb21YIiwiYWJzIiwic2V0U2F0dXJhdGlvbiIsInNldFZhbHVlIiwic2V0IiwidXBkYXRlVUkiLCJmb3JtYXQiLCJhZGRDb2xvclRvU2VsZWN0aW9uUGFsZXR0ZSIsInBhbGV0dGVFbGVtZW50Q2xpY2siLCJkYXRhIiwiaWdub3JlIiwiY2xvc2VzdCIsInBhbGV0dGVFdmVudCIsImRlbGVnYXRlIiwibG9jYWxTdG9yYWdlIiwib2xkUGFsZXR0ZSIsInNwbGl0IiwiZWFjaCIsImluQXJyYXkiLCJzaGlmdCIsImdldFVuaXF1ZVNlbGVjdGlvblBhbGV0dGUiLCJ1bmlxdWUiLCJyZXZlcnNlIiwiZHJhd1BhbGV0dGUiLCJjdXJyZW50Q29sb3IiLCJnZXQiLCJtYXAiLCJkcmF3SW5pdGlhbCIsImluaXRpYWwiLCJ0cmlnZ2VyIiwicmVtb3ZlQ2xhc3MiLCJldmVudCIsIkV2ZW50IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiY2xpY2tvdXQiLCJidXR0b24iLCJ1bmJpbmQiLCJpZ25vcmVGb3JtYXRDaGFuZ2UiLCJuZXdDb2xvciIsIm5ld0hzdiIsInRvSHN2IiwiaCIsInMiLCJ2IiwiYSIsImdldEZvcm1hdCIsImZyb21SYXRpbyIsImhhc0NsYXNzIiwidXBkYXRlSGVscGVyTG9jYXRpb25zIiwiZmxhdENvbG9yIiwidG9IZXhTdHJpbmciLCJyZWFsQ29sb3IiLCJkaXNwbGF5Q29sb3IiLCJyZWFsSGV4IiwicmVhbFJnYiIsImFscGhhIiwidG9SZ2IiLCJyZWFsQWxwaGEiLCJncmFkaWVudCIsImdyYWRpZW50VHlwZSIsIm1heCIsIm1pbiIsImFscGhhWCIsInNsaWRlWSIsImZpcmVDYWxsYmFjayIsImhhc0NoYW5nZWQiLCJ3aWR0aCIsImhlaWdodCIsIm9mZnNldCIsImdldE9mZnNldCIsImRlc3Ryb3kiLCJyZW1vdmUiLCJzcGVjdCIsImlkIiwib3B0aW9uIiwib3B0aW9uTmFtZSIsIm9wdGlvblZhbHVlIiwiZW5hYmxlIiwicGlja2VyIiwiaW5wdXQiLCJleHRyYVkiLCJkcFdpZHRoIiwiZHBIZWlnaHQiLCJvdXRlckhlaWdodCIsImlucHV0SGVpZ2h0IiwiZG9jRWxlbSIsImRvY3VtZW50RWxlbWVudCIsInZpZXdXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsTGVmdCIsInZpZXdIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxUb3AiLCJ0b3AiLCJsZWZ0IiwiZnVuYyIsIm9iaiIsIkFycmF5IiwicHJvdG90eXBlIiwiYXJncyIsImNhbGwiLCJhcmd1bWVudHMiLCJhcHBseSIsImNvbmNhdCIsIm9ubW92ZSIsIm9uc3RhcnQiLCJvbnN0b3AiLCJkcmFnZ2luZyIsIm1heEhlaWdodCIsIm1heFdpZHRoIiwiaGFzVG91Y2giLCJkdXJpbmdEcmFnRXZlbnRzIiwicHJldmVudCIsInN0b3AiLCJyZXR1cm5WYWx1ZSIsImRvY3VtZW50TW9kZSIsInRvdWNoZXMiLCJvcmlnaW5hbEV2ZW50IiwicGFnZVgiLCJwYWdlWSIsInN0YXJ0IiwicmlnaHRjbGljayIsIndoaWNoIiwid2FpdCIsImRlYm91bmNlIiwidGltZW91dCIsImNvbnRleHQiLCJ0aHJvdHRsZXIiLCJjbGVhclRpbWVvdXQiLCJkYXRhSUQiLCJmbiIsImV4dHJhIiwibWV0aG9kIiwiRXJyb3IiLCJyZW1vdmVEYXRhIiwib3B0aW9ucyIsImxvYWQiLCJsb2FkT3B0cyIsImRlZmF1bHRzIiwibG9jYWxpemF0aW9uIiwicGFsZXR0ZXMiLCJwcm9jZXNzTmF0aXZlQ29sb3JJbnB1dHMiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsInRpbnlDb3VudGVyIiwibWF0aCIsIm1hdGhSb3VuZCIsIm1hdGhNaW4iLCJtYXRoTWF4IiwibWF0aFJhbmRvbSIsInJhbmRvbSIsImlucHV0VG9SR0IiLCJfciIsInIiLCJfZyIsImciLCJfYiIsImIiLCJfYSIsIl9yb3VuZEEiLCJfZm9ybWF0IiwiX2dyYWRpZW50VHlwZSIsIl9vayIsIm9rIiwiX3RjX2lkIiwiaXNEYXJrIiwiZ2V0QnJpZ2h0bmVzcyIsImlzTGlnaHQiLCJnZXRBbHBoYSIsInNldEFscGhhIiwiYm91bmRBbHBoYSIsImhzdiIsInJnYlRvSHN2IiwidG9Ic3ZTdHJpbmciLCJoc2wiLCJyZ2JUb0hzbCIsInRvSHNsU3RyaW5nIiwidG9IZXgiLCJhbGxvdzNDaGFyIiwicmdiVG9IZXgiLCJ0b0hleDgiLCJyZ2JhVG9IZXgiLCJ0b0hleDhTdHJpbmciLCJ0b1BlcmNlbnRhZ2VSZ2IiLCJib3VuZDAxIiwidG9QZXJjZW50YWdlUmdiU3RyaW5nIiwidG9OYW1lIiwiaGV4TmFtZXMiLCJzZWNvbmRDb2xvciIsImhleDhTdHJpbmciLCJzZWNvbmRIZXg4U3RyaW5nIiwiZm9ybWF0U2V0IiwiaGFzQWxwaGEiLCJuZWVkc0FscGhhRm9ybWF0IiwiX2FwcGx5TW9kaWZpY2F0aW9uIiwibGlnaHRlbiIsImJyaWdodGVuIiwiZGFya2VuIiwiZGVzYXR1cmF0ZSIsInNhdHVyYXRlIiwiZ3JleXNjYWxlIiwic3BpbiIsIl9hcHBseUNvbWJpbmF0aW9uIiwiYW5hbG9nb3VzIiwiY29tcGxlbWVudCIsIm1vbm9jaHJvbWF0aWMiLCJzcGxpdGNvbXBsZW1lbnQiLCJ0cmlhZCIsInRldHJhZCIsImhhc093blByb3BlcnR5IiwiY29udmVydFRvUGVyY2VudGFnZSIsInN0cmluZ0lucHV0VG9PYmplY3QiLCJyZ2JUb1JnYiIsIlN0cmluZyIsImhzdlRvUmdiIiwiaHNsVG9SZ2IiLCJkIiwiaHVlMnJnYiIsInEiLCJ0IiwiZmxvb3IiLCJmIiwibW9kIiwiaGV4IiwicGFkMiIsImNoYXJBdCIsImNvbnZlcnREZWNpbWFsVG9IZXgiLCJjb2xvcjEiLCJjb2xvcjIiLCJhbW91bnQiLCJjbGFtcDAxIiwiaHVlIiwicmVzdWx0cyIsInNsaWNlcyIsInBhcnQiLCJyZXQiLCJtb2RpZmljYXRpb24iLCJtaXgiLCJyZ2IxIiwicmdiMiIsInciLCJ3MSIsIncyIiwicmdiYSIsInJlYWRhYmlsaXR5IiwiYzEiLCJjMiIsImJyaWdodG5lc3NBIiwiYnJpZ2h0bmVzc0IiLCJjb2xvckRpZmYiLCJicmlnaHRuZXNzIiwiaXNSZWFkYWJsZSIsIm1vc3RSZWFkYWJsZSIsImJhc2VDb2xvciIsImNvbG9yTGlzdCIsImJlc3RDb2xvciIsImJlc3RTY29yZSIsImJlc3RJc1JlYWRhYmxlIiwicmVhZGFibGUiLCJzY29yZSIsIm5hbWVzIiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJidXJudHNpZW5uYSIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGFuIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwiZmxpcCIsImZsaXBwZWQiLCJpc05hTiIsIm4iLCJpc09uZVBvaW50WmVybyIsInByb2Nlc3NQZXJjZW50IiwiaXNQZXJjZW50YWdlIiwicGFyc2VJbnQiLCJwYXJzZUludEZyb21IZXgiLCJjb252ZXJ0SGV4VG9EZWNpbWFsIiwibWF0Y2hlcnMiLCJDU1NfSU5URUdFUiIsIkNTU19OVU1CRVIiLCJDU1NfVU5JVCIsIlBFUk1JU1NJVkVfTUFUQ0gzIiwiUEVSTUlTU0lWRV9NQVRDSDQiLCJSZWdFeHAiLCJoc2xhIiwiaGV4MyIsImhleDYiLCJoZXg4IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwibmFtZWQiLCJtYXRjaCIsImpRdWVyeSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsVUFBVUEsTUFBVixFQUFrQkMsQ0FBbEIsRUFBcUJDLFNBQXJCLEVBQWdDO0FBQzdCOztBQUVBLFFBQUlDLGNBQWM7O0FBRWQ7QUFDQUMsb0JBQVlDLElBSEU7QUFJZEMsY0FBTUQsSUFKUTtBQUtkRSxnQkFBUUYsSUFMTTtBQU1kRyxjQUFNSCxJQU5RO0FBT2RJLGNBQU1KLElBUFE7O0FBU2Q7QUFDQUssZUFBTyxLQVZPO0FBV2RDLGNBQU0sS0FYUTtBQVlkQyxtQkFBVyxLQVpHO0FBYWRDLG9CQUFZLEtBYkU7QUFjZEMscUJBQWEsSUFkQztBQWVkQyw2QkFBcUIsS0FmUDtBQWdCZEMscUJBQWEsS0FoQkM7QUFpQmRDLHFCQUFhLEtBakJDO0FBa0JkQyx5QkFBaUIsS0FsQkg7QUFtQmRDLGdDQUF3QixLQW5CVjtBQW9CZEMsMkJBQW1CLEtBcEJMO0FBcUJkQyw4QkFBc0IsSUFyQlI7QUFzQmRDLHlCQUFpQixLQXRCSDtBQXVCZEMsa0JBQVUsTUF2Qkk7QUF3QmRDLDBCQUFrQixDQXhCSjtBQXlCZEMsb0JBQVksUUF6QkU7QUEwQmRDLG9CQUFZLFFBMUJFO0FBMkJkQywrQkFBdUIsTUEzQlQ7QUE0QmRDLCtCQUF1QixNQTVCVDtBQTZCZEMsbUJBQVcsdUJBN0JHO0FBOEJkQyw2QkFBcUIsbUJBOUJQO0FBK0JkQyx5QkFBaUIsS0EvQkg7QUFnQ2RDLG1CQUFXLEVBaENHLEVBZ0NDO0FBQ2ZDLDRCQUFvQixFQWpDTjtBQWtDZEMsMkJBQW1CLEVBbENMO0FBbUNkQyxtQkFBVyxLQW5DRztBQW9DZEMsZUFBTyxVQXBDTztBQXFDZEMsaUJBQVMsQ0FBQyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLEVBQWtDLFNB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LEVBQVgsR0FBZ0JBLE1BQU0sQ0FBTixDQUFoQyxDQURBO0FBRUh0Uix1QkFBR3NRLGdCQUFnQmdCLE1BQU0sQ0FBTixJQUFXLEVBQVgsR0FBZ0JBLE1BQU0sQ0FBTixDQUFoQyxDQUZBO0FBR0hwUix1QkFBR29RLGdCQUFnQmdCLE1BQU0sQ0FBTixJQUFXLEVBQVgsR0FBZ0JBLE1BQU0sQ0FBTixDQUFoQyxDQUhBO0FBSUgzYSw0QkFBUTBhLFFBQVEsTUFBUixHQUFpQjtBQUp0QixpQkFBUDtBQU1IOztBQUVELG1CQUFPLEtBQVA7QUFDSDs7QUFFRDNtQixlQUFPd0UsU0FBUCxHQUFtQkEsU0FBbkI7QUFDQyxLQWxrQ0Q7O0FBcWtDQXZFLE1BQUUsWUFBWTtBQUNWLFlBQUlBLEVBQUU0VCxFQUFGLENBQUtoTyxRQUFMLENBQWNzTyxJQUFsQixFQUF3QjtBQUNwQmxVLGNBQUU0VCxFQUFGLENBQUtoTyxRQUFMLENBQWMyTyx3QkFBZDtBQUNIO0FBQ0osS0FKRDtBQU1ILENBenNFRCxFQXlzRUd4VSxNQXpzRUgsRUF5c0VXNm1CLE1BenNFWCxFIiwiZmlsZSI6IjE0Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFNwZWN0cnVtIENvbG9ycGlja2VyIHYxLjUuMVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jncmlucy9zcGVjdHJ1bVxuLy8gQXV0aG9yOiBCcmlhbiBHcmluc3RlYWRcbi8vIExpY2Vuc2U6IE1JVFxuXG4oZnVuY3Rpb24gKHdpbmRvdywgJCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZGVmYXVsdE9wdHMgPSB7XG5cbiAgICAgICAgLy8gQ2FsbGJhY2tzXG4gICAgICAgIGJlZm9yZVNob3c6IG5vb3AsXG4gICAgICAgIG1vdmU6IG5vb3AsXG4gICAgICAgIGNoYW5nZTogbm9vcCxcbiAgICAgICAgc2hvdzogbm9vcCxcbiAgICAgICAgaGlkZTogbm9vcCxcblxuICAgICAgICAvLyBPcHRpb25zXG4gICAgICAgIGNvbG9yOiBmYWxzZSxcbiAgICAgICAgZmxhdDogZmFsc2UsXG4gICAgICAgIHNob3dJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsbG93RW1wdHk6IGZhbHNlLFxuICAgICAgICBzaG93QnV0dG9uczogdHJ1ZSxcbiAgICAgICAgY2xpY2tvdXRGaXJlc0NoYW5nZTogZmFsc2UsXG4gICAgICAgIHNob3dJbml0aWFsOiBmYWxzZSxcbiAgICAgICAgc2hvd1BhbGV0dGU6IGZhbHNlLFxuICAgICAgICBzaG93UGFsZXR0ZU9ubHk6IGZhbHNlLFxuICAgICAgICBoaWRlQWZ0ZXJQYWxldHRlU2VsZWN0OiBmYWxzZSxcbiAgICAgICAgdG9nZ2xlUGFsZXR0ZU9ubHk6IGZhbHNlLFxuICAgICAgICBzaG93U2VsZWN0aW9uUGFsZXR0ZTogdHJ1ZSxcbiAgICAgICAgbG9jYWxTdG9yYWdlS2V5OiBmYWxzZSxcbiAgICAgICAgYXBwZW5kVG86IFwiYm9keVwiLFxuICAgICAgICBtYXhTZWxlY3Rpb25TaXplOiA3LFxuICAgICAgICBjYW5jZWxUZXh0OiBcImNhbmNlbFwiLFxuICAgICAgICBjaG9vc2VUZXh0OiBcImNob29zZVwiLFxuICAgICAgICB0b2dnbGVQYWxldHRlTW9yZVRleHQ6IFwibW9yZVwiLFxuICAgICAgICB0b2dnbGVQYWxldHRlTGVzc1RleHQ6IFwibGVzc1wiLFxuICAgICAgICBjbGVhclRleHQ6IFwiQ2xlYXIgQ29sb3IgU2VsZWN0aW9uXCIsXG4gICAgICAgIG5vQ29sb3JTZWxlY3RlZFRleHQ6IFwiTm8gQ29sb3IgU2VsZWN0ZWRcIixcbiAgICAgICAgcHJlZmVycmVkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgY2xhc3NOYW1lOiBcIlwiLCAvLyBEZXByZWNhdGVkIC0gdXNlIGNvbnRhaW5lckNsYXNzTmFtZSBhbmQgcmVwbGFjZXJDbGFzc05hbWUgaW5zdGVhZC5cbiAgICAgICAgY29udGFpbmVyQ2xhc3NOYW1lOiBcIlwiLFxuICAgICAgICByZXBsYWNlckNsYXNzTmFtZTogXCJcIixcbiAgICAgICAgc2hvd0FscGhhOiBmYWxzZSxcbiAgICAgICAgdGhlbWU6IFwic3AtbGlnaHRcIixcbiAgICAgICAgcGFsZXR0ZTogW1tcIiNmZmZmZmZcIiwgXCIjMDAwMDAwXCIsIFwiI2ZmMDAwMFwiLCBcIiNmZjgwMDBcIiwgXCIjZmZmZjAwXCIsIFwiIzAwODAwMFwiLCBcIiMwMDAwZmZcIiwgXCIjNGIwMDgyXCIsIFwiIzk0MDBkM1wiXV0sXG4gICAgICAgIHNlbGVjdGlvblBhbGV0dGU6IFtdLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2VcbiAgICB9LFxuICAgIHNwZWN0cnVtcyA9IFtdLFxuICAgIElFID0gISEvbXNpZS9pLmV4ZWMoIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50ICksXG4gICAgcmdiYVN1cHBvcnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zKCBzdHIsIHN1YnN0ciApIHtcbiAgICAgICAgICAgIHJldHVybiAhIX4oJycgKyBzdHIpLmluZGV4T2Yoc3Vic3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHZhciBzdHlsZSA9IGVsZW0uc3R5bGU7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSAnYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC41KSc7XG4gICAgICAgIHJldHVybiBjb250YWlucyhzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsICdyZ2JhJykgfHwgY29udGFpbnMoc3R5bGUuYmFja2dyb3VuZENvbG9yLCAnaHNsYScpO1xuICAgIH0pKCksXG4gICAgaW5wdXRUeXBlQ29sb3JTdXBwb3J0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sb3JJbnB1dCA9ICQoXCI8aW5wdXQgdHlwZT0nY29sb3InIHZhbHVlPSchJyAvPlwiKVswXTtcbiAgICAgICAgcmV0dXJuIGNvbG9ySW5wdXQudHlwZSA9PT0gXCJjb2xvclwiICYmIGNvbG9ySW5wdXQudmFsdWUgIT09IFwiIVwiO1xuICAgIH0pKCksXG4gICAgcmVwbGFjZUlucHV0ID0gW1xuICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLXJlcGxhY2VyJz5cIixcbiAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtcHJldmlldyc+PGRpdiBjbGFzcz0nc3AtcHJldmlldy1pbm5lcic+PC9kaXY+PC9kaXY+XCIsXG4gICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLWRkJz4mIzk2NjA7PC9kaXY+XCIsXG4gICAgICAgIFwiPC9kaXY+XCJcbiAgICBdLmpvaW4oJycpLFxuICAgIG1hcmt1cCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLy8gSUUgZG9lcyBub3Qgc3VwcG9ydCBncmFkaWVudHMgd2l0aCBtdWx0aXBsZSBzdG9wcywgc28gd2UgbmVlZCB0byBzaW11bGF0ZVxuICAgICAgICAvLyAgdGhhdCBmb3IgdGhlIHJhaW5ib3cgc2xpZGVyIHdpdGggOCBkaXZzIHRoYXQgZWFjaCBoYXZlIGEgc2luZ2xlIGdyYWRpZW50XG4gICAgICAgIHZhciBncmFkaWVudEZpeCA9IFwiXCI7XG4gICAgICAgIGlmIChJRSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRGaXggKz0gXCI8ZGl2IGNsYXNzPSdzcC1cIiArIGkgKyBcIic+PC9kaXY+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzcC1jb250YWluZXIgc3AtaGlkZGVuJz5cIixcbiAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLXBhbGV0dGUtY29udGFpbmVyJz5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzcC1wYWxldHRlIHNwLXRodW1iIHNwLWNmJz48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzcC1wYWxldHRlLWJ1dHRvbi1jb250YWluZXIgc3AtY2YnPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3NwLXBhbGV0dGUtdG9nZ2xlJz48L2J1dHRvbj5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtcGlja2VyLWNvbnRhaW5lcic+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtdG9wIHNwLWNmJz5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtZmlsbCc+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLXRvcC1pbm5lcic+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzcC1jb2xvcic+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3Atc2F0Jz5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtdmFsJz5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLWRyYWdnZXInPjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtY2xlYXIgc3AtY2xlYXItZGlzcGxheSc+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLWh1ZSc+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3Atc2xpZGVyJz48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRGaXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9J3NwLWFscGhhJz48ZGl2IGNsYXNzPSdzcC1hbHBoYS1pbm5lcic+PGRpdiBjbGFzcz0nc3AtYWxwaGEtaGFuZGxlJz48L2Rpdj48L2Rpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdzcC1pbnB1dC1jb250YWluZXIgc3AtY2YnPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8aW5wdXQgY2xhc3M9J3NwLWlucHV0JyB0eXBlPSd0ZXh0JyBzcGVsbGNoZWNrPSdmYWxzZScgIC8+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtaW5pdGlhbCBzcC10aHVtYiBzcC1jZic+PC9kaXY+XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiPGRpdiBjbGFzcz0nc3AtYnV0dG9uLWNvbnRhaW5lciBzcC1jZic+XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxhIGNsYXNzPSdzcC1jYW5jZWwnIGhyZWY9JyMnPjwvYT5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSdzcC1jaG9vc2UnPjwvYnV0dG9uPlwiLFxuICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiLFxuICAgICAgICAgICAgICAgIFwiPC9kaXY+XCIsXG4gICAgICAgICAgICBcIjwvZGl2PlwiXG4gICAgICAgIF0uam9pbihcIlwiKTtcbiAgICB9KSgpO1xuXG4gICAgZnVuY3Rpb24gcGFsZXR0ZVRlbXBsYXRlIChwLCBjb2xvciwgY2xhc3NOYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBodG1sID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBwW2ldO1xuICAgICAgICAgICAgaWYoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW55ID0gdGlueWNvbG9yKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGlueS50b0hzbCgpLmwgPCAwLjUgPyBcInNwLXRodW1iLWVsIHNwLXRodW1iLWRhcmtcIiA6IFwic3AtdGh1bWItZWwgc3AtdGh1bWItbGlnaHRcIjtcbiAgICAgICAgICAgICAgICBjICs9ICh0aW55Y29sb3IuZXF1YWxzKGNvbG9yLCBjdXJyZW50KSkgPyBcIiBzcC10aHVtYi1hY3RpdmVcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFN0cmluZyA9IHRpbnkudG9TdHJpbmcob3B0cy5wcmVmZXJyZWRGb3JtYXQgfHwgXCJyZ2JcIik7XG4gICAgICAgICAgICAgICAgdmFyIHN3YXRjaFN0eWxlID0gcmdiYVN1cHBvcnQgPyAoXCJiYWNrZ3JvdW5kLWNvbG9yOlwiICsgdGlueS50b1JnYlN0cmluZygpKSA6IFwiZmlsdGVyOlwiICsgdGlueS50b0ZpbHRlcigpO1xuICAgICAgICAgICAgICAgIGh0bWwucHVzaCgnPHNwYW4gdGl0bGU9XCInICsgZm9ybWF0dGVkU3RyaW5nICsgJ1wiIGRhdGEtY29sb3I9XCInICsgdGlueS50b1JnYlN0cmluZygpICsgJ1wiIGNsYXNzPVwiJyArIGMgKyAnXCI+PHNwYW4gY2xhc3M9XCJzcC10aHVtYi1pbm5lclwiIHN0eWxlPVwiJyArIHN3YXRjaFN0eWxlICsgJztcIiAvPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNscyA9ICdzcC1jbGVhci1kaXNwbGF5JztcbiAgICAgICAgICAgICAgICBodG1sLnB1c2goJCgnPGRpdiAvPicpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHNwYW4gZGF0YS1jb2xvcj1cIlwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtcIiBjbGFzcz1cIicgKyBjbHMgKyAnXCI+PC9zcGFuPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCBvcHRzLm5vQ29sb3JTZWxlY3RlZFRleHQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmh0bWwoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiPGRpdiBjbGFzcz0nc3AtY2YgXCIgKyBjbGFzc05hbWUgKyBcIic+XCIgKyBodG1sLmpvaW4oJycpICsgXCI8L2Rpdj5cIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWRlQWxsKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWN0cnVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNwZWN0cnVtc1tpXSkge1xuICAgICAgICAgICAgICAgIHNwZWN0cnVtc1tpXS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YW5jZU9wdGlvbnMobywgY2FsbGJhY2tDb250ZXh0KSB7XG4gICAgICAgIHZhciBvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRPcHRzLCBvKTtcbiAgICAgICAgb3B0cy5jYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAnbW92ZSc6IGJpbmQob3B0cy5tb3ZlLCBjYWxsYmFja0NvbnRleHQpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IGJpbmQob3B0cy5jaGFuZ2UsIGNhbGxiYWNrQ29udGV4dCksXG4gICAgICAgICAgICAnc2hvdyc6IGJpbmQob3B0cy5zaG93LCBjYWxsYmFja0NvbnRleHQpLFxuICAgICAgICAgICAgJ2hpZGUnOiBiaW5kKG9wdHMuaGlkZSwgY2FsbGJhY2tDb250ZXh0KSxcbiAgICAgICAgICAgICdiZWZvcmVTaG93JzogYmluZChvcHRzLmJlZm9yZVNob3csIGNhbGxiYWNrQ29udGV4dClcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGVjdHJ1bShlbGVtZW50LCBvKSB7XG5cbiAgICAgICAgdmFyIG9wdHMgPSBpbnN0YW5jZU9wdGlvbnMobywgZWxlbWVudCksXG4gICAgICAgICAgICBmbGF0ID0gb3B0cy5mbGF0LFxuICAgICAgICAgICAgc2hvd1NlbGVjdGlvblBhbGV0dGUgPSBvcHRzLnNob3dTZWxlY3Rpb25QYWxldHRlLFxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlS2V5ID0gb3B0cy5sb2NhbFN0b3JhZ2VLZXksXG4gICAgICAgICAgICB0aGVtZSA9IG9wdHMudGhlbWUsXG4gICAgICAgICAgICBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIHJlc2l6ZSA9IHRocm90dGxlKHJlZmxvdywgMTApLFxuICAgICAgICAgICAgdmlzaWJsZSA9IGZhbHNlLFxuICAgICAgICAgICAgZHJhZ1dpZHRoID0gMCxcbiAgICAgICAgICAgIGRyYWdIZWlnaHQgPSAwLFxuICAgICAgICAgICAgZHJhZ0hlbHBlckhlaWdodCA9IDAsXG4gICAgICAgICAgICBzbGlkZUhlaWdodCA9IDAsXG4gICAgICAgICAgICBzbGlkZVdpZHRoID0gMCxcbiAgICAgICAgICAgIGFscGhhV2lkdGggPSAwLFxuICAgICAgICAgICAgYWxwaGFTbGlkZUhlbHBlcldpZHRoID0gMCxcbiAgICAgICAgICAgIHNsaWRlSGVscGVySGVpZ2h0ID0gMCxcbiAgICAgICAgICAgIGN1cnJlbnRIdWUgPSAwLFxuICAgICAgICAgICAgY3VycmVudFNhdHVyYXRpb24gPSAwLFxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gMCxcbiAgICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IDEsXG4gICAgICAgICAgICBwYWxldHRlID0gW10sXG4gICAgICAgICAgICBwYWxldHRlQXJyYXkgPSBbXSxcbiAgICAgICAgICAgIHBhbGV0dGVMb29rdXAgPSB7fSxcbiAgICAgICAgICAgIHNlbGVjdGlvblBhbGV0dGUgPSBvcHRzLnNlbGVjdGlvblBhbGV0dGUuc2xpY2UoMCksXG4gICAgICAgICAgICBtYXhTZWxlY3Rpb25TaXplID0gb3B0cy5tYXhTZWxlY3Rpb25TaXplLFxuICAgICAgICAgICAgZHJhZ2dpbmdDbGFzcyA9IFwic3AtZHJhZ2dpbmdcIixcbiAgICAgICAgICAgIHNoaWZ0TW92ZW1lbnREaXJlY3Rpb24gPSBudWxsO1xuXG4gICAgICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBib2R5ID0gZG9jLmJvZHksXG4gICAgICAgICAgICBib3VuZEVsZW1lbnQgPSAkKGVsZW1lbnQpLFxuICAgICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICQobWFya3VwLCBkb2MpLmFkZENsYXNzKHRoZW1lKSxcbiAgICAgICAgICAgIHBpY2tlckNvbnRhaW5lciA9IGNvbnRhaW5lci5maW5kKFwiLnNwLXBpY2tlci1jb250YWluZXJcIiksXG4gICAgICAgICAgICBkcmFnZ2VyID0gY29udGFpbmVyLmZpbmQoXCIuc3AtY29sb3JcIiksXG4gICAgICAgICAgICBkcmFnSGVscGVyID0gY29udGFpbmVyLmZpbmQoXCIuc3AtZHJhZ2dlclwiKSxcbiAgICAgICAgICAgIHNsaWRlciA9IGNvbnRhaW5lci5maW5kKFwiLnNwLWh1ZVwiKSxcbiAgICAgICAgICAgIHNsaWRlSGVscGVyID0gY29udGFpbmVyLmZpbmQoXCIuc3Atc2xpZGVyXCIpLFxuICAgICAgICAgICAgYWxwaGFTbGlkZXJJbm5lciA9IGNvbnRhaW5lci5maW5kKFwiLnNwLWFscGhhLWlubmVyXCIpLFxuICAgICAgICAgICAgYWxwaGFTbGlkZXIgPSBjb250YWluZXIuZmluZChcIi5zcC1hbHBoYVwiKSxcbiAgICAgICAgICAgIGFscGhhU2xpZGVIZWxwZXIgPSBjb250YWluZXIuZmluZChcIi5zcC1hbHBoYS1oYW5kbGVcIiksXG4gICAgICAgICAgICB0ZXh0SW5wdXQgPSBjb250YWluZXIuZmluZChcIi5zcC1pbnB1dFwiKSxcbiAgICAgICAgICAgIHBhbGV0dGVDb250YWluZXIgPSBjb250YWluZXIuZmluZChcIi5zcC1wYWxldHRlXCIpLFxuICAgICAgICAgICAgaW5pdGlhbENvbG9yQ29udGFpbmVyID0gY29udGFpbmVyLmZpbmQoXCIuc3AtaW5pdGlhbFwiKSxcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbiA9IGNvbnRhaW5lci5maW5kKFwiLnNwLWNhbmNlbFwiKSxcbiAgICAgICAgICAgIGNsZWFyQnV0dG9uID0gY29udGFpbmVyLmZpbmQoXCIuc3AtY2xlYXJcIiksXG4gICAgICAgICAgICBjaG9vc2VCdXR0b24gPSBjb250YWluZXIuZmluZChcIi5zcC1jaG9vc2VcIiksXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24gPSBjb250YWluZXIuZmluZChcIi5zcC1wYWxldHRlLXRvZ2dsZVwiKSxcbiAgICAgICAgICAgIGlzSW5wdXQgPSBib3VuZEVsZW1lbnQuaXMoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIGlzSW5wdXRUeXBlQ29sb3IgPSBpc0lucHV0ICYmIGlucHV0VHlwZUNvbG9yU3VwcG9ydCAmJiBib3VuZEVsZW1lbnQuYXR0cihcInR5cGVcIikgPT09IFwiY29sb3JcIixcbiAgICAgICAgICAgIHNob3VsZFJlcGxhY2UgPSBpc0lucHV0ICYmICFmbGF0LFxuICAgICAgICAgICAgcmVwbGFjZXIgPSAoc2hvdWxkUmVwbGFjZSkgPyAkKHJlcGxhY2VJbnB1dCkuYWRkQ2xhc3ModGhlbWUpLmFkZENsYXNzKG9wdHMuY2xhc3NOYW1lKS5hZGRDbGFzcyhvcHRzLnJlcGxhY2VyQ2xhc3NOYW1lKSA6ICQoW10pLFxuICAgICAgICAgICAgb2Zmc2V0RWxlbWVudCA9IChzaG91bGRSZXBsYWNlKSA/IHJlcGxhY2VyIDogYm91bmRFbGVtZW50LFxuICAgICAgICAgICAgcHJldmlld0VsZW1lbnQgPSByZXBsYWNlci5maW5kKFwiLnNwLXByZXZpZXctaW5uZXJcIiksXG4gICAgICAgICAgICBpbml0aWFsQ29sb3IgPSBvcHRzLmNvbG9yIHx8IChpc0lucHV0ICYmIGJvdW5kRWxlbWVudC52YWwoKSksXG4gICAgICAgICAgICBjb2xvck9uU2hvdyA9IGZhbHNlLFxuICAgICAgICAgICAgcHJlZmVycmVkRm9ybWF0ID0gb3B0cy5wcmVmZXJyZWRGb3JtYXQsXG4gICAgICAgICAgICBjdXJyZW50UHJlZmVycmVkRm9ybWF0ID0gcHJlZmVycmVkRm9ybWF0LFxuICAgICAgICAgICAgY2xpY2tvdXRGaXJlc0NoYW5nZSA9ICFvcHRzLnNob3dCdXR0b25zIHx8IG9wdHMuY2xpY2tvdXRGaXJlc0NoYW5nZSxcbiAgICAgICAgICAgIGlzRW1wdHkgPSAhaW5pdGlhbENvbG9yLFxuICAgICAgICAgICAgYWxsb3dFbXB0eSA9IG9wdHMuYWxsb3dFbXB0eSAmJiAhaXNJbnB1dFR5cGVDb2xvcjtcblxuICAgICAgICBmdW5jdGlvbiBhcHBseU9wdGlvbnMoKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLnNob3dQYWxldHRlT25seSkge1xuICAgICAgICAgICAgICAgIG9wdHMuc2hvd1BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b2dnbGVCdXR0b24udGV4dChvcHRzLnNob3dQYWxldHRlT25seSA/IG9wdHMudG9nZ2xlUGFsZXR0ZU1vcmVUZXh0IDogb3B0cy50b2dnbGVQYWxldHRlTGVzc1RleHQpO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5wYWxldHRlKSB7XG4gICAgICAgICAgICAgICAgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICBwYWxldHRlQXJyYXkgPSAkLmlzQXJyYXkocGFsZXR0ZVswXSkgPyBwYWxldHRlIDogW3BhbGV0dGVdO1xuICAgICAgICAgICAgICAgIHBhbGV0dGVMb29rdXAgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhbGV0dGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhbGV0dGVBcnJheVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJnYiA9IHRpbnljb2xvcihwYWxldHRlQXJyYXlbaV1bal0pLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWxldHRlTG9va3VwW3JnYl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIudG9nZ2xlQ2xhc3MoXCJzcC1mbGF0XCIsIGZsYXQpO1xuICAgICAgICAgICAgY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwic3AtaW5wdXQtZGlzYWJsZWRcIiwgIW9wdHMuc2hvd0lucHV0KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci50b2dnbGVDbGFzcyhcInNwLWFscGhhLWVuYWJsZWRcIiwgb3B0cy5zaG93QWxwaGEpO1xuICAgICAgICAgICAgY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwic3AtY2xlYXItZW5hYmxlZFwiLCBhbGxvd0VtcHR5KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci50b2dnbGVDbGFzcyhcInNwLWJ1dHRvbnMtZGlzYWJsZWRcIiwgIW9wdHMuc2hvd0J1dHRvbnMpO1xuICAgICAgICAgICAgY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwic3AtcGFsZXR0ZS1idXR0b25zLWRpc2FibGVkXCIsICFvcHRzLnRvZ2dsZVBhbGV0dGVPbmx5KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci50b2dnbGVDbGFzcyhcInNwLXBhbGV0dGUtZGlzYWJsZWRcIiwgIW9wdHMuc2hvd1BhbGV0dGUpO1xuICAgICAgICAgICAgY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwic3AtcGFsZXR0ZS1vbmx5XCIsIG9wdHMuc2hvd1BhbGV0dGVPbmx5KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci50b2dnbGVDbGFzcyhcInNwLWluaXRpYWwtZGlzYWJsZWRcIiwgIW9wdHMuc2hvd0luaXRpYWwpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKG9wdHMuY2xhc3NOYW1lKS5hZGRDbGFzcyhvcHRzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIHJlZmxvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcblxuICAgICAgICAgICAgaWYgKElFKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmZpbmQoXCIqOm5vdChpbnB1dClcIikuYXR0cihcInVuc2VsZWN0YWJsZVwiLCBcIm9uXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcHBseU9wdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZFJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnQuYWZ0ZXIocmVwbGFjZXIpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJCdXR0b24uaGlkZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmxhdCkge1xuICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudC5hZnRlcihjb250YWluZXIpLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFwcGVuZFRvID0gb3B0cy5hcHBlbmRUbyA9PT0gXCJwYXJlbnRcIiA/IGJvdW5kRWxlbWVudC5wYXJlbnQoKSA6ICQob3B0cy5hcHBlbmRUbyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGVuZFRvLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRUbyA9ICQoXCJib2R5XCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFwcGVuZFRvLmFwcGVuZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb25QYWxldHRlRnJvbVN0b3JhZ2UoKTtcblxuICAgICAgICAgICAgb2Zmc2V0RWxlbWVudC5iaW5kKFwiY2xpY2suc3BlY3RydW0gdG91Y2hzdGFydC5zcGVjdHJ1bVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmICghJChlLnRhcmdldCkuaXMoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKGJvdW5kRWxlbWVudC5pcyhcIjpkaXNhYmxlZFwiKSB8fCAob3B0cy5kaXNhYmxlZCA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGZyb20gYnViYmxpbmcgdXAgdG8gZG9jdW1lbnQuICBUaGlzIHdvdWxkIGNhdXNlIGl0IHRvIGJlIGhpZGRlbi5cbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGljayhzdG9wUHJvcGFnYXRpb24pO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgdXNlciB0eXBlZCBpbnB1dFxuICAgICAgICAgICAgdGV4dElucHV0LmNoYW5nZShzZXRGcm9tVGV4dElucHV0KTtcbiAgICAgICAgICAgIHRleHRJbnB1dC5iaW5kKFwicGFzdGVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2V0RnJvbVRleHRJbnB1dCwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRleHRJbnB1dC5rZXlkb3duKGZ1bmN0aW9uIChlKSB7IGlmIChlLmtleUNvZGUgPT0gMTMpIHsgc2V0RnJvbVRleHRJbnB1dCgpOyB9IH0pO1xuXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24udGV4dChvcHRzLmNhbmNlbFRleHQpO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmJpbmQoXCJjbGljay5zcGVjdHJ1bVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldmVydCgpO1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjbGVhckJ1dHRvbi5hdHRyKFwidGl0bGVcIiwgb3B0cy5jbGVhclRleHQpO1xuICAgICAgICAgICAgY2xlYXJCdXR0b24uYmluZChcImNsaWNrLnNwZWN0cnVtXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYoZmxhdCkge1xuICAgICAgICAgICAgICAgICAgICAvL2ZvciB0aGUgZmxhdCBzdHlsZSwgdGhpcyBpcyBhIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPcmlnaW5hbElucHV0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjaG9vc2VCdXR0b24udGV4dChvcHRzLmNob29zZVRleHQpO1xuICAgICAgICAgICAgY2hvb3NlQnV0dG9uLmJpbmQoXCJjbGljay5zcGVjdHJ1bVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPcmlnaW5hbElucHV0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbi50ZXh0KG9wdHMuc2hvd1BhbGV0dGVPbmx5ID8gb3B0cy50b2dnbGVQYWxldHRlTW9yZVRleHQgOiBvcHRzLnRvZ2dsZVBhbGV0dGVMZXNzVGV4dCk7XG4gICAgICAgICAgICB0b2dnbGVCdXR0b24uYmluZChcImNsaWNrLnNwZWN0cnVtXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICBvcHRzLnNob3dQYWxldHRlT25seSA9ICFvcHRzLnNob3dQYWxldHRlT25seTtcblxuICAgICAgICAgICAgICAgIC8vIFRvIG1ha2Ugc3VyZSB0aGUgUGlja2VyIGFyZWEgaXMgZHJhd24gb24gdGhlIHJpZ2h0LCBuZXh0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIFBhbGV0dGUgYXJlYSAoYW5kIG5vdCBiZWxvdyB0aGUgcGFsZXR0ZSksIGZpcnN0IG1vdmUgdGhlIFBhbGV0dGVcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbGVmdCB0byBtYWtlIHNwYWNlIGZvciB0aGUgcGlja2VyLCBwbHVzIDVweCBleHRyYS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgJ2FwcGx5T3B0aW9ucycgZnVuY3Rpb24gcHV0cyB0aGUgd2hvbGUgY29udGFpbmVyIGJhY2sgaW50byBwbGFjZVxuICAgICAgICAgICAgICAgIC8vIGFuZCB0YWtlcyBjYXJlIG9mIHRoZSBidXR0b24tdGV4dCBhbmQgdGhlIHNwLXBhbGV0dGUtb25seSBDU1MgY2xhc3MuXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLnNob3dQYWxldHRlT25seSAmJiAhZmxhdCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY3NzKCdsZWZ0JywgJy09JyArIChwaWNrZXJDb250YWluZXIub3V0ZXJXaWR0aCh0cnVlKSArIDUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHlPcHRpb25zKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZHJhZ2dhYmxlKGFscGhhU2xpZGVyLCBmdW5jdGlvbiAoZHJhZ1gsIGRyYWdZLCBlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEFscGhhID0gKGRyYWdYIC8gYWxwaGFXaWR0aCk7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IE1hdGgucm91bmQoY3VycmVudEFscGhhICogMTApIC8gMTA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgICAgfSwgZHJhZ1N0YXJ0LCBkcmFnU3RvcCk7XG5cbiAgICAgICAgICAgIGRyYWdnYWJsZShzbGlkZXIsIGZ1bmN0aW9uIChkcmFnWCwgZHJhZ1kpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SHVlID0gcGFyc2VGbG9hdChkcmFnWSAvIHNsaWRlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLnNob3dBbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgICB9LCBkcmFnU3RhcnQsIGRyYWdTdG9wKTtcblxuICAgICAgICAgICAgZHJhZ2dhYmxlKGRyYWdnZXIsIGZ1bmN0aW9uIChkcmFnWCwgZHJhZ1ksIGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIHNoaWZ0K2RyYWcgc2hvdWxkIHNuYXAgdGhlIG1vdmVtZW50IHRvIGVpdGhlciB0aGUgeCBvciB5IGF4aXMuXG4gICAgICAgICAgICAgICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0TW92ZW1lbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghc2hpZnRNb3ZlbWVudERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkRHJhZ1ggPSBjdXJyZW50U2F0dXJhdGlvbiAqIGRyYWdXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZERyYWdZID0gZHJhZ0hlaWdodCAtIChjdXJyZW50VmFsdWUgKiBkcmFnSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1cnRoZXJGcm9tWCA9IE1hdGguYWJzKGRyYWdYIC0gb2xkRHJhZ1gpID4gTWF0aC5hYnMoZHJhZ1kgLSBvbGREcmFnWSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hpZnRNb3ZlbWVudERpcmVjdGlvbiA9IGZ1cnRoZXJGcm9tWCA/IFwieFwiIDogXCJ5XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNldFNhdHVyYXRpb24gPSAhc2hpZnRNb3ZlbWVudERpcmVjdGlvbiB8fCBzaGlmdE1vdmVtZW50RGlyZWN0aW9uID09PSBcInhcIjtcbiAgICAgICAgICAgICAgICB2YXIgc2V0VmFsdWUgPSAhc2hpZnRNb3ZlbWVudERpcmVjdGlvbiB8fCBzaGlmdE1vdmVtZW50RGlyZWN0aW9uID09PSBcInlcIjtcblxuICAgICAgICAgICAgICAgIGlmIChzZXRTYXR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTYXR1cmF0aW9uID0gcGFyc2VGbG9hdChkcmFnWCAvIGRyYWdXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KChkcmFnSGVpZ2h0IC0gZHJhZ1kpIC8gZHJhZ0hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghb3B0cy5zaG93QWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFscGhhID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3ZlKCk7XG5cbiAgICAgICAgICAgIH0sIGRyYWdTdGFydCwgZHJhZ1N0b3ApO1xuXG4gICAgICAgICAgICBpZiAoISFpbml0aWFsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBzZXQoaW5pdGlhbENvbG9yKTtcblxuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgY29sb3Igd2FzIGJsYWNrIC0gdXBkYXRlIHRoZSBwcmV2aWV3IFVJIGFuZCBzZXQgdGhlIGZvcm1hdFxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBzZXQgZnVuY3Rpb24gd2lsbCBub3QgcnVuIChkZWZhdWx0IGNvbG9yIGlzIGJsYWNrKS5cbiAgICAgICAgICAgICAgICB1cGRhdGVVSSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVmZXJyZWRGb3JtYXQgPSBwcmVmZXJyZWRGb3JtYXQgfHwgdGlueWNvbG9yKGluaXRpYWxDb2xvcikuZm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgYWRkQ29sb3JUb1NlbGVjdGlvblBhbGV0dGUoaW5pdGlhbENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVVJKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmbGF0KSB7XG4gICAgICAgICAgICAgICAgc2hvdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwYWxldHRlRWxlbWVudENsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS5pZ25vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KCQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuc3AtdGh1bWItZWxcIikuZGF0YShcImNvbG9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KCQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuc3AtdGh1bWItZWxcIikuZGF0YShcImNvbG9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPcmlnaW5hbElucHV0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5oaWRlQWZ0ZXJQYWxldHRlU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFsZXR0ZUV2ZW50ID0gSUUgPyBcIm1vdXNlZG93bi5zcGVjdHJ1bVwiIDogXCJjbGljay5zcGVjdHJ1bSB0b3VjaHN0YXJ0LnNwZWN0cnVtXCI7XG4gICAgICAgICAgICBwYWxldHRlQ29udGFpbmVyLmRlbGVnYXRlKFwiLnNwLXRodW1iLWVsXCIsIHBhbGV0dGVFdmVudCwgcGFsZXR0ZUVsZW1lbnRDbGljayk7XG4gICAgICAgICAgICBpbml0aWFsQ29sb3JDb250YWluZXIuZGVsZWdhdGUoXCIuc3AtdGh1bWItZWw6bnRoLWNoaWxkKDEpXCIsIHBhbGV0dGVFdmVudCwgeyBpZ25vcmU6IHRydWUgfSwgcGFsZXR0ZUVsZW1lbnRDbGljayk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb25QYWxldHRlRnJvbVN0b3JhZ2UoKSB7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2VLZXkgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gTWlncmF0ZSBvbGQgcGFsZXR0ZXMgb3ZlciB0byBuZXcgZm9ybWF0LiAgTWF5IHdhbnQgdG8gcmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkUGFsZXR0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VbbG9jYWxTdG9yYWdlS2V5XS5zcGxpdChcIiwjXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUGFsZXR0ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93LmxvY2FsU3RvcmFnZVtsb2NhbFN0b3JhZ2VLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG9sZFBhbGV0dGUsIGZ1bmN0aW9uKGksIGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ29sb3JUb1NlbGVjdGlvblBhbGV0dGUoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7IH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblBhbGV0dGUgPSB3aW5kb3cubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZUtleV0uc3BsaXQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRDb2xvclRvU2VsZWN0aW9uUGFsZXR0ZShjb2xvcikge1xuICAgICAgICAgICAgaWYgKHNob3dTZWxlY3Rpb25QYWxldHRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJnYiA9IHRpbnljb2xvcihjb2xvcikudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhbGV0dGVMb29rdXBbcmdiXSAmJiAkLmluQXJyYXkocmdiLCBzZWxlY3Rpb25QYWxldHRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUGFsZXR0ZS5wdXNoKHJnYik7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHNlbGVjdGlvblBhbGV0dGUubGVuZ3RoID4gbWF4U2VsZWN0aW9uU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUGFsZXR0ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZUtleSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW2xvY2FsU3RvcmFnZUtleV0gPSBzZWxlY3Rpb25QYWxldHRlLmpvaW4oXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFVuaXF1ZVNlbGVjdGlvblBhbGV0dGUoKSB7XG4gICAgICAgICAgICB2YXIgdW5pcXVlID0gW107XG4gICAgICAgICAgICBpZiAob3B0cy5zaG93UGFsZXR0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0aW9uUGFsZXR0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiID0gdGlueWNvbG9yKHNlbGVjdGlvblBhbGV0dGVbaV0pLnRvUmdiU3RyaW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYWxldHRlTG9va3VwW3JnYl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZS5wdXNoKHNlbGVjdGlvblBhbGV0dGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlLnJldmVyc2UoKS5zbGljZSgwLCBvcHRzLm1heFNlbGVjdGlvblNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd1BhbGV0dGUoKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29sb3IgPSBnZXQoKTtcblxuICAgICAgICAgICAgdmFyIGh0bWwgPSAkLm1hcChwYWxldHRlQXJyYXksIGZ1bmN0aW9uIChwYWxldHRlLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhbGV0dGVUZW1wbGF0ZShwYWxldHRlLCBjdXJyZW50Q29sb3IsIFwic3AtcGFsZXR0ZS1yb3cgc3AtcGFsZXR0ZS1yb3ctXCIgKyBpLCBvcHRzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb25QYWxldHRlRnJvbVN0b3JhZ2UoKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblBhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICBodG1sLnB1c2gocGFsZXR0ZVRlbXBsYXRlKGdldFVuaXF1ZVNlbGVjdGlvblBhbGV0dGUoKSwgY3VycmVudENvbG9yLCBcInNwLXBhbGV0dGUtcm93IHNwLXBhbGV0dGUtcm93LXNlbGVjdGlvblwiLCBvcHRzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhbGV0dGVDb250YWluZXIuaHRtbChodG1sLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0luaXRpYWwoKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zaG93SW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsID0gY29sb3JPblNob3c7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBpbml0aWFsQ29sb3JDb250YWluZXIuaHRtbChwYWxldHRlVGVtcGxhdGUoW2luaXRpYWwsIGN1cnJlbnRdLCBjdXJyZW50LCBcInNwLXBhbGV0dGUtcm93LWluaXRpYWxcIiwgb3B0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKGRyYWdIZWlnaHQgPD0gMCB8fCBkcmFnV2lkdGggPD0gMCB8fCBzbGlkZUhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVmbG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICBzaGlmdE1vdmVtZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGJvdW5kRWxlbWVudC50cmlnZ2VyKCdkcmFnc3RhcnQuc3BlY3RydW0nLCBbIGdldCgpIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhZ1N0b3AoKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2xhc3MoZHJhZ2dpbmdDbGFzcyk7XG4gICAgICAgICAgICBib3VuZEVsZW1lbnQudHJpZ2dlcignZHJhZ3N0b3Auc3BlY3RydW0nLCBbIGdldCgpIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0RnJvbVRleHRJbnB1dCgpIHtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGV4dElucHV0LnZhbCgpO1xuXG4gICAgICAgICAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiKSAmJiBhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgc2V0KG51bGwpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU9yaWdpbmFsSW5wdXQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGlueSA9IHRpbnljb2xvcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbnkuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCh0aW55KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT3JpZ2luYWxJbnB1dCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRJbnB1dC5hZGRDbGFzcyhcInNwLXZhbGlkYXRpb24tZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gJC5FdmVudCgnYmVmb3JlU2hvdy5zcGVjdHJ1bScpO1xuXG4gICAgICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJlZmxvdygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm91bmRFbGVtZW50LnRyaWdnZXIoZXZlbnQsIFsgZ2V0KCkgXSk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MuYmVmb3JlU2hvdyhnZXQoKSkgPT09IGZhbHNlIHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoaWRlQWxsKCk7XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgJChkb2MpLmJpbmQoXCJjbGljay5zcGVjdHJ1bVwiLCBjbGlja291dCk7XG4gICAgICAgICAgICAkKHdpbmRvdykuYmluZChcInJlc2l6ZS5zcGVjdHJ1bVwiLCByZXNpemUpO1xuICAgICAgICAgICAgcmVwbGFjZXIuYWRkQ2xhc3MoXCJzcC1hY3RpdmVcIik7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJzcC1oaWRkZW5cIik7XG5cbiAgICAgICAgICAgIHJlZmxvdygpO1xuICAgICAgICAgICAgdXBkYXRlVUkoKTtcblxuICAgICAgICAgICAgY29sb3JPblNob3cgPSBnZXQoKTtcblxuICAgICAgICAgICAgZHJhd0luaXRpYWwoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zaG93KGNvbG9yT25TaG93KTtcbiAgICAgICAgICAgIGJvdW5kRWxlbWVudC50cmlnZ2VyKCdzaG93LnNwZWN0cnVtJywgWyBjb2xvck9uU2hvdyBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNsaWNrb3V0KGUpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBvbiByaWdodCBjbGljay5cbiAgICAgICAgICAgIGlmIChlICYmIGUudHlwZSA9PSBcImNsaWNrXCIgJiYgZS5idXR0b24gPT0gMikgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgaWYgKGNsaWNrb3V0RmlyZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVPcmlnaW5hbElucHV0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGlmIGhpZGluZyBpcyB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgaWYgKCF2aXNpYmxlIHx8IGZsYXQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICQoZG9jKS51bmJpbmQoXCJjbGljay5zcGVjdHJ1bVwiLCBjbGlja291dCk7XG4gICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKFwicmVzaXplLnNwZWN0cnVtXCIsIHJlc2l6ZSk7XG5cbiAgICAgICAgICAgIHJlcGxhY2VyLnJlbW92ZUNsYXNzKFwic3AtYWN0aXZlXCIpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKFwic3AtaGlkZGVuXCIpO1xuXG4gICAgICAgICAgICBjYWxsYmFja3MuaGlkZShnZXQoKSk7XG4gICAgICAgICAgICBib3VuZEVsZW1lbnQudHJpZ2dlcignaGlkZS5zcGVjdHJ1bScsIFsgZ2V0KCkgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXZlcnQoKSB7XG4gICAgICAgICAgICBzZXQoY29sb3JPblNob3csIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0KGNvbG9yLCBpZ25vcmVGb3JtYXRDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aW55Y29sb3IuZXF1YWxzKGNvbG9yLCBnZXQoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkganVzdCBpbiBjYXNlIGEgdmFsaWRhdGlvbiBlcnJvciBuZWVkc1xuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGNsZWFyZWQuXG4gICAgICAgICAgICAgICAgdXBkYXRlVUkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdDb2xvciwgbmV3SHN2O1xuICAgICAgICAgICAgaWYgKCFjb2xvciAmJiBhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdDb2xvciA9IHRpbnljb2xvcihjb2xvcik7XG4gICAgICAgICAgICAgICAgbmV3SHN2ID0gbmV3Q29sb3IudG9Ic3YoKTtcblxuICAgICAgICAgICAgICAgIGN1cnJlbnRIdWUgPSAobmV3SHN2LmggJSAzNjApIC8gMzYwO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTYXR1cmF0aW9uID0gbmV3SHN2LnM7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3SHN2LnY7XG4gICAgICAgICAgICAgICAgY3VycmVudEFscGhhID0gbmV3SHN2LmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVVSSgpO1xuXG4gICAgICAgICAgICBpZiAobmV3Q29sb3IgJiYgbmV3Q29sb3IuaXNWYWxpZCgpICYmICFpZ25vcmVGb3JtYXRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlZmVycmVkRm9ybWF0ID0gcHJlZmVycmVkRm9ybWF0IHx8IG5ld0NvbG9yLmdldEZvcm1hdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0KG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgICAgICAgICAgaWYgKGFsbG93RW1wdHkgJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGlueWNvbG9yLmZyb21SYXRpbyh7XG4gICAgICAgICAgICAgICAgaDogY3VycmVudEh1ZSxcbiAgICAgICAgICAgICAgICBzOiBjdXJyZW50U2F0dXJhdGlvbixcbiAgICAgICAgICAgICAgICB2OiBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgYTogTWF0aC5yb3VuZChjdXJyZW50QWxwaGEgKiAxMDApIC8gMTAwXG4gICAgICAgICAgICB9LCB7IGZvcm1hdDogb3B0cy5mb3JtYXQgfHwgY3VycmVudFByZWZlcnJlZEZvcm1hdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRleHRJbnB1dC5oYXNDbGFzcyhcInNwLXZhbGlkYXRpb24tZXJyb3JcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3ZlKCkge1xuICAgICAgICAgICAgdXBkYXRlVUkoKTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzLm1vdmUoZ2V0KCkpO1xuICAgICAgICAgICAgYm91bmRFbGVtZW50LnRyaWdnZXIoJ21vdmUuc3BlY3RydW0nLCBbIGdldCgpIF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVUkoKSB7XG5cbiAgICAgICAgICAgIHRleHRJbnB1dC5yZW1vdmVDbGFzcyhcInNwLXZhbGlkYXRpb24tZXJyb3JcIik7XG5cbiAgICAgICAgICAgIHVwZGF0ZUhlbHBlckxvY2F0aW9ucygpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgZHJhZ2dlciBiYWNrZ3JvdW5kIGNvbG9yIChncmFkaWVudHMgdGFrZSBjYXJlIG9mIHNhdHVyYXRpb24gYW5kIHZhbHVlKS5cbiAgICAgICAgICAgIHZhciBmbGF0Q29sb3IgPSB0aW55Y29sb3IuZnJvbVJhdGlvKHsgaDogY3VycmVudEh1ZSwgczogMSwgdjogMSB9KTtcbiAgICAgICAgICAgIGRyYWdnZXIuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBmbGF0Q29sb3IudG9IZXhTdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIC8vIEdldCBhIGZvcm1hdCB0aGF0IGFscGhhIHdpbGwgYmUgaW5jbHVkZWQgaW4gKGhleCBhbmQgbmFtZXMgaWdub3JlIGFscGhhKVxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGN1cnJlbnRQcmVmZXJyZWRGb3JtYXQ7XG4gICAgICAgICAgICBpZiAoY3VycmVudEFscGhhIDwgMSAmJiAhKGN1cnJlbnRBbHBoYSA9PT0gMCAmJiBmb3JtYXQgPT09IFwibmFtZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDNcIiB8fCBmb3JtYXQgPT09IFwiaGV4NlwiIHx8IGZvcm1hdCA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJyZ2JcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWFsQ29sb3IgPSBnZXQoeyBmb3JtYXQ6IGZvcm1hdCB9KSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5Q29sb3IgPSAnJztcblxuICAgICAgICAgICAgIC8vcmVzZXQgYmFja2dyb3VuZCBpbmZvIGZvciBwcmV2aWV3IGVsZW1lbnRcbiAgICAgICAgICAgIHByZXZpZXdFbGVtZW50LnJlbW92ZUNsYXNzKFwic3AtY2xlYXItZGlzcGxheVwiKTtcbiAgICAgICAgICAgIHByZXZpZXdFbGVtZW50LmNzcygnYmFja2dyb3VuZC1jb2xvcicsICd0cmFuc3BhcmVudCcpO1xuXG4gICAgICAgICAgICBpZiAoIXJlYWxDb2xvciAmJiBhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZXBsYWNlZCBlbGVtZW50cyBiYWNrZ3JvdW5kIHdpdGggaWNvbiBpbmRpY2F0aW5nIG5vIGNvbG9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHByZXZpZXdFbGVtZW50LmFkZENsYXNzKFwic3AtY2xlYXItZGlzcGxheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZWFsSGV4ID0gcmVhbENvbG9yLnRvSGV4U3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHJlYWxSZ2IgPSByZWFsQ29sb3IudG9SZ2JTdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVwbGFjZWQgZWxlbWVudHMgYmFja2dyb3VuZCBjb2xvciAod2l0aCBhY3R1YWwgc2VsZWN0ZWQgY29sb3IpXG4gICAgICAgICAgICAgICAgaWYgKHJnYmFTdXBwb3J0IHx8IHJlYWxDb2xvci5hbHBoYSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3RWxlbWVudC5jc3MoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIHJlYWxSZ2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlld0VsZW1lbnQuY3NzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aWV3RWxlbWVudC5jc3MoXCJmaWx0ZXJcIiwgcmVhbENvbG9yLnRvRmlsdGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRzLnNob3dBbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmdiID0gcmVhbENvbG9yLnRvUmdiKCk7XG4gICAgICAgICAgICAgICAgICAgIHJnYi5hID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWxBbHBoYSA9IHRpbnljb2xvcihyZ2IpLnRvUmdiU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IFwibGluZWFyLWdyYWRpZW50KGxlZnQsIFwiICsgcmVhbEFscGhhICsgXCIsIFwiICsgcmVhbEhleCArIFwiKVwiO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChJRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFTbGlkZXJJbm5lci5jc3MoXCJmaWx0ZXJcIiwgdGlueWNvbG9yKHJlYWxBbHBoYSkudG9GaWx0ZXIoeyBncmFkaWVudFR5cGU6IDEgfSwgcmVhbEhleCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFTbGlkZXJJbm5lci5jc3MoXCJiYWNrZ3JvdW5kXCIsIFwiLXdlYmtpdC1cIiArIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhU2xpZGVySW5uZXIuY3NzKFwiYmFja2dyb3VuZFwiLCBcIi1tb3otXCIgKyBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVNsaWRlcklubmVyLmNzcyhcImJhY2tncm91bmRcIiwgXCItbXMtXCIgKyBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgY3VycmVudCBzeW50YXggZ3JhZGllbnQgb24gdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhU2xpZGVySW5uZXIuY3NzKFwiYmFja2dyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCBcIiArIHJlYWxBbHBoYSArIFwiLCBcIiArIHJlYWxIZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXNwbGF5Q29sb3IgPSByZWFsQ29sb3IudG9TdHJpbmcoZm9ybWF0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0ZXh0IGVudHJ5IGlucHV0IGFzIGl0IGNoYW5nZXMgaGFwcGVuXG4gICAgICAgICAgICBpZiAob3B0cy5zaG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0SW5wdXQudmFsKGRpc3BsYXlDb2xvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLnNob3dQYWxldHRlKSB7XG4gICAgICAgICAgICAgICAgZHJhd1BhbGV0dGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHJhd0luaXRpYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUhlbHBlckxvY2F0aW9ucygpIHtcbiAgICAgICAgICAgIHZhciBzID0gY3VycmVudFNhdHVyYXRpb247XG4gICAgICAgICAgICB2YXIgdiA9IGN1cnJlbnRWYWx1ZTtcblxuICAgICAgICAgICAgaWYoYWxsb3dFbXB0eSAmJiBpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgLy9pZiBzZWxlY3RlZCBjb2xvciBpcyBlbXB0eSwgaGlkZSB0aGUgaGVscGVyc1xuICAgICAgICAgICAgICAgIGFscGhhU2xpZGVIZWxwZXIuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHNsaWRlSGVscGVyLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBkcmFnSGVscGVyLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIGhlbHBlcnMgYXJlIHZpc2libGVcbiAgICAgICAgICAgICAgICBhbHBoYVNsaWRlSGVscGVyLnNob3coKTtcbiAgICAgICAgICAgICAgICBzbGlkZUhlbHBlci5zaG93KCk7XG4gICAgICAgICAgICAgICAgZHJhZ0hlbHBlci5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVyZSB0byBzaG93IHRoZSBsaXR0bGUgY2lyY2xlIGluIHRoYXQgZGlzcGxheXMgeW91ciBjdXJyZW50IHNlbGVjdGVkIGNvbG9yXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdYID0gcyAqIGRyYWdXaWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ1kgPSBkcmFnSGVpZ2h0IC0gKHYgKiBkcmFnSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBkcmFnWCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAtZHJhZ0hlbHBlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZHJhZ1dpZHRoIC0gZHJhZ0hlbHBlckhlaWdodCwgZHJhZ1ggLSBkcmFnSGVscGVySGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZHJhZ1kgPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgICAgLWRyYWdIZWxwZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGRyYWdIZWlnaHQgLSBkcmFnSGVscGVySGVpZ2h0LCBkcmFnWSAtIGRyYWdIZWxwZXJIZWlnaHQpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkcmFnSGVscGVyLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IGRyYWdZICsgXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogZHJhZ1ggKyBcInB4XCJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBhbHBoYVggPSBjdXJyZW50QWxwaGEgKiBhbHBoYVdpZHRoO1xuICAgICAgICAgICAgICAgIGFscGhhU2xpZGVIZWxwZXIuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IChhbHBoYVggLSAoYWxwaGFTbGlkZUhlbHBlcldpZHRoIC8gMikpICsgXCJweFwiXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVyZSB0byBzaG93IHRoZSBiYXIgdGhhdCBkaXNwbGF5cyB5b3VyIGN1cnJlbnQgc2VsZWN0ZWQgaHVlXG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlWSA9IChjdXJyZW50SHVlKSAqIHNsaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHNsaWRlSGVscGVyLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IChzbGlkZVkgLSBzbGlkZUhlbHBlckhlaWdodCkgKyBcInB4XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9yaWdpbmFsSW5wdXQoZmlyZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBnZXQoKSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5Q29sb3IgPSAnJyxcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VkID0gIXRpbnljb2xvci5lcXVhbHMoY29sb3IsIGNvbG9yT25TaG93KTtcblxuICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheUNvbG9yID0gY29sb3IudG9TdHJpbmcoY3VycmVudFByZWZlcnJlZEZvcm1hdCk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gcGFsZXR0ZSB3aXRoIHRoZSBjdXJyZW50IGNvbG9yXG4gICAgICAgICAgICAgICAgYWRkQ29sb3JUb1NlbGVjdGlvblBhbGV0dGUoY29sb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudC52YWwoZGlzcGxheUNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpcmVDYWxsYmFjayAmJiBoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmNoYW5nZShjb2xvcik7XG4gICAgICAgICAgICAgICAgYm91bmRFbGVtZW50LnRyaWdnZXIoJ2NoYW5nZScsIFsgY29sb3IgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWZsb3coKSB7XG4gICAgICAgICAgICBkcmFnV2lkdGggPSBkcmFnZ2VyLndpZHRoKCk7XG4gICAgICAgICAgICBkcmFnSGVpZ2h0ID0gZHJhZ2dlci5oZWlnaHQoKTtcbiAgICAgICAgICAgIGRyYWdIZWxwZXJIZWlnaHQgPSBkcmFnSGVscGVyLmhlaWdodCgpO1xuICAgICAgICAgICAgc2xpZGVXaWR0aCA9IHNsaWRlci53aWR0aCgpO1xuICAgICAgICAgICAgc2xpZGVIZWlnaHQgPSBzbGlkZXIuaGVpZ2h0KCk7XG4gICAgICAgICAgICBzbGlkZUhlbHBlckhlaWdodCA9IHNsaWRlSGVscGVyLmhlaWdodCgpO1xuICAgICAgICAgICAgYWxwaGFXaWR0aCA9IGFscGhhU2xpZGVyLndpZHRoKCk7XG4gICAgICAgICAgICBhbHBoYVNsaWRlSGVscGVyV2lkdGggPSBhbHBoYVNsaWRlSGVscGVyLndpZHRoKCk7XG5cbiAgICAgICAgICAgIGlmICghZmxhdCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jc3MoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5vZmZzZXQoZ2V0T2Zmc2V0KGNvbnRhaW5lciwgb2Zmc2V0RWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVIZWxwZXJMb2NhdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1BhbGV0dGUpIHtcbiAgICAgICAgICAgICAgICBkcmF3UGFsZXR0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBib3VuZEVsZW1lbnQudHJpZ2dlcigncmVmbG93LnNwZWN0cnVtJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgYm91bmRFbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgIG9mZnNldEVsZW1lbnQudW5iaW5kKFwiY2xpY2suc3BlY3RydW0gdG91Y2hzdGFydC5zcGVjdHJ1bVwiKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJlcGxhY2VyLnJlbW92ZSgpO1xuICAgICAgICAgICAgc3BlY3RydW1zW3NwZWN0LmlkXSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvcHRpb24ob3B0aW9uTmFtZSwgb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe30sIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0c1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0c1tvcHRpb25OYW1lXSA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgICAgYXBwbHlPcHRpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYm91bmRFbGVtZW50LmF0dHIoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gICAgICAgICAgICBvZmZzZXRFbGVtZW50LnJlbW92ZUNsYXNzKFwic3AtZGlzYWJsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYm91bmRFbGVtZW50LmF0dHIoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgICAgICAgICAgIG9mZnNldEVsZW1lbnQuYWRkQ2xhc3MoXCJzcC1kaXNhYmxlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemUoKTtcblxuICAgICAgICB2YXIgc3BlY3QgPSB7XG4gICAgICAgICAgICBzaG93OiBzaG93LFxuICAgICAgICAgICAgaGlkZTogaGlkZSxcbiAgICAgICAgICAgIHRvZ2dsZTogdG9nZ2xlLFxuICAgICAgICAgICAgcmVmbG93OiByZWZsb3csXG4gICAgICAgICAgICBvcHRpb246IG9wdGlvbixcbiAgICAgICAgICAgIGVuYWJsZTogZW5hYmxlLFxuICAgICAgICAgICAgZGlzYWJsZTogZGlzYWJsZSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBzZXQoYyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlT3JpZ2luYWxJbnB1dCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZ2V0LFxuICAgICAgICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gICAgICAgIH07XG5cbiAgICAgICAgc3BlY3QuaWQgPSBzcGVjdHJ1bXMucHVzaChzcGVjdCkgLSAxO1xuXG4gICAgICAgIHJldHVybiBzcGVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIGNoZWNrT2Zmc2V0IC0gZ2V0IHRoZSBvZmZzZXQgYmVsb3cvYWJvdmUgYW5kIGxlZnQvcmlnaHQgZWxlbWVudCBkZXBlbmRpbmcgb24gc2NyZWVuIHBvc2l0aW9uXG4gICAgKiBUaGFua3MgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvanF1ZXJ5LnVpLmRhdGVwaWNrZXIuanNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9mZnNldChwaWNrZXIsIGlucHV0KSB7XG4gICAgICAgIHZhciBleHRyYVkgPSAwO1xuICAgICAgICB2YXIgZHBXaWR0aCA9IHBpY2tlci5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciBkcEhlaWdodCA9IHBpY2tlci5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgaW5wdXRIZWlnaHQgPSBpbnB1dC5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgZG9jID0gcGlja2VyWzBdLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHZhciBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGRvY0VsZW0uY2xpZW50V2lkdGggKyAkKGRvYykuc2Nyb2xsTGVmdCgpO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9IGRvY0VsZW0uY2xpZW50SGVpZ2h0ICsgJChkb2MpLnNjcm9sbFRvcCgpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gaW5wdXQub2Zmc2V0KCk7XG4gICAgICAgIG9mZnNldC50b3AgKz0gaW5wdXRIZWlnaHQ7XG5cbiAgICAgICAgb2Zmc2V0LmxlZnQgLT1cbiAgICAgICAgICAgIE1hdGgubWluKG9mZnNldC5sZWZ0LCAob2Zmc2V0LmxlZnQgKyBkcFdpZHRoID4gdmlld1dpZHRoICYmIHZpZXdXaWR0aCA+IGRwV2lkdGgpID9cbiAgICAgICAgICAgIE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcblxuICAgICAgICBvZmZzZXQudG9wIC09XG4gICAgICAgICAgICBNYXRoLm1pbihvZmZzZXQudG9wLCAoKG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0KSA/XG4gICAgICAgICAgICBNYXRoLmFicyhkcEhlaWdodCArIGlucHV0SGVpZ2h0IC0gZXh0cmFZKSA6IGV4dHJhWSkpO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBub29wIC0gZG8gbm90aGluZ1xuICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICogc3RvcFByb3BhZ2F0aW9uIC0gbWFrZXMgdGhlIGNvZGUgb25seSBkb2luZyB0aGlzIGEgbGl0dGxlIGVhc2llciB0byByZWFkIGluIGxpbmVcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdFxuICAgICogVGhhbmtzIHRvIHVuZGVyc2NvcmUuanNcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgb2JqKSB7XG4gICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogTGlnaHR3ZWlnaHQgZHJhZyBoZWxwZXIuICBIYW5kbGVzIGNvbnRhaW5tZW50IHdpdGhpbiB0aGUgZWxlbWVudCwgc28gdGhhdFxuICAgICogd2hlbiBkcmFnZ2luZywgdGhlIHggaXMgd2l0aGluIFswLGVsZW1lbnQud2lkdGhdIGFuZCB5IGlzIHdpdGhpbiBbMCxlbGVtZW50LmhlaWdodF1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYWdnYWJsZShlbGVtZW50LCBvbm1vdmUsIG9uc3RhcnQsIG9uc3RvcCkge1xuICAgICAgICBvbm1vdmUgPSBvbm1vdmUgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBvbnN0YXJ0ID0gb25zdGFydCB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIG9uc3RvcCA9IG9uc3RvcCB8fCBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBvZmZzZXQgPSB7fTtcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IDA7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IDA7XG4gICAgICAgIHZhciBoYXNUb3VjaCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4gICAgICAgIHZhciBkdXJpbmdEcmFnRXZlbnRzID0ge307XG4gICAgICAgIGR1cmluZ0RyYWdFdmVudHNbXCJzZWxlY3RzdGFydFwiXSA9IHByZXZlbnQ7XG4gICAgICAgIGR1cmluZ0RyYWdFdmVudHNbXCJkcmFnc3RhcnRcIl0gPSBwcmV2ZW50O1xuICAgICAgICBkdXJpbmdEcmFnRXZlbnRzW1widG91Y2htb3ZlIG1vdXNlbW92ZVwiXSA9IG1vdmU7XG4gICAgICAgIGR1cmluZ0RyYWdFdmVudHNbXCJ0b3VjaGVuZCBtb3VzZXVwXCJdID0gc3RvcDtcblxuICAgICAgICBmdW5jdGlvbiBwcmV2ZW50KGUpIHtcbiAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1vdmUoZSkge1xuICAgICAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gTW91c2V1cCBoYXBwZW5lZCBvdXRzaWRlIG9mIHdpbmRvd1xuICAgICAgICAgICAgICAgIGlmIChJRSAmJiBkb2MuZG9jdW1lbnRNb2RlIDwgOSAmJiAhZS5idXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGUub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuICAgICAgICAgICAgICAgIHZhciBwYWdlWCA9IHRvdWNoZXMgPyB0b3VjaGVzWzBdLnBhZ2VYIDogZS5wYWdlWDtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVkgPSB0b3VjaGVzID8gdG91Y2hlc1swXS5wYWdlWSA6IGUucGFnZVk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJhZ1ggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlWCAtIG9mZnNldC5sZWZ0LCBtYXhXaWR0aCkpO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnWSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VZIC0gb2Zmc2V0LnRvcCwgbWF4SGVpZ2h0KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBzY3JvbGxpbmcgaW4gaU9TXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb25tb3ZlLmFwcGx5KGVsZW1lbnQsIFtkcmFnWCwgZHJhZ1ksIGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICAgICAgICAgIHZhciByaWdodGNsaWNrID0gKGUud2hpY2gpID8gKGUud2hpY2ggPT0gMykgOiAoZS5idXR0b24gPT0gMik7XG5cbiAgICAgICAgICAgIGlmICghcmlnaHRjbGljayAmJiAhZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAob25zdGFydC5hcHBseShlbGVtZW50LCBhcmd1bWVudHMpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA9ICQoZWxlbWVudCkuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1heFdpZHRoID0gJChlbGVtZW50KS53aWR0aCgpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAkKGVsZW1lbnQpLm9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoZG9jKS5iaW5kKGR1cmluZ0RyYWdFdmVudHMpO1xuICAgICAgICAgICAgICAgICAgICAkKGRvYy5ib2R5KS5hZGRDbGFzcyhcInNwLWRyYWdnaW5nXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICAkKGRvYykudW5iaW5kKGR1cmluZ0RyYWdFdmVudHMpO1xuICAgICAgICAgICAgICAgICQoZG9jLmJvZHkpLnJlbW92ZUNsYXNzKFwic3AtZHJhZ2dpbmdcIik7XG4gICAgICAgICAgICAgICAgb25zdG9wLmFwcGx5KGVsZW1lbnQsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgJChlbGVtZW50KS5iaW5kKFwidG91Y2hzdGFydCBtb3VzZWRvd25cIiwgc3RhcnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIGRlYm91bmNlKSB7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdmFyIHRocm90dGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkZWJvdW5jZSkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGRlYm91bmNlIHx8ICF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dCh0aHJvdHRsZXIsIHdhaXQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICogRGVmaW5lIGEgalF1ZXJ5IHBsdWdpblxuICAgICovXG4gICAgdmFyIGRhdGFJRCA9IFwic3BlY3RydW0uaWRcIjtcbiAgICAkLmZuLnNwZWN0cnVtID0gZnVuY3Rpb24gKG9wdHMsIGV4dHJhKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09IFwic3RyaW5nXCIpIHtcblxuICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzcGVjdCA9IHNwZWN0cnVtc1skKHRoaXMpLmRhdGEoZGF0YUlEKV07XG4gICAgICAgICAgICAgICAgaWYgKHNwZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBzcGVjdFtvcHRzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciggXCJTcGVjdHJ1bTogbm8gc3VjaCBtZXRob2Q6ICdcIiArIG9wdHMgKyBcIidcIiApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMgPT0gXCJnZXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBzcGVjdC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRzID09IFwiY29udGFpbmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gc3BlY3QuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMgPT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBzcGVjdC5vcHRpb24uYXBwbHkoc3BlY3QsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMgPT0gXCJkZXN0cm95XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlRGF0YShkYXRhSUQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHNwZWN0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXppbmcgYSBuZXcgaW5zdGFuY2Ugb2Ygc3BlY3RydW1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3RydW0oXCJkZXN0cm95XCIpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0cywgJCh0aGlzKS5kYXRhKCkpO1xuICAgICAgICAgICAgdmFyIHNwZWN0ID0gc3BlY3RydW0odGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAkKHRoaXMpLmRhdGEoZGF0YUlELCBzcGVjdC5pZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAkLmZuLnNwZWN0cnVtLmxvYWQgPSB0cnVlO1xuICAgICQuZm4uc3BlY3RydW0ubG9hZE9wdHMgPSB7fTtcbiAgICAkLmZuLnNwZWN0cnVtLmRyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICAkLmZuLnNwZWN0cnVtLmRlZmF1bHRzID0gZGVmYXVsdE9wdHM7XG5cbiAgICAkLnNwZWN0cnVtID0geyB9O1xuICAgICQuc3BlY3RydW0ubG9jYWxpemF0aW9uID0geyB9O1xuICAgICQuc3BlY3RydW0ucGFsZXR0ZXMgPSB7IH07XG5cbiAgICAkLmZuLnNwZWN0cnVtLnByb2Nlc3NOYXRpdmVDb2xvcklucHV0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpbnB1dFR5cGVDb2xvclN1cHBvcnQpIHtcbiAgICAgICAgICAgICQoXCJpbnB1dFt0eXBlPWNvbG9yXVwiKS5zcGVjdHJ1bSh7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkRm9ybWF0OiBcImhleDZcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVGlueUNvbG9yIHYxLjAuMFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZ3JpbnMvVGlueUNvbG9yXG4gICAgLy8gQnJpYW4gR3JpbnN0ZWFkLCBNSVQgTGljZW5zZVxuXG4gICAgKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHRyaW1MZWZ0ID0gL15bXFxzLCNdKy8sXG4gICAgICAgIHRyaW1SaWdodCA9IC9cXHMrJC8sXG4gICAgICAgIHRpbnlDb3VudGVyID0gMCxcbiAgICAgICAgbWF0aCA9IE1hdGgsXG4gICAgICAgIG1hdGhSb3VuZCA9IG1hdGgucm91bmQsXG4gICAgICAgIG1hdGhNaW4gPSBtYXRoLm1pbixcbiAgICAgICAgbWF0aE1heCA9IG1hdGgubWF4LFxuICAgICAgICBtYXRoUmFuZG9tID0gbWF0aC5yYW5kb207XG5cbiAgICB2YXIgdGlueWNvbG9yID0gZnVuY3Rpb24gdGlueWNvbG9yIChjb2xvciwgb3B0cykge1xuXG4gICAgICAgIGNvbG9yID0gKGNvbG9yKSA/IGNvbG9yIDogJyc7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHsgfTtcblxuICAgICAgICAvLyBJZiBpbnB1dCBpcyBhbHJlYWR5IGEgdGlueWNvbG9yLCByZXR1cm4gaXRzZWxmXG4gICAgICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIHRpbnljb2xvcikge1xuICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBjYWxsIHVzaW5nIG5ldyBpbnN0ZWFkXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aW55Y29sb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRpbnljb2xvcihjb2xvciwgb3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmdiID0gaW5wdXRUb1JHQihjb2xvcik7XG4gICAgICAgIHRoaXMuX3IgPSByZ2IucixcbiAgICAgICAgdGhpcy5fZyA9IHJnYi5nLFxuICAgICAgICB0aGlzLl9iID0gcmdiLmIsXG4gICAgICAgIHRoaXMuX2EgPSByZ2IuYSxcbiAgICAgICAgdGhpcy5fcm91bmRBID0gbWF0aFJvdW5kKDEwMCp0aGlzLl9hKSAvIDEwMCxcbiAgICAgICAgdGhpcy5fZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgcmdiLmZvcm1hdDtcbiAgICAgICAgdGhpcy5fZ3JhZGllbnRUeXBlID0gb3B0cy5ncmFkaWVudFR5cGU7XG5cbiAgICAgICAgLy8gRG9uJ3QgbGV0IHRoZSByYW5nZSBvZiBbMCwyNTVdIGNvbWUgYmFjayBpbiBbMCwxXS5cbiAgICAgICAgLy8gUG90ZW50aWFsbHkgbG9zZSBhIGxpdHRsZSBiaXQgb2YgcHJlY2lzaW9uIGhlcmUsIGJ1dCB3aWxsIGZpeCBpc3N1ZXMgd2hlcmVcbiAgICAgICAgLy8gLjUgZ2V0cyBpbnRlcnByZXRlZCBhcyBoYWxmIG9mIHRoZSB0b3RhbCwgaW5zdGVhZCBvZiBoYWxmIG9mIDFcbiAgICAgICAgLy8gSWYgaXQgd2FzIHN1cHBvc2VkIHRvIGJlIDEyOCwgdGhpcyB3YXMgYWxyZWFkeSB0YWtlbiBjYXJlIG9mIGJ5IGBpbnB1dFRvUmdiYFxuICAgICAgICBpZiAodGhpcy5fciA8IDEpIHsgdGhpcy5fciA9IG1hdGhSb3VuZCh0aGlzLl9yKTsgfVxuICAgICAgICBpZiAodGhpcy5fZyA8IDEpIHsgdGhpcy5fZyA9IG1hdGhSb3VuZCh0aGlzLl9nKTsgfVxuICAgICAgICBpZiAodGhpcy5fYiA8IDEpIHsgdGhpcy5fYiA9IG1hdGhSb3VuZCh0aGlzLl9iKTsgfVxuXG4gICAgICAgIHRoaXMuX29rID0gcmdiLm9rO1xuICAgICAgICB0aGlzLl90Y19pZCA9IHRpbnlDb3VudGVyKys7XG4gICAgfTtcblxuICAgIHRpbnljb2xvci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGlzRGFyazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCcmlnaHRuZXNzKCkgPCAxMjg7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTGlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzRGFyaygpO1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vaztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgICAgICB9LFxuICAgICAgICBnZXRCcmlnaHRuZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZ2IgPSB0aGlzLnRvUmdiKCk7XG4gICAgICAgICAgICByZXR1cm4gKHJnYi5yICogMjk5ICsgcmdiLmcgKiA1ODcgKyByZ2IuYiAqIDExNCkgLyAxMDAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBbHBoYTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2EgPSBib3VuZEFscGhhKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3JvdW5kQSA9IG1hdGhSb3VuZCgxMDAqdGhpcy5fYSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgdG9Ic3Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhzdiA9IHJnYlRvSHN2KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICAgICAgcmV0dXJuIHsgaDogaHN2LmggKiAzNjAsIHM6IGhzdi5zLCB2OiBoc3YudiwgYTogdGhpcy5fYSB9O1xuICAgICAgICB9LFxuICAgICAgICB0b0hzdlN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaHN2ID0gcmdiVG9Ic3YodGhpcy5fciwgdGhpcy5fZywgdGhpcy5fYik7XG4gICAgICAgICAgICB2YXIgaCA9IG1hdGhSb3VuZChoc3YuaCAqIDM2MCksIHMgPSBtYXRoUm91bmQoaHN2LnMgKiAxMDApLCB2ID0gbWF0aFJvdW5kKGhzdi52ICogMTAwKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgICAgIFwiaHN2KFwiICArIGggKyBcIiwgXCIgKyBzICsgXCIlLCBcIiArIHYgKyBcIiUpXCIgOlxuICAgICAgICAgICAgICBcImhzdmEoXCIgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyB2ICsgXCIlLCBcIisgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoc2wgPSByZ2JUb0hzbCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iKTtcbiAgICAgICAgICAgIHJldHVybiB7IGg6IGhzbC5oICogMzYwLCBzOiBoc2wucywgbDogaHNsLmwsIGE6IHRoaXMuX2EgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9Ic2xTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhzbCA9IHJnYlRvSHNsKHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IpO1xuICAgICAgICAgICAgdmFyIGggPSBtYXRoUm91bmQoaHNsLmggKiAzNjApLCBzID0gbWF0aFJvdW5kKGhzbC5zICogMTAwKSwgbCA9IG1hdGhSb3VuZChoc2wubCAqIDEwMCk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2EgPT0gMSkgP1xuICAgICAgICAgICAgICBcImhzbChcIiAgKyBoICsgXCIsIFwiICsgcyArIFwiJSwgXCIgKyBsICsgXCIlKVwiIDpcbiAgICAgICAgICAgICAgXCJoc2xhKFwiICsgaCArIFwiLCBcIiArIHMgKyBcIiUsIFwiICsgbCArIFwiJSwgXCIrIHRoaXMuX3JvdW5kQSArIFwiKVwiO1xuICAgICAgICB9LFxuICAgICAgICB0b0hleDogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICAgICAgcmV0dXJuIHJnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIGFsbG93M0NoYXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b0hleFN0cmluZzogZnVuY3Rpb24oYWxsb3czQ2hhcikge1xuICAgICAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXgoYWxsb3czQ2hhcik7XG4gICAgICAgIH0sXG4gICAgICAgIHRvSGV4ODogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcmdiYVRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRoaXMuX2EpO1xuICAgICAgICB9LFxuICAgICAgICB0b0hleDhTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICcjJyArIHRoaXMudG9IZXg4KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZCh0aGlzLl9yKSwgZzogbWF0aFJvdW5kKHRoaXMuX2cpLCBiOiBtYXRoUm91bmQodGhpcy5fYiksIGE6IHRoaXMuX2EgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9SZ2JTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9hID09IDEpID9cbiAgICAgICAgICAgICAgXCJyZ2IoXCIgICsgbWF0aFJvdW5kKHRoaXMuX3IpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2cpICsgXCIsIFwiICsgbWF0aFJvdW5kKHRoaXMuX2IpICsgXCIpXCIgOlxuICAgICAgICAgICAgICBcInJnYmEoXCIgKyBtYXRoUm91bmQodGhpcy5fcikgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fZykgKyBcIiwgXCIgKyBtYXRoUm91bmQodGhpcy5fYikgKyBcIiwgXCIgKyB0aGlzLl9yb3VuZEEgKyBcIilcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdG9QZXJjZW50YWdlUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGc6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlXCIsIGI6IG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlXCIsIGE6IHRoaXMuX2EgfTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9QZXJjZW50YWdlUmdiU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fYSA9PSAxKSA/XG4gICAgICAgICAgICAgIFwicmdiKFwiICArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX3IsIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2csIDI1NSkgKiAxMDApICsgXCIlLCBcIiArIG1hdGhSb3VuZChib3VuZDAxKHRoaXMuX2IsIDI1NSkgKiAxMDApICsgXCIlKVwiIDpcbiAgICAgICAgICAgICAgXCJyZ2JhKFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fciwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fZywgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgbWF0aFJvdW5kKGJvdW5kMDEodGhpcy5fYiwgMjU1KSAqIDEwMCkgKyBcIiUsIFwiICsgdGhpcy5fcm91bmRBICsgXCIpXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHRvTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9hIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhleE5hbWVzW3JnYlRvSGV4KHRoaXMuX3IsIHRoaXMuX2csIHRoaXMuX2IsIHRydWUpXSB8fCBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9GaWx0ZXI6IGZ1bmN0aW9uKHNlY29uZENvbG9yKSB7XG4gICAgICAgICAgICB2YXIgaGV4OFN0cmluZyA9ICcjJyArIHJnYmFUb0hleCh0aGlzLl9yLCB0aGlzLl9nLCB0aGlzLl9iLCB0aGlzLl9hKTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRIZXg4U3RyaW5nID0gaGV4OFN0cmluZztcbiAgICAgICAgICAgIHZhciBncmFkaWVudFR5cGUgPSB0aGlzLl9ncmFkaWVudFR5cGUgPyBcIkdyYWRpZW50VHlwZSA9IDEsIFwiIDogXCJcIjtcblxuICAgICAgICAgICAgaWYgKHNlY29uZENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aW55Y29sb3Ioc2Vjb25kQ29sb3IpO1xuICAgICAgICAgICAgICAgIHNlY29uZEhleDhTdHJpbmcgPSBzLnRvSGV4OFN0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoXCIrZ3JhZGllbnRUeXBlK1wic3RhcnRDb2xvcnN0cj1cIitoZXg4U3RyaW5nK1wiLGVuZENvbG9yc3RyPVwiK3NlY29uZEhleDhTdHJpbmcrXCIpXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXRTZXQgPSAhIWZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLl9mb3JtYXQ7XG5cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoYXNBbHBoYSA9IHRoaXMuX2EgPCAxICYmIHRoaXMuX2EgPj0gMDtcbiAgICAgICAgICAgIHZhciBuZWVkc0FscGhhRm9ybWF0ID0gIWZvcm1hdFNldCAmJiBoYXNBbHBoYSAmJiAoZm9ybWF0ID09PSBcImhleFwiIHx8IGZvcm1hdCA9PT0gXCJoZXg2XCIgfHwgZm9ybWF0ID09PSBcImhleDNcIiB8fCBmb3JtYXQgPT09IFwibmFtZVwiKTtcblxuICAgICAgICAgICAgaWYgKG5lZWRzQWxwaGFGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFwidHJhbnNwYXJlbnRcIiwgYWxsIG90aGVyIG5vbi1hbHBoYSBmb3JtYXRzXG4gICAgICAgICAgICAgICAgLy8gd2lsbCByZXR1cm4gcmdiYSB3aGVuIHRoZXJlIGlzIHRyYW5zcGFyZW5jeS5cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcIm5hbWVcIiAmJiB0aGlzLl9hID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTmFtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b1JnYlN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyZ2JcIikge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9SZ2JTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwicHJnYlwiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b1BlcmNlbnRhZ2VSZ2JTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4XCIgfHwgZm9ybWF0ID09PSBcImhleDZcIikge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4M1wiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiaGV4OFwiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hleDhTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b05hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiaHNsXCIpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLnRvSHNsU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImhzdlwiKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nID0gdGhpcy50b0hzdlN0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVkU3RyaW5nIHx8IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYXBwbHlNb2RpZmljYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSBmbi5hcHBseShudWxsLCBbdGhpc10uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJncykpKTtcbiAgICAgICAgICAgIHRoaXMuX3IgPSBjb2xvci5fcjtcbiAgICAgICAgICAgIHRoaXMuX2cgPSBjb2xvci5fZztcbiAgICAgICAgICAgIHRoaXMuX2IgPSBjb2xvci5fYjtcbiAgICAgICAgICAgIHRoaXMuc2V0QWxwaGEoY29sb3IuX2EpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGxpZ2h0ZW4sIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGJyaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihicmlnaHRlbiwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGFya2VuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihkYXJrZW4sIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc2F0dXJhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKGRlc2F0dXJhdGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNhdHVyYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihzYXR1cmF0ZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ3JleXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseU1vZGlmaWNhdGlvbihncmV5c2NhbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TW9kaWZpY2F0aW9uKHNwaW4sIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FwcGx5Q29tYmluYXRpb246IGZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW3RoaXNdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3MpKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFuYWxvZ291czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihhbmFsb2dvdXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oY29tcGxlbWVudCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW9ub2Nocm9tYXRpYzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbihtb25vY2hyb21hdGljLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBzcGxpdGNvbXBsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5Q29tYmluYXRpb24oc3BsaXRjb21wbGVtZW50LCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlDb21iaW5hdGlvbih0cmlhZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGV0cmFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseUNvbWJpbmF0aW9uKHRldHJhZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJZiBpbnB1dCBpcyBhbiBvYmplY3QsIGZvcmNlIDEgaW50byBcIjEuMFwiIHRvIGhhbmRsZSByYXRpb3MgcHJvcGVybHlcbiAgICAvLyBTdHJpbmcgaW5wdXQgcmVxdWlyZXMgXCIxLjBcIiBhcyBpbnB1dCwgc28gMSB3aWxsIGJlIHRyZWF0ZWQgYXMgMVxuICAgIHRpbnljb2xvci5mcm9tUmF0aW8gPSBmdW5jdGlvbihjb2xvciwgb3B0cykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBuZXdDb2xvciA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBjb2xvcikge1xuICAgICAgICAgICAgICAgIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gXCJhXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yW2ldID0gY29sb3JbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2xvcltpXSA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3JbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sb3IgPSBuZXdDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aW55Y29sb3IoY29sb3IsIG9wdHMpO1xuICAgIH07XG5cbiAgICAvLyBHaXZlbiBhIHN0cmluZyBvciBvYmplY3QsIGNvbnZlcnQgdGhhdCBpbnB1dCB0byBSR0JcbiAgICAvLyBQb3NzaWJsZSBzdHJpbmcgaW5wdXRzOlxuICAgIC8vXG4gICAgLy8gICAgIFwicmVkXCJcbiAgICAvLyAgICAgXCIjZjAwXCIgb3IgXCJmMDBcIlxuICAgIC8vICAgICBcIiNmZjAwMDBcIiBvciBcImZmMDAwMFwiXG4gICAgLy8gICAgIFwiI2ZmMDAwMDAwXCIgb3IgXCJmZjAwMDAwMFwiXG4gICAgLy8gICAgIFwicmdiIDI1NSAwIDBcIiBvciBcInJnYiAoMjU1LCAwLCAwKVwiXG4gICAgLy8gICAgIFwicmdiIDEuMCAwIDBcIiBvciBcInJnYiAoMSwgMCwgMClcIlxuICAgIC8vICAgICBcInJnYmEgKDI1NSwgMCwgMCwgMSlcIiBvciBcInJnYmEgMjU1LCAwLCAwLCAxXCJcbiAgICAvLyAgICAgXCJyZ2JhICgxLjAsIDAsIDAsIDEpXCIgb3IgXCJyZ2JhIDEuMCwgMCwgMCwgMVwiXG4gICAgLy8gICAgIFwiaHNsKDAsIDEwMCUsIDUwJSlcIiBvciBcImhzbCAwIDEwMCUgNTAlXCJcbiAgICAvLyAgICAgXCJoc2xhKDAsIDEwMCUsIDUwJSwgMSlcIiBvciBcImhzbGEgMCAxMDAlIDUwJSwgMVwiXG4gICAgLy8gICAgIFwiaHN2KDAsIDEwMCUsIDEwMCUpXCIgb3IgXCJoc3YgMCAxMDAlIDEwMCVcIlxuICAgIC8vXG4gICAgZnVuY3Rpb24gaW5wdXRUb1JHQihjb2xvcikge1xuXG4gICAgICAgIHZhciByZ2IgPSB7IHI6IDAsIGc6IDAsIGI6IDAgfTtcbiAgICAgICAgdmFyIGEgPSAxO1xuICAgICAgICB2YXIgb2sgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29sb3IgPSBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiclwiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcImdcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJiXCIpKSB7XG4gICAgICAgICAgICAgICAgcmdiID0gcmdiVG9SZ2IoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IFN0cmluZyhjb2xvci5yKS5zdWJzdHIoLTEpID09PSBcIiVcIiA/IFwicHJnYlwiIDogXCJyZ2JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yLmhhc093blByb3BlcnR5KFwiaFwiKSAmJiBjb2xvci5oYXNPd25Qcm9wZXJ0eShcInNcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJ2XCIpKSB7XG4gICAgICAgICAgICAgICAgY29sb3IucyA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iucyk7XG4gICAgICAgICAgICAgICAgY29sb3IudiA9IGNvbnZlcnRUb1BlcmNlbnRhZ2UoY29sb3Iudik7XG4gICAgICAgICAgICAgICAgcmdiID0gaHN2VG9SZ2IoY29sb3IuaCwgY29sb3IucywgY29sb3Iudik7XG4gICAgICAgICAgICAgICAgb2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiaHN2XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvci5oYXNPd25Qcm9wZXJ0eShcImhcIikgJiYgY29sb3IuaGFzT3duUHJvcGVydHkoXCJzXCIpICYmIGNvbG9yLmhhc093blByb3BlcnR5KFwibFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbG9yLnMgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLnMpO1xuICAgICAgICAgICAgICAgIGNvbG9yLmwgPSBjb252ZXJ0VG9QZXJjZW50YWdlKGNvbG9yLmwpO1xuICAgICAgICAgICAgICAgIHJnYiA9IGhzbFRvUmdiKGNvbG9yLmgsIGNvbG9yLnMsIGNvbG9yLmwpO1xuICAgICAgICAgICAgICAgIG9rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBcImhzbFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sb3IuaGFzT3duUHJvcGVydHkoXCJhXCIpKSB7XG4gICAgICAgICAgICAgICAgYSA9IGNvbG9yLmE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhID0gYm91bmRBbHBoYShhKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IG9rLFxuICAgICAgICAgICAgZm9ybWF0OiBjb2xvci5mb3JtYXQgfHwgZm9ybWF0LFxuICAgICAgICAgICAgcjogbWF0aE1pbigyNTUsIG1hdGhNYXgocmdiLnIsIDApKSxcbiAgICAgICAgICAgIGc6IG1hdGhNaW4oMjU1LCBtYXRoTWF4KHJnYi5nLCAwKSksXG4gICAgICAgICAgICBiOiBtYXRoTWluKDI1NSwgbWF0aE1heChyZ2IuYiwgMCkpLFxuICAgICAgICAgICAgYTogYVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLy8gQ29udmVyc2lvbiBGdW5jdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gYHJnYlRvSHNsYCwgYHJnYlRvSHN2YCwgYGhzbFRvUmdiYCwgYGhzdlRvUmdiYCBtb2RpZmllZCBmcm9tOlxuICAgIC8vIDxodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0PlxuXG4gICAgLy8gYHJnYlRvUmdiYFxuICAgIC8vIEhhbmRsZSBib3VuZHMgLyBwZXJjZW50YWdlIGNoZWNraW5nIHRvIGNvbmZvcm0gdG8gQ1NTIGNvbG9yIHNwZWNcbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8+XG4gICAgLy8gKkFzc3VtZXM6KiByLCBnLCBiIGluIFswLCAyNTVdIG9yIFswLCAxXVxuICAgIC8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gWzAsIDI1NV1cbiAgICBmdW5jdGlvbiByZ2JUb1JnYihyLCBnLCBiKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IGJvdW5kMDEociwgMjU1KSAqIDI1NSxcbiAgICAgICAgICAgIGc6IGJvdW5kMDEoZywgMjU1KSAqIDI1NSxcbiAgICAgICAgICAgIGI6IGJvdW5kMDEoYiwgMjU1KSAqIDI1NVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGByZ2JUb0hzbGBcbiAgICAvLyBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLlxuICAgIC8vICpBc3N1bWVzOiogciwgZywgYW5kIGIgYXJlIGNvbnRhaW5lZCBpbiBbMCwgMjU1XSBvciBbMCwgMV1cbiAgICAvLyAqUmV0dXJuczoqIHsgaCwgcywgbCB9IGluIFswLDFdXG4gICAgZnVuY3Rpb24gcmdiVG9Ic2wociwgZywgYikge1xuXG4gICAgICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICAgICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgICAgIHZhciBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICAgIGlmKG1heCA9PSBtaW4pIHtcbiAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgICAgICBzd2l0Y2gobWF4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHIgLSBnKSAvIGQgKyA0OyBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaCAvPSA2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgaDogaCwgczogcywgbDogbCB9O1xuICAgIH1cblxuICAgIC8vIGBoc2xUb1JnYmBcbiAgICAvLyBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLlxuICAgIC8vICpBc3N1bWVzOiogaCBpcyBjb250YWluZWQgaW4gWzAsIDFdIG9yIFswLCAzNjBdIGFuZCBzIGFuZCBsIGFyZSBjb250YWluZWQgWzAsIDFdIG9yIFswLCAxMDBdXG4gICAgLy8gKlJldHVybnM6KiB7IHIsIGcsIGIgfSBpbiB0aGUgc2V0IFswLCAyNTVdXG4gICAgZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICAgICAgICB2YXIgciwgZywgYjtcblxuICAgICAgICBoID0gYm91bmQwMShoLCAzNjApO1xuICAgICAgICBzID0gYm91bmQwMShzLCAxMDApO1xuICAgICAgICBsID0gYm91bmQwMShsLCAxMDApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcbiAgICAgICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xuICAgICAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYocyA9PT0gMCkge1xuICAgICAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICAgICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEvMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG4gICAgfVxuXG4gICAgLy8gYHJnYlRvSHN2YFxuICAgIC8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB2YWx1ZSB0byBIU1ZcbiAgICAvLyAqQXNzdW1lczoqIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XSBvciBbMCwgMV1cbiAgICAvLyAqUmV0dXJuczoqIHsgaCwgcywgdiB9IGluIFswLDFdXG4gICAgZnVuY3Rpb24gcmdiVG9Ic3YociwgZywgYikge1xuXG4gICAgICAgIHIgPSBib3VuZDAxKHIsIDI1NSk7XG4gICAgICAgIGcgPSBib3VuZDAxKGcsIDI1NSk7XG4gICAgICAgIGIgPSBib3VuZDAxKGIsIDI1NSk7XG5cbiAgICAgICAgdmFyIG1heCA9IG1hdGhNYXgociwgZywgYiksIG1pbiA9IG1hdGhNaW4ociwgZywgYik7XG4gICAgICAgIHZhciBoLCBzLCB2ID0gbWF4O1xuXG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbWF4ID09PSAwID8gMCA6IGQgLyBtYXg7XG5cbiAgICAgICAgaWYobWF4ID09IG1pbikge1xuICAgICAgICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaChtYXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSAvIGQgKyAyOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCAvPSA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGg6IGgsIHM6IHMsIHY6IHYgfTtcbiAgICB9XG5cbiAgICAvLyBgaHN2VG9SZ2JgXG4gICAgLy8gQ29udmVydHMgYW4gSFNWIGNvbG9yIHZhbHVlIHRvIFJHQi5cbiAgICAvLyAqQXNzdW1lczoqIGggaXMgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMzYwXSBhbmQgcyBhbmQgdiBhcmUgY29udGFpbmVkIGluIFswLCAxXSBvciBbMCwgMTAwXVxuICAgIC8vICpSZXR1cm5zOiogeyByLCBnLCBiIH0gaW4gdGhlIHNldCBbMCwgMjU1XVxuICAgICBmdW5jdGlvbiBoc3ZUb1JnYihoLCBzLCB2KSB7XG5cbiAgICAgICAgaCA9IGJvdW5kMDEoaCwgMzYwKSAqIDY7XG4gICAgICAgIHMgPSBib3VuZDAxKHMsIDEwMCk7XG4gICAgICAgIHYgPSBib3VuZDAxKHYsIDEwMCk7XG5cbiAgICAgICAgdmFyIGkgPSBtYXRoLmZsb29yKGgpLFxuICAgICAgICAgICAgZiA9IGggLSBpLFxuICAgICAgICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgICAgICAgcSA9IHYgKiAoMSAtIGYgKiBzKSxcbiAgICAgICAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyksXG4gICAgICAgICAgICBtb2QgPSBpICUgNixcbiAgICAgICAgICAgIHIgPSBbdiwgcSwgcCwgcCwgdCwgdl1bbW9kXSxcbiAgICAgICAgICAgIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXSxcbiAgICAgICAgICAgIGIgPSBbcCwgcCwgdCwgdiwgdiwgcV1bbW9kXTtcblxuICAgICAgICByZXR1cm4geyByOiByICogMjU1LCBnOiBnICogMjU1LCBiOiBiICogMjU1IH07XG4gICAgfVxuXG4gICAgLy8gYHJnYlRvSGV4YFxuICAgIC8vIENvbnZlcnRzIGFuIFJHQiBjb2xvciB0byBoZXhcbiAgICAvLyBBc3N1bWVzIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuICAgIC8vIFJldHVybnMgYSAzIG9yIDYgY2hhcmFjdGVyIGhleFxuICAgIGZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIsIGFsbG93M0NoYXIpIHtcblxuICAgICAgICB2YXIgaGV4ID0gW1xuICAgICAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgIHBhZDIobWF0aFJvdW5kKGcpLnRvU3RyaW5nKDE2KSksXG4gICAgICAgICAgICBwYWQyKG1hdGhSb3VuZChiKS50b1N0cmluZygxNikpXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgMyBjaGFyYWN0ZXIgaGV4IGlmIHBvc3NpYmxlXG4gICAgICAgIGlmIChhbGxvdzNDaGFyICYmIGhleFswXS5jaGFyQXQoMCkgPT0gaGV4WzBdLmNoYXJBdCgxKSAmJiBoZXhbMV0uY2hhckF0KDApID09IGhleFsxXS5jaGFyQXQoMSkgJiYgaGV4WzJdLmNoYXJBdCgwKSA9PSBoZXhbMl0uY2hhckF0KDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4WzBdLmNoYXJBdCgwKSArIGhleFsxXS5jaGFyQXQoMCkgKyBoZXhbMl0uY2hhckF0KDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICAgICAgLy8gYHJnYmFUb0hleGBcbiAgICAgICAgLy8gQ29udmVydHMgYW4gUkdCQSBjb2xvciBwbHVzIGFscGhhIHRyYW5zcGFyZW5jeSB0byBoZXhcbiAgICAgICAgLy8gQXNzdW1lcyByLCBnLCBiIGFuZCBhIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuICAgICAgICAvLyBSZXR1cm5zIGFuIDggY2hhcmFjdGVyIGhleFxuICAgICAgICBmdW5jdGlvbiByZ2JhVG9IZXgociwgZywgYiwgYSkge1xuXG4gICAgICAgICAgICB2YXIgaGV4ID0gW1xuICAgICAgICAgICAgICAgIHBhZDIoY29udmVydERlY2ltYWxUb0hleChhKSksXG4gICAgICAgICAgICAgICAgcGFkMihtYXRoUm91bmQocikudG9TdHJpbmcoMTYpKSxcbiAgICAgICAgICAgICAgICBwYWQyKG1hdGhSb3VuZChnKS50b1N0cmluZygxNikpLFxuICAgICAgICAgICAgICAgIHBhZDIobWF0aFJvdW5kKGIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHJldHVybiBoZXguam9pbihcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgLy8gYGVxdWFsc2BcbiAgICAvLyBDYW4gYmUgY2FsbGVkIHdpdGggYW55IHRpbnljb2xvciBpbnB1dFxuICAgIHRpbnljb2xvci5lcXVhbHMgPSBmdW5jdGlvbiAoY29sb3IxLCBjb2xvcjIpIHtcbiAgICAgICAgaWYgKCFjb2xvcjEgfHwgIWNvbG9yMikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcihjb2xvcjEpLnRvUmdiU3RyaW5nKCkgPT0gdGlueWNvbG9yKGNvbG9yMikudG9SZ2JTdHJpbmcoKTtcbiAgICB9O1xuICAgIHRpbnljb2xvci5yYW5kb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvci5mcm9tUmF0aW8oe1xuICAgICAgICAgICAgcjogbWF0aFJhbmRvbSgpLFxuICAgICAgICAgICAgZzogbWF0aFJhbmRvbSgpLFxuICAgICAgICAgICAgYjogbWF0aFJhbmRvbSgpXG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIC8vIE1vZGlmaWNhdGlvbiBGdW5jdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVGhhbmtzIHRvIGxlc3MuanMgZm9yIHNvbWUgb2YgdGhlIGJhc2ljcyBoZXJlXG4gICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9jbG91ZGhlYWQvbGVzcy5qcy9ibG9iL21hc3Rlci9saWIvbGVzcy9mdW5jdGlvbnMuanM+XG5cbiAgICBmdW5jdGlvbiBkZXNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgICAgIGhzbC5zIC09IGFtb3VudCAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdHVyYXRlKGNvbG9yLCBhbW91bnQpIHtcbiAgICAgICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCAxMCk7XG4gICAgICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgICAgIGhzbC5zICs9IGFtb3VudCAvIDEwMDtcbiAgICAgICAgaHNsLnMgPSBjbGFtcDAxKGhzbC5zKTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyZXlzY2FsZShjb2xvcikge1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKGNvbG9yKS5kZXNhdHVyYXRlKDEwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlnaHRlbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICAgICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICAgICAgaHNsLmwgKz0gYW1vdW50IC8gMTAwO1xuICAgICAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJpZ2h0ZW4oY29sb3IsIGFtb3VudCkge1xuICAgICAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICAgICAgdmFyIHJnYiA9IHRpbnljb2xvcihjb2xvcikudG9SZ2IoKTtcbiAgICAgICAgcmdiLnIgPSBtYXRoTWF4KDAsIG1hdGhNaW4oMjU1LCByZ2IuciAtIG1hdGhSb3VuZCgyNTUgKiAtIChhbW91bnQgLyAxMDApKSkpO1xuICAgICAgICByZ2IuZyA9IG1hdGhNYXgoMCwgbWF0aE1pbigyNTUsIHJnYi5nIC0gbWF0aFJvdW5kKDI1NSAqIC0gKGFtb3VudCAvIDEwMCkpKSk7XG4gICAgICAgIHJnYi5iID0gbWF0aE1heCgwLCBtYXRoTWluKDI1NSwgcmdiLmIgLSBtYXRoUm91bmQoMjU1ICogLSAoYW1vdW50IC8gMTAwKSkpKTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcihyZ2IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRhcmtlbiAoY29sb3IsIGFtb3VudCkge1xuICAgICAgICBhbW91bnQgPSAoYW1vdW50ID09PSAwKSA/IDAgOiAoYW1vdW50IHx8IDEwKTtcbiAgICAgICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICAgICAgaHNsLmwgLT0gYW1vdW50IC8gMTAwO1xuICAgICAgICBoc2wubCA9IGNsYW1wMDEoaHNsLmwpO1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG4gICAgfVxuXG4gICAgLy8gU3BpbiB0YWtlcyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGFtb3VudCB3aXRoaW4gWy0zNjAsIDM2MF0gaW5kaWNhdGluZyB0aGUgY2hhbmdlIG9mIGh1ZS5cbiAgICAvLyBWYWx1ZXMgb3V0c2lkZSBvZiB0aGlzIHJhbmdlIHdpbGwgYmUgd3JhcHBlZCBpbnRvIHRoaXMgcmFuZ2UuXG4gICAgZnVuY3Rpb24gc3Bpbihjb2xvciwgYW1vdW50KSB7XG4gICAgICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgICAgIHZhciBodWUgPSAobWF0aFJvdW5kKGhzbC5oKSArIGFtb3VudCkgJSAzNjA7XG4gICAgICAgIGhzbC5oID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcbiAgICAgICAgcmV0dXJuIHRpbnljb2xvcihoc2wpO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmF0aW9uIEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRoYW5rcyB0byBqUXVlcnkgeENvbG9yIGZvciBzb21lIG9mIHRoZSBpZGVhcyBiZWhpbmQgdGhlc2VcbiAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2luZnVzaW9uL2pRdWVyeS14Y29sb3IvYmxvYi9tYXN0ZXIvanF1ZXJ5Lnhjb2xvci5qcz5cblxuICAgIGZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICAgICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICAgICAgaHNsLmggPSAoaHNsLmggKyAxODApICUgMzYwO1xuICAgICAgICByZXR1cm4gdGlueWNvbG9yKGhzbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJpYWQoY29sb3IpIHtcbiAgICAgICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICAgICAgdmFyIGggPSBoc2wuaDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDEyMCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMjQwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGV0cmFkKGNvbG9yKSB7XG4gICAgICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgICAgIHZhciBoID0gaHNsLmg7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aW55Y29sb3IoY29sb3IpLFxuICAgICAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyA5MCkgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubCB9KSxcbiAgICAgICAgICAgIHRpbnljb2xvcih7IGg6IChoICsgMTgwKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sIH0pLFxuICAgICAgICAgICAgdGlueWNvbG9yKHsgaDogKGggKyAyNzApICUgMzYwLCBzOiBoc2wucywgbDogaHNsLmwgfSlcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpdGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgICAgICAgdmFyIGhzbCA9IHRpbnljb2xvcihjb2xvcikudG9Ic2woKTtcbiAgICAgICAgdmFyIGggPSBoc2wuaDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbnljb2xvcihjb2xvciksXG4gICAgICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDcyKSAlIDM2MCwgczogaHNsLnMsIGw6IGhzbC5sfSksXG4gICAgICAgICAgICB0aW55Y29sb3IoeyBoOiAoaCArIDIxNikgJSAzNjAsIHM6IGhzbC5zLCBsOiBoc2wubH0pXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW5hbG9nb3VzKGNvbG9yLCByZXN1bHRzLCBzbGljZXMpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgNjtcbiAgICAgICAgc2xpY2VzID0gc2xpY2VzIHx8IDMwO1xuXG4gICAgICAgIHZhciBoc2wgPSB0aW55Y29sb3IoY29sb3IpLnRvSHNsKCk7XG4gICAgICAgIHZhciBwYXJ0ID0gMzYwIC8gc2xpY2VzO1xuICAgICAgICB2YXIgcmV0ID0gW3Rpbnljb2xvcihjb2xvcildO1xuXG4gICAgICAgIGZvciAoaHNsLmggPSAoKGhzbC5oIC0gKHBhcnQgKiByZXN1bHRzID4+IDEpKSArIDcyMCkgJSAzNjA7IC0tcmVzdWx0czsgKSB7XG4gICAgICAgICAgICBoc2wuaCA9IChoc2wuaCArIHBhcnQpICUgMzYwO1xuICAgICAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKGhzbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9ub2Nocm9tYXRpYyhjb2xvciwgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCA2O1xuICAgICAgICB2YXIgaHN2ID0gdGlueWNvbG9yKGNvbG9yKS50b0hzdigpO1xuICAgICAgICB2YXIgaCA9IGhzdi5oLCBzID0gaHN2LnMsIHYgPSBoc3YudjtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgbW9kaWZpY2F0aW9uID0gMSAvIHJlc3VsdHM7XG5cbiAgICAgICAgd2hpbGUgKHJlc3VsdHMtLSkge1xuICAgICAgICAgICAgcmV0LnB1c2godGlueWNvbG9yKHsgaDogaCwgczogcywgdjogdn0pKTtcbiAgICAgICAgICAgIHYgPSAodiArIG1vZGlmaWNhdGlvbikgJSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdGlueWNvbG9yLm1peCA9IGZ1bmN0aW9uKGNvbG9yMSwgY29sb3IyLCBhbW91bnQpIHtcbiAgICAgICAgYW1vdW50ID0gKGFtb3VudCA9PT0gMCkgPyAwIDogKGFtb3VudCB8fCA1MCk7XG5cbiAgICAgICAgdmFyIHJnYjEgPSB0aW55Y29sb3IoY29sb3IxKS50b1JnYigpO1xuICAgICAgICB2YXIgcmdiMiA9IHRpbnljb2xvcihjb2xvcjIpLnRvUmdiKCk7XG5cbiAgICAgICAgdmFyIHAgPSBhbW91bnQgLyAxMDA7XG4gICAgICAgIHZhciB3ID0gcCAqIDIgLSAxO1xuICAgICAgICB2YXIgYSA9IHJnYjIuYSAtIHJnYjEuYTtcblxuICAgICAgICB2YXIgdzE7XG5cbiAgICAgICAgaWYgKHcgKiBhID09IC0xKSB7XG4gICAgICAgICAgICB3MSA9IHc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3MSA9ICh3ICsgYSkgLyAoMSArIHcgKiBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcxID0gKHcxICsgMSkgLyAyO1xuXG4gICAgICAgIHZhciB3MiA9IDEgLSB3MTtcblxuICAgICAgICB2YXIgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IHJnYjIuciAqIHcxICsgcmdiMS5yICogdzIsXG4gICAgICAgICAgICBnOiByZ2IyLmcgKiB3MSArIHJnYjEuZyAqIHcyLFxuICAgICAgICAgICAgYjogcmdiMi5iICogdzEgKyByZ2IxLmIgKiB3MixcbiAgICAgICAgICAgIGE6IHJnYjIuYSAqIHAgICsgcmdiMS5hICogKDEgLSBwKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aW55Y29sb3IocmdiYSk7XG4gICAgfTtcblxuXG4gICAgLy8gUmVhZGFiaWxpdHkgRnVuY3Rpb25zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL0FFUlQjY29sb3ItY29udHJhc3Q+XG5cbiAgICAvLyBgcmVhZGFiaWxpdHlgXG4gICAgLy8gQW5hbHl6ZSB0aGUgMiBjb2xvcnMgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgIC8vICAgIGBicmlnaHRuZXNzYDogZGlmZmVyZW5jZSBpbiBicmlnaHRuZXNzIGJldHdlZW4gdGhlIHR3byBjb2xvcnNcbiAgICAvLyAgICBgY29sb3JgOiBkaWZmZXJlbmNlIGluIGNvbG9yL2h1ZSBiZXR3ZWVuIHRoZSB0d28gY29sb3JzXG4gICAgdGlueWNvbG9yLnJlYWRhYmlsaXR5ID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgICAgICAgdmFyIGMxID0gdGlueWNvbG9yKGNvbG9yMSk7XG4gICAgICAgIHZhciBjMiA9IHRpbnljb2xvcihjb2xvcjIpO1xuICAgICAgICB2YXIgcmdiMSA9IGMxLnRvUmdiKCk7XG4gICAgICAgIHZhciByZ2IyID0gYzIudG9SZ2IoKTtcbiAgICAgICAgdmFyIGJyaWdodG5lc3NBID0gYzEuZ2V0QnJpZ2h0bmVzcygpO1xuICAgICAgICB2YXIgYnJpZ2h0bmVzc0IgPSBjMi5nZXRCcmlnaHRuZXNzKCk7XG4gICAgICAgIHZhciBjb2xvckRpZmYgPSAoXG4gICAgICAgICAgICBNYXRoLm1heChyZ2IxLnIsIHJnYjIucikgLSBNYXRoLm1pbihyZ2IxLnIsIHJnYjIucikgK1xuICAgICAgICAgICAgTWF0aC5tYXgocmdiMS5nLCByZ2IyLmcpIC0gTWF0aC5taW4ocmdiMS5nLCByZ2IyLmcpICtcbiAgICAgICAgICAgIE1hdGgubWF4KHJnYjEuYiwgcmdiMi5iKSAtIE1hdGgubWluKHJnYjEuYiwgcmdiMi5iKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBicmlnaHRuZXNzOiBNYXRoLmFicyhicmlnaHRuZXNzQSAtIGJyaWdodG5lc3NCKSxcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvckRpZmZcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gYHJlYWRhYmxlYFxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0FFUlQjY29sb3ItY29udHJhc3RcbiAgICAvLyBFbnN1cmUgdGhhdCBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGNvbG9yIGNvbWJpbmF0aW9ucyBwcm92aWRlIHN1ZmZpY2llbnQgY29udHJhc3QuXG4gICAgLy8gKkV4YW1wbGUqXG4gICAgLy8gICAgdGlueWNvbG9yLmlzUmVhZGFibGUoXCIjMDAwXCIsIFwiIzExMVwiKSA9PiBmYWxzZVxuICAgIHRpbnljb2xvci5pc1JlYWRhYmxlID0gZnVuY3Rpb24oY29sb3IxLCBjb2xvcjIpIHtcbiAgICAgICAgdmFyIHJlYWRhYmlsaXR5ID0gdGlueWNvbG9yLnJlYWRhYmlsaXR5KGNvbG9yMSwgY29sb3IyKTtcbiAgICAgICAgcmV0dXJuIHJlYWRhYmlsaXR5LmJyaWdodG5lc3MgPiAxMjUgJiYgcmVhZGFiaWxpdHkuY29sb3IgPiA1MDA7XG4gICAgfTtcblxuICAgIC8vIGBtb3N0UmVhZGFibGVgXG4gICAgLy8gR2l2ZW4gYSBiYXNlIGNvbG9yIGFuZCBhIGxpc3Qgb2YgcG9zc2libGUgZm9yZWdyb3VuZCBvciBiYWNrZ3JvdW5kXG4gICAgLy8gY29sb3JzIGZvciB0aGF0IGJhc2UsIHJldHVybnMgdGhlIG1vc3QgcmVhZGFibGUgY29sb3IuXG4gICAgLy8gKkV4YW1wbGUqXG4gICAgLy8gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZShcIiMxMjNcIiwgW1wiI2ZmZlwiLCBcIiMwMDBcIl0pID0+IFwiIzAwMFwiXG4gICAgdGlueWNvbG9yLm1vc3RSZWFkYWJsZSA9IGZ1bmN0aW9uKGJhc2VDb2xvciwgY29sb3JMaXN0KSB7XG4gICAgICAgIHZhciBiZXN0Q29sb3IgPSBudWxsO1xuICAgICAgICB2YXIgYmVzdFNjb3JlID0gMDtcbiAgICAgICAgdmFyIGJlc3RJc1JlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGNvbG9yTGlzdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBXZSBub3JtYWxpemUgYm90aCBhcm91bmQgdGhlIFwiYWNjZXB0YWJsZVwiIGJyZWFraW5nIHBvaW50LFxuICAgICAgICAgICAgLy8gYnV0IHJhbmsgYnJpZ2h0bmVzcyBjb25zdHJhc3QgaGlnaGVyIHRoYW4gaHVlLlxuXG4gICAgICAgICAgICB2YXIgcmVhZGFiaWxpdHkgPSB0aW55Y29sb3IucmVhZGFiaWxpdHkoYmFzZUNvbG9yLCBjb2xvckxpc3RbaV0pO1xuICAgICAgICAgICAgdmFyIHJlYWRhYmxlID0gcmVhZGFiaWxpdHkuYnJpZ2h0bmVzcyA+IDEyNSAmJiByZWFkYWJpbGl0eS5jb2xvciA+IDUwMDtcbiAgICAgICAgICAgIHZhciBzY29yZSA9IDMgKiAocmVhZGFiaWxpdHkuYnJpZ2h0bmVzcyAvIDEyNSkgKyAocmVhZGFiaWxpdHkuY29sb3IgLyA1MDApO1xuXG4gICAgICAgICAgICBpZiAoKHJlYWRhYmxlICYmICEgYmVzdElzUmVhZGFibGUpIHx8XG4gICAgICAgICAgICAgICAgKHJlYWRhYmxlICYmIGJlc3RJc1JlYWRhYmxlICYmIHNjb3JlID4gYmVzdFNjb3JlKSB8fFxuICAgICAgICAgICAgICAgICgoISByZWFkYWJsZSkgJiYgKCEgYmVzdElzUmVhZGFibGUpICYmIHNjb3JlID4gYmVzdFNjb3JlKSkge1xuICAgICAgICAgICAgICAgIGJlc3RJc1JlYWRhYmxlID0gcmVhZGFibGU7XG4gICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdENvbG9yID0gdGlueWNvbG9yKGNvbG9yTGlzdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RDb2xvcjtcbiAgICB9O1xuXG5cbiAgICAvLyBCaWcgTGlzdCBvZiBDb2xvcnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yPlxuICAgIHZhciBuYW1lcyA9IHRpbnljb2xvci5uYW1lcyA9IHtcbiAgICAgICAgYWxpY2VibHVlOiBcImYwZjhmZlwiLFxuICAgICAgICBhbnRpcXVld2hpdGU6IFwiZmFlYmQ3XCIsXG4gICAgICAgIGFxdWE6IFwiMGZmXCIsXG4gICAgICAgIGFxdWFtYXJpbmU6IFwiN2ZmZmQ0XCIsXG4gICAgICAgIGF6dXJlOiBcImYwZmZmZlwiLFxuICAgICAgICBiZWlnZTogXCJmNWY1ZGNcIixcbiAgICAgICAgYmlzcXVlOiBcImZmZTRjNFwiLFxuICAgICAgICBibGFjazogXCIwMDBcIixcbiAgICAgICAgYmxhbmNoZWRhbG1vbmQ6IFwiZmZlYmNkXCIsXG4gICAgICAgIGJsdWU6IFwiMDBmXCIsXG4gICAgICAgIGJsdWV2aW9sZXQ6IFwiOGEyYmUyXCIsXG4gICAgICAgIGJyb3duOiBcImE1MmEyYVwiLFxuICAgICAgICBidXJseXdvb2Q6IFwiZGViODg3XCIsXG4gICAgICAgIGJ1cm50c2llbm5hOiBcImVhN2U1ZFwiLFxuICAgICAgICBjYWRldGJsdWU6IFwiNWY5ZWEwXCIsXG4gICAgICAgIGNoYXJ0cmV1c2U6IFwiN2ZmZjAwXCIsXG4gICAgICAgIGNob2NvbGF0ZTogXCJkMjY5MWVcIixcbiAgICAgICAgY29yYWw6IFwiZmY3ZjUwXCIsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiBcIjY0OTVlZFwiLFxuICAgICAgICBjb3Juc2lsazogXCJmZmY4ZGNcIixcbiAgICAgICAgY3JpbXNvbjogXCJkYzE0M2NcIixcbiAgICAgICAgY3lhbjogXCIwZmZcIixcbiAgICAgICAgZGFya2JsdWU6IFwiMDAwMDhiXCIsXG4gICAgICAgIGRhcmtjeWFuOiBcIjAwOGI4YlwiLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiBcImI4ODYwYlwiLFxuICAgICAgICBkYXJrZ3JheTogXCJhOWE5YTlcIixcbiAgICAgICAgZGFya2dyZWVuOiBcIjAwNjQwMFwiLFxuICAgICAgICBkYXJrZ3JleTogXCJhOWE5YTlcIixcbiAgICAgICAgZGFya2toYWtpOiBcImJkYjc2YlwiLFxuICAgICAgICBkYXJrbWFnZW50YTogXCI4YjAwOGJcIixcbiAgICAgICAgZGFya29saXZlZ3JlZW46IFwiNTU2YjJmXCIsXG4gICAgICAgIGRhcmtvcmFuZ2U6IFwiZmY4YzAwXCIsXG4gICAgICAgIGRhcmtvcmNoaWQ6IFwiOTkzMmNjXCIsXG4gICAgICAgIGRhcmtyZWQ6IFwiOGIwMDAwXCIsXG4gICAgICAgIGRhcmtzYWxtb246IFwiZTk5NjdhXCIsXG4gICAgICAgIGRhcmtzZWFncmVlbjogXCI4ZmJjOGZcIixcbiAgICAgICAgZGFya3NsYXRlYmx1ZTogXCI0ODNkOGJcIixcbiAgICAgICAgZGFya3NsYXRlZ3JheTogXCIyZjRmNGZcIixcbiAgICAgICAgZGFya3NsYXRlZ3JleTogXCIyZjRmNGZcIixcbiAgICAgICAgZGFya3R1cnF1b2lzZTogXCIwMGNlZDFcIixcbiAgICAgICAgZGFya3Zpb2xldDogXCI5NDAwZDNcIixcbiAgICAgICAgZGVlcHBpbms6IFwiZmYxNDkzXCIsXG4gICAgICAgIGRlZXBza3libHVlOiBcIjAwYmZmZlwiLFxuICAgICAgICBkaW1ncmF5OiBcIjY5Njk2OVwiLFxuICAgICAgICBkaW1ncmV5OiBcIjY5Njk2OVwiLFxuICAgICAgICBkb2RnZXJibHVlOiBcIjFlOTBmZlwiLFxuICAgICAgICBmaXJlYnJpY2s6IFwiYjIyMjIyXCIsXG4gICAgICAgIGZsb3JhbHdoaXRlOiBcImZmZmFmMFwiLFxuICAgICAgICBmb3Jlc3RncmVlbjogXCIyMjhiMjJcIixcbiAgICAgICAgZnVjaHNpYTogXCJmMGZcIixcbiAgICAgICAgZ2FpbnNib3JvOiBcImRjZGNkY1wiLFxuICAgICAgICBnaG9zdHdoaXRlOiBcImY4ZjhmZlwiLFxuICAgICAgICBnb2xkOiBcImZmZDcwMFwiLFxuICAgICAgICBnb2xkZW5yb2Q6IFwiZGFhNTIwXCIsXG4gICAgICAgIGdyYXk6IFwiODA4MDgwXCIsXG4gICAgICAgIGdyZWVuOiBcIjAwODAwMFwiLFxuICAgICAgICBncmVlbnllbGxvdzogXCJhZGZmMmZcIixcbiAgICAgICAgZ3JleTogXCI4MDgwODBcIixcbiAgICAgICAgaG9uZXlkZXc6IFwiZjBmZmYwXCIsXG4gICAgICAgIGhvdHBpbms6IFwiZmY2OWI0XCIsXG4gICAgICAgIGluZGlhbnJlZDogXCJjZDVjNWNcIixcbiAgICAgICAgaW5kaWdvOiBcIjRiMDA4MlwiLFxuICAgICAgICBpdm9yeTogXCJmZmZmZjBcIixcbiAgICAgICAga2hha2k6IFwiZjBlNjhjXCIsXG4gICAgICAgIGxhdmVuZGVyOiBcImU2ZTZmYVwiLFxuICAgICAgICBsYXZlbmRlcmJsdXNoOiBcImZmZjBmNVwiLFxuICAgICAgICBsYXduZ3JlZW46IFwiN2NmYzAwXCIsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogXCJmZmZhY2RcIixcbiAgICAgICAgbGlnaHRibHVlOiBcImFkZDhlNlwiLFxuICAgICAgICBsaWdodGNvcmFsOiBcImYwODA4MFwiLFxuICAgICAgICBsaWdodGN5YW46IFwiZTBmZmZmXCIsXG4gICAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcImZhZmFkMlwiLFxuICAgICAgICBsaWdodGdyYXk6IFwiZDNkM2QzXCIsXG4gICAgICAgIGxpZ2h0Z3JlZW46IFwiOTBlZTkwXCIsXG4gICAgICAgIGxpZ2h0Z3JleTogXCJkM2QzZDNcIixcbiAgICAgICAgbGlnaHRwaW5rOiBcImZmYjZjMVwiLFxuICAgICAgICBsaWdodHNhbG1vbjogXCJmZmEwN2FcIixcbiAgICAgICAgbGlnaHRzZWFncmVlbjogXCIyMGIyYWFcIixcbiAgICAgICAgbGlnaHRza3libHVlOiBcIjg3Y2VmYVwiLFxuICAgICAgICBsaWdodHNsYXRlZ3JheTogXCI3ODlcIixcbiAgICAgICAgbGlnaHRzbGF0ZWdyZXk6IFwiNzg5XCIsXG4gICAgICAgIGxpZ2h0c3RlZWxibHVlOiBcImIwYzRkZVwiLFxuICAgICAgICBsaWdodHllbGxvdzogXCJmZmZmZTBcIixcbiAgICAgICAgbGltZTogXCIwZjBcIixcbiAgICAgICAgbGltZWdyZWVuOiBcIjMyY2QzMlwiLFxuICAgICAgICBsaW5lbjogXCJmYWYwZTZcIixcbiAgICAgICAgbWFnZW50YTogXCJmMGZcIixcbiAgICAgICAgbWFyb29uOiBcIjgwMDAwMFwiLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiBcIjY2Y2RhYVwiLFxuICAgICAgICBtZWRpdW1ibHVlOiBcIjAwMDBjZFwiLFxuICAgICAgICBtZWRpdW1vcmNoaWQ6IFwiYmE1NWQzXCIsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogXCI5MzcwZGJcIixcbiAgICAgICAgbWVkaXVtc2VhZ3JlZW46IFwiM2NiMzcxXCIsXG4gICAgICAgIG1lZGl1bXNsYXRlYmx1ZTogXCI3YjY4ZWVcIixcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiMDBmYTlhXCIsXG4gICAgICAgIG1lZGl1bXR1cnF1b2lzZTogXCI0OGQxY2NcIixcbiAgICAgICAgbWVkaXVtdmlvbGV0cmVkOiBcImM3MTU4NVwiLFxuICAgICAgICBtaWRuaWdodGJsdWU6IFwiMTkxOTcwXCIsXG4gICAgICAgIG1pbnRjcmVhbTogXCJmNWZmZmFcIixcbiAgICAgICAgbWlzdHlyb3NlOiBcImZmZTRlMVwiLFxuICAgICAgICBtb2NjYXNpbjogXCJmZmU0YjVcIixcbiAgICAgICAgbmF2YWpvd2hpdGU6IFwiZmZkZWFkXCIsXG4gICAgICAgIG5hdnk6IFwiMDAwMDgwXCIsXG4gICAgICAgIG9sZGxhY2U6IFwiZmRmNWU2XCIsXG4gICAgICAgIG9saXZlOiBcIjgwODAwMFwiLFxuICAgICAgICBvbGl2ZWRyYWI6IFwiNmI4ZTIzXCIsXG4gICAgICAgIG9yYW5nZTogXCJmZmE1MDBcIixcbiAgICAgICAgb3JhbmdlcmVkOiBcImZmNDUwMFwiLFxuICAgICAgICBvcmNoaWQ6IFwiZGE3MGQ2XCIsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6IFwiZWVlOGFhXCIsXG4gICAgICAgIHBhbGVncmVlbjogXCI5OGZiOThcIixcbiAgICAgICAgcGFsZXR1cnF1b2lzZTogXCJhZmVlZWVcIixcbiAgICAgICAgcGFsZXZpb2xldHJlZDogXCJkYjcwOTNcIixcbiAgICAgICAgcGFwYXlhd2hpcDogXCJmZmVmZDVcIixcbiAgICAgICAgcGVhY2hwdWZmOiBcImZmZGFiOVwiLFxuICAgICAgICBwZXJ1OiBcImNkODUzZlwiLFxuICAgICAgICBwaW5rOiBcImZmYzBjYlwiLFxuICAgICAgICBwbHVtOiBcImRkYTBkZFwiLFxuICAgICAgICBwb3dkZXJibHVlOiBcImIwZTBlNlwiLFxuICAgICAgICBwdXJwbGU6IFwiODAwMDgwXCIsXG4gICAgICAgIHJlZDogXCJmMDBcIixcbiAgICAgICAgcm9zeWJyb3duOiBcImJjOGY4ZlwiLFxuICAgICAgICByb3lhbGJsdWU6IFwiNDE2OWUxXCIsXG4gICAgICAgIHNhZGRsZWJyb3duOiBcIjhiNDUxM1wiLFxuICAgICAgICBzYWxtb246IFwiZmE4MDcyXCIsXG4gICAgICAgIHNhbmR5YnJvd246IFwiZjRhNDYwXCIsXG4gICAgICAgIHNlYWdyZWVuOiBcIjJlOGI1N1wiLFxuICAgICAgICBzZWFzaGVsbDogXCJmZmY1ZWVcIixcbiAgICAgICAgc2llbm5hOiBcImEwNTIyZFwiLFxuICAgICAgICBzaWx2ZXI6IFwiYzBjMGMwXCIsXG4gICAgICAgIHNreWJsdWU6IFwiODdjZWViXCIsXG4gICAgICAgIHNsYXRlYmx1ZTogXCI2YTVhY2RcIixcbiAgICAgICAgc2xhdGVncmF5OiBcIjcwODA5MFwiLFxuICAgICAgICBzbGF0ZWdyZXk6IFwiNzA4MDkwXCIsXG4gICAgICAgIHNub3c6IFwiZmZmYWZhXCIsXG4gICAgICAgIHNwcmluZ2dyZWVuOiBcIjAwZmY3ZlwiLFxuICAgICAgICBzdGVlbGJsdWU6IFwiNDY4MmI0XCIsXG4gICAgICAgIHRhbjogXCJkMmI0OGNcIixcbiAgICAgICAgdGVhbDogXCIwMDgwODBcIixcbiAgICAgICAgdGhpc3RsZTogXCJkOGJmZDhcIixcbiAgICAgICAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICAgICAgICB0dXJxdW9pc2U6IFwiNDBlMGQwXCIsXG4gICAgICAgIHZpb2xldDogXCJlZTgyZWVcIixcbiAgICAgICAgd2hlYXQ6IFwiZjVkZWIzXCIsXG4gICAgICAgIHdoaXRlOiBcImZmZlwiLFxuICAgICAgICB3aGl0ZXNtb2tlOiBcImY1ZjVmNVwiLFxuICAgICAgICB5ZWxsb3c6IFwiZmYwXCIsXG4gICAgICAgIHllbGxvd2dyZWVuOiBcIjlhY2QzMlwiXG4gICAgfTtcblxuICAgIC8vIE1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgY29sb3JzIHZpYSBgaGV4TmFtZXNbaGV4XWBcbiAgICB2YXIgaGV4TmFtZXMgPSB0aW55Y29sb3IuaGV4TmFtZXMgPSBmbGlwKG5hbWVzKTtcblxuXG4gICAgLy8gVXRpbGl0aWVzXG4gICAgLy8gLS0tLS0tLS0tXG5cbiAgICAvLyBgeyAnbmFtZTEnOiAndmFsMScgfWAgYmVjb21lcyBgeyAndmFsMSc6ICduYW1lMScgfWBcbiAgICBmdW5jdGlvbiBmbGlwKG8pIHtcbiAgICAgICAgdmFyIGZsaXBwZWQgPSB7IH07XG4gICAgICAgIGZvciAodmFyIGkgaW4gbykge1xuICAgICAgICAgICAgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICBmbGlwcGVkW29baV1dID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxpcHBlZDtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSB2YWxpZCBhbHBoYSB2YWx1ZSBbMCwxXSB3aXRoIGFsbCBpbnZhbGlkIHZhbHVlcyBiZWluZyBzZXQgdG8gMVxuICAgIGZ1bmN0aW9uIGJvdW5kQWxwaGEoYSkge1xuICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgICAgICBpZiAoaXNOYU4oYSkgfHwgYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgICAgIGEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnB1dCBmcm9tIFswLCBuXSBhbmQgcmV0dXJuIGl0IGFzIFswLCAxXVxuICAgIGZ1bmN0aW9uIGJvdW5kMDEobiwgbWF4KSB7XG4gICAgICAgIGlmIChpc09uZVBvaW50WmVybyhuKSkgeyBuID0gXCIxMDAlXCI7IH1cblxuICAgICAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBpc1BlcmNlbnRhZ2Uobik7XG4gICAgICAgIG4gPSBtYXRoTWluKG1heCwgbWF0aE1heCgwLCBwYXJzZUZsb2F0KG4pKSk7XG5cbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IHBlcmNlbnRhZ2UgaW50byBudW1iZXJcbiAgICAgICAgaWYgKHByb2Nlc3NQZXJjZW50KSB7XG4gICAgICAgICAgICBuID0gcGFyc2VJbnQobiAqIG1heCwgMTApIC8gMTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yc1xuICAgICAgICBpZiAoKG1hdGguYWJzKG4gLSBtYXgpIDwgMC4wMDAwMDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgaW50byBbMCwgMV0gcmFuZ2UgaWYgaXQgaXNuJ3QgYWxyZWFkeVxuICAgICAgICByZXR1cm4gKG4gJSBtYXgpIC8gcGFyc2VGbG9hdChtYXgpO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgIGZ1bmN0aW9uIGNsYW1wMDEodmFsKSB7XG4gICAgICAgIHJldHVybiBtYXRoTWluKDEsIG1hdGhNYXgoMCwgdmFsKSk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgYSBiYXNlLTE2IGhleCB2YWx1ZSBpbnRvIGEgYmFzZS0xMCBpbnRlZ2VyXG4gICAgZnVuY3Rpb24gcGFyc2VJbnRGcm9tSGV4KHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxNik7XG4gICAgfVxuXG4gICAgLy8gTmVlZCB0byBoYW5kbGUgMS4wIGFzIDEwMCUsIHNpbmNlIG9uY2UgaXQgaXMgYSBudW1iZXIsIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UgYmV0d2VlbiBpdCBhbmQgMVxuICAgIC8vIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc0MjIwNzIvamF2YXNjcmlwdC1ob3ctdG8tZGV0ZWN0LW51bWJlci1hcy1hLWRlY2ltYWwtaW5jbHVkaW5nLTEtMD5cbiAgICBmdW5jdGlvbiBpc09uZVBvaW50WmVybyhuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignLicpICE9IC0xICYmIHBhcnNlRmxvYXQobikgPT09IDE7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHN0cmluZyBwYXNzZWQgaW4gaXMgYSBwZXJjZW50YWdlXG4gICAgZnVuY3Rpb24gaXNQZXJjZW50YWdlKG4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4uaW5kZXhPZignJScpICE9IC0xO1xuICAgIH1cblxuICAgIC8vIEZvcmNlIGEgaGV4IHZhbHVlIHRvIGhhdmUgMiBjaGFyYWN0ZXJzXG4gICAgZnVuY3Rpb24gcGFkMihjKSB7XG4gICAgICAgIHJldHVybiBjLmxlbmd0aCA9PSAxID8gJzAnICsgYyA6ICcnICsgYztcbiAgICB9XG5cbiAgICAvLyBSZXBsYWNlIGEgZGVjaW1hbCB3aXRoIGl0J3MgcGVyY2VudGFnZSB2YWx1ZVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb1BlcmNlbnRhZ2Uobikge1xuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgICBuID0gKG4gKiAxMDApICsgXCIlXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBoZXggdmFsdWVcbiAgICBmdW5jdGlvbiBjb252ZXJ0RGVjaW1hbFRvSGV4KGQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChkKSAqIDI1NSkudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBhIGhleCB2YWx1ZSB0byBhIGRlY2ltYWxcbiAgICBmdW5jdGlvbiBjb252ZXJ0SGV4VG9EZWNpbWFsKGgpIHtcbiAgICAgICAgcmV0dXJuIChwYXJzZUludEZyb21IZXgoaCkgLyAyNTUpO1xuICAgIH1cblxuICAgIHZhciBtYXRjaGVycyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyA8aHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzPlxuICAgICAgICB2YXIgQ1NTX0lOVEVHRVIgPSBcIlstXFxcXCtdP1xcXFxkKyU/XCI7XG5cbiAgICAgICAgLy8gPGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdmFsdWVzLyNudW1iZXItdmFsdWU+XG4gICAgICAgIHZhciBDU1NfTlVNQkVSID0gXCJbLVxcXFwrXT9cXFxcZCpcXFxcLlxcXFxkKyU/XCI7XG5cbiAgICAgICAgLy8gQWxsb3cgcG9zaXRpdmUvbmVnYXRpdmUgaW50ZWdlci9udW1iZXIuICBEb24ndCBjYXB0dXJlIHRoZSBlaXRoZXIvb3IsIGp1c3QgdGhlIGVudGlyZSBvdXRjb21lLlxuICAgICAgICB2YXIgQ1NTX1VOSVQgPSBcIig/OlwiICsgQ1NTX05VTUJFUiArIFwiKXwoPzpcIiArIENTU19JTlRFR0VSICsgXCIpXCI7XG5cbiAgICAgICAgLy8gQWN0dWFsIG1hdGNoaW5nLlxuICAgICAgICAvLyBQYXJlbnRoZXNlcyBhbmQgY29tbWFzIGFyZSBvcHRpb25hbCwgYnV0IG5vdCByZXF1aXJlZC5cbiAgICAgICAgLy8gV2hpdGVzcGFjZSBjYW4gdGFrZSB0aGUgcGxhY2Ugb2YgY29tbWFzIG9yIG9wZW5pbmcgcGFyZW5cbiAgICAgICAgdmFyIFBFUk1JU1NJVkVfTUFUQ0gzID0gXCJbXFxcXHN8XFxcXChdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpWyx8XFxcXHNdKyhcIiArIENTU19VTklUICsgXCIpXFxcXHMqXFxcXCk/XCI7XG4gICAgICAgIHZhciBQRVJNSVNTSVZFX01BVENINCA9IFwiW1xcXFxzfFxcXFwoXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVssfFxcXFxzXSsoXCIgKyBDU1NfVU5JVCArIFwiKVxcXFxzKlxcXFwpP1wiO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZ2I6IG5ldyBSZWdFeHAoXCJyZ2JcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgICAgIHJnYmE6IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgICAgICBoc2w6IG5ldyBSZWdFeHAoXCJoc2xcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgICAgIGhzbGE6IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBQRVJNSVNTSVZFX01BVENINCksXG4gICAgICAgICAgICBoc3Y6IG5ldyBSZWdFeHAoXCJoc3ZcIiArIFBFUk1JU1NJVkVfTUFUQ0gzKSxcbiAgICAgICAgICAgIGhleDM6IC9eKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC8sXG4gICAgICAgICAgICBoZXg2OiAvXihbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KSQvLFxuICAgICAgICAgICAgaGV4ODogL14oWzAtOWEtZkEtRl17Mn0pKFswLTlhLWZBLUZdezJ9KShbMC05YS1mQS1GXXsyfSkoWzAtOWEtZkEtRl17Mn0pJC9cbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgLy8gYHN0cmluZ0lucHV0VG9PYmplY3RgXG4gICAgLy8gUGVybWlzc2l2ZSBzdHJpbmcgcGFyc2luZy4gIFRha2UgaW4gYSBudW1iZXIgb2YgZm9ybWF0cywgYW5kIG91dHB1dCBhbiBvYmplY3RcbiAgICAvLyBiYXNlZCBvbiBkZXRlY3RlZCBmb3JtYXQuICBSZXR1cm5zIGB7IHIsIGcsIGIgfWAgb3IgYHsgaCwgcywgbCB9YCBvciBgeyBoLCBzLCB2fWBcbiAgICBmdW5jdGlvbiBzdHJpbmdJbnB1dFRvT2JqZWN0KGNvbG9yKSB7XG5cbiAgICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKHRyaW1MZWZ0LCcnKS5yZXBsYWNlKHRyaW1SaWdodCwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBuYW1lZCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZXNbY29sb3JdKSB7XG4gICAgICAgICAgICBjb2xvciA9IG5hbWVzW2NvbG9yXTtcbiAgICAgICAgICAgIG5hbWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xvciA9PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwLCBmb3JtYXQ6IFwibmFtZVwiIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggc3RyaW5nIGlucHV0IHVzaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICAgIC8vIEtlZXAgbW9zdCBvZiB0aGUgbnVtYmVyIGJvdW5kaW5nIG91dCBvZiB0aGlzIGZ1bmN0aW9uIC0gZG9uJ3Qgd29ycnkgYWJvdXQgWzAsMV0gb3IgWzAsMTAwXSBvciBbMCwzNjBdXG4gICAgICAgIC8vIEp1c3QgcmV0dXJuIGFuIG9iamVjdCBhbmQgbGV0IHRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBoYW5kbGUgdGhhdC5cbiAgICAgICAgLy8gVGhpcyB3YXkgdGhlIHJlc3VsdCB3aWxsIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHRpbnljb2xvciBpcyBpbml0aWFsaXplZCB3aXRoIHN0cmluZyBvciBvYmplY3QuXG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHI6IG1hdGNoWzFdLCBnOiBtYXRjaFsyXSwgYjogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgbDogbWF0Y2hbM10sIGE6IG1hdGNoWzRdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzdi5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGg6IG1hdGNoWzFdLCBzOiBtYXRjaFsyXSwgdjogbWF0Y2hbM10gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYTogY29udmVydEhleFRvRGVjaW1hbChtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgcjogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBnOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFs0XSksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBuYW1lZCA/IFwibmFtZVwiIDogXCJoZXg4XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSksXG4gICAgICAgICAgICAgICAgZzogcGFyc2VJbnRGcm9tSGV4KG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBiOiBwYXJzZUludEZyb21IZXgobWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IHBhcnNlSW50RnJvbUhleChtYXRjaFsxXSArICcnICsgbWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50RnJvbUhleChtYXRjaFsyXSArICcnICsgbWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIGI6IHBhcnNlSW50RnJvbUhleChtYXRjaFszXSArICcnICsgbWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogbmFtZWQgPyBcIm5hbWVcIiA6IFwiaGV4XCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2luZG93LnRpbnljb2xvciA9IHRpbnljb2xvcjtcbiAgICB9KSgpO1xuXG5cbiAgICAkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCQuZm4uc3BlY3RydW0ubG9hZCkge1xuICAgICAgICAgICAgJC5mbi5zcGVjdHJ1bS5wcm9jZXNzTmF0aXZlQ29sb3JJbnB1dHMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KSh3aW5kb3csIGpRdWVyeSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvc3BlY3RydW0uanMiXSwic291cmNlUm9vdCI6IiJ9');
},196:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.id, ".markup{top:10px;left:10px;width:300px;height:350px;resize:auto}.markup .container{height:calc(100% - 50px);width:calc(100% - 24px);padding-top:10px;padding-left:10px;padding-right:10px;margin:0}.markup .switch-container{float:left;margin-right:28px}.markup .dropdown-mode-container{float:left;margin-top:1px;margin-bottom:10px}.markup .input{height:14px;margin-left:2px;margin-top:0;border-radius:5px;vertical-align:top;width:calc(100% - 88px)}.markup .styles{width:calc(100% - 84px);margin-left:6px;height:20px}.markup .btn{height:6px;line-height:0;vertical-align:top}.markup .btn-dropdown{width:170px;height:10px}.markup .btn-span{margin-right:0;line-height:.3;top:1px}.markup .btn-row{width:63px}.markup .btn-span-list{margin-right:0;line-height:.3;top:1px}.markup .btn-list{margin-top:-8px;float:right}.minimized{height:34px;min-height:34px}.markup .v-spacer{border-width:0;margin:2px}.markup .v-spacer-large{border-width:0;margin:10px}.markup .list-group-item{width:calc(100% - 20px);height:4px;line-height:.3;border-radius:4px;margin-top:0;margin-bottom:2px;padding-right:2px;background-color:#f0f0f0}.markup .view-mode .list-group-item{cursor:pointer}.markup .view-mode .list-group-item.enabled{border:1px solid #42c542;background-color:#42c542}.markup .view-mode .list-group-item.enabled:hover{border:1px solid #42c542;background-color:#41e641}.markup .view-mode .list-group-item:hover{border:1px solid #34afd4;background-color:#34afd4}", ""]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuY3NzP2RmOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSxrQ0FBa0MsU0FBUyxVQUFVLFlBQVksYUFBYSxZQUFZLG1CQUFtQix5QkFBeUIsd0JBQXdCLGlCQUFpQixrQkFBa0IsbUJBQW1CLFNBQVMsMEJBQTBCLFdBQVcsa0JBQWtCLGlDQUFpQyxXQUFXLGVBQWUsbUJBQW1CLGVBQWUsWUFBWSxnQkFBZ0IsYUFBYSxrQkFBa0IsbUJBQW1CLHdCQUF3QixnQkFBZ0Isd0JBQXdCLGdCQUFnQixZQUFZLGFBQWEsV0FBVyxjQUFjLG1CQUFtQixzQkFBc0IsWUFBWSxZQUFZLGtCQUFrQixlQUFlLGVBQWUsUUFBUSxpQkFBaUIsV0FBVyx1QkFBdUIsZUFBZSxlQUFlLFFBQVEsa0JBQWtCLGdCQUFnQixZQUFZLFdBQVcsWUFBWSxnQkFBZ0Isa0JBQWtCLGVBQWUsV0FBVyx3QkFBd0IsZUFBZSxZQUFZLHlCQUF5Qix3QkFBd0IsV0FBVyxlQUFlLGtCQUFrQixhQUFhLGtCQUFrQixrQkFBa0IseUJBQXlCLG9DQUFvQyxlQUFlLDRDQUE0Qyx5QkFBeUIseUJBQXlCLGtEQUFrRCx5QkFBeUIseUJBQXlCLDBDQUEwQyx5QkFBeUIseUJBQXlCOztBQUUvN0MiLCJmaWxlIjoiMTk2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLm1hcmt1cHt0b3A6MTBweDtsZWZ0OjEwcHg7d2lkdGg6MzAwcHg7aGVpZ2h0OjM1MHB4O3Jlc2l6ZTphdXRvfS5tYXJrdXAgLmNvbnRhaW5lcntoZWlnaHQ6Y2FsYygxMDAlIC0gNTBweCk7d2lkdGg6Y2FsYygxMDAlIC0gMjRweCk7cGFkZGluZy10b3A6MTBweDtwYWRkaW5nLWxlZnQ6MTBweDtwYWRkaW5nLXJpZ2h0OjEwcHg7bWFyZ2luOjB9Lm1hcmt1cCAuc3dpdGNoLWNvbnRhaW5lcntmbG9hdDpsZWZ0O21hcmdpbi1yaWdodDoyOHB4fS5tYXJrdXAgLmRyb3Bkb3duLW1vZGUtY29udGFpbmVye2Zsb2F0OmxlZnQ7bWFyZ2luLXRvcDoxcHg7bWFyZ2luLWJvdHRvbToxMHB4fS5tYXJrdXAgLmlucHV0e2hlaWdodDoxNHB4O21hcmdpbi1sZWZ0OjJweDttYXJnaW4tdG9wOjA7Ym9yZGVyLXJhZGl1czo1cHg7dmVydGljYWwtYWxpZ246dG9wO3dpZHRoOmNhbGMoMTAwJSAtIDg4cHgpfS5tYXJrdXAgLnN0eWxlc3t3aWR0aDpjYWxjKDEwMCUgLSA4NHB4KTttYXJnaW4tbGVmdDo2cHg7aGVpZ2h0OjIwcHh9Lm1hcmt1cCAuYnRue2hlaWdodDo2cHg7bGluZS1oZWlnaHQ6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9Lm1hcmt1cCAuYnRuLWRyb3Bkb3due3dpZHRoOjE3MHB4O2hlaWdodDoxMHB4fS5tYXJrdXAgLmJ0bi1zcGFue21hcmdpbi1yaWdodDowO2xpbmUtaGVpZ2h0Oi4zO3RvcDoxcHh9Lm1hcmt1cCAuYnRuLXJvd3t3aWR0aDo2M3B4fS5tYXJrdXAgLmJ0bi1zcGFuLWxpc3R7bWFyZ2luLXJpZ2h0OjA7bGluZS1oZWlnaHQ6LjM7dG9wOjFweH0ubWFya3VwIC5idG4tbGlzdHttYXJnaW4tdG9wOi04cHg7ZmxvYXQ6cmlnaHR9Lm1pbmltaXplZHtoZWlnaHQ6MzRweDttaW4taGVpZ2h0OjM0cHh9Lm1hcmt1cCAudi1zcGFjZXJ7Ym9yZGVyLXdpZHRoOjA7bWFyZ2luOjJweH0ubWFya3VwIC52LXNwYWNlci1sYXJnZXtib3JkZXItd2lkdGg6MDttYXJnaW46MTBweH0ubWFya3VwIC5saXN0LWdyb3VwLWl0ZW17d2lkdGg6Y2FsYygxMDAlIC0gMjBweCk7aGVpZ2h0OjRweDtsaW5lLWhlaWdodDouMztib3JkZXItcmFkaXVzOjRweDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbToycHg7cGFkZGluZy1yaWdodDoycHg7YmFja2dyb3VuZC1jb2xvcjojZjBmMGYwfS5tYXJrdXAgLnZpZXctbW9kZSAubGlzdC1ncm91cC1pdGVte2N1cnNvcjpwb2ludGVyfS5tYXJrdXAgLnZpZXctbW9kZSAubGlzdC1ncm91cC1pdGVtLmVuYWJsZWR7Ym9yZGVyOjFweCBzb2xpZCAjNDJjNTQyO2JhY2tncm91bmQtY29sb3I6IzQyYzU0Mn0ubWFya3VwIC52aWV3LW1vZGUgLmxpc3QtZ3JvdXAtaXRlbS5lbmFibGVkOmhvdmVye2JvcmRlcjoxcHggc29saWQgIzQyYzU0MjtiYWNrZ3JvdW5kLWNvbG9yOiM0MWU2NDF9Lm1hcmt1cCAudmlldy1tb2RlIC5saXN0LWdyb3VwLWl0ZW06aG92ZXJ7Ym9yZGVyOjFweCBzb2xpZCAjMzRhZmQ0O2JhY2tncm91bmQtY29sb3I6IzM0YWZkNH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL3NyYy9WaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRC9WaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRC5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDYiXSwic291cmNlUm9vdCI6IiJ9')},197:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.id, ".sp-container{position:absolute;top:0;left:0;display:inline-block;*display:inline;*zoom:1;z-index:9999994;overflow:hidden}.sp-container.sp-flat{position:relative}.sp-container,.sp-container *{box-sizing:content-box}.sp-top{position:relative;width:100%;display:inline-block}.sp-top-inner{right:0}.sp-color,.sp-top-inner{position:absolute;top:0;left:0;bottom:0}.sp-color{right:20%}.sp-hue{position:absolute;top:0;right:0;bottom:0;left:84%;height:100%}.sp-clear-enabled .sp-hue{top:33px;height:77.5%}.sp-fill{padding-top:80%}.sp-sat,.sp-val{position:absolute;top:0;left:0;right:0;bottom:0}.sp-alpha-enabled .sp-top{margin-bottom:18px}.sp-alpha-enabled .sp-alpha{display:block}.sp-alpha-handle{position:absolute;top:-4px;bottom:-4px;width:6px;left:50%;cursor:pointer;border:1px solid #000;background:#fff;opacity:.8}.sp-alpha{display:none;position:absolute;bottom:-14px;right:0;left:0;height:8px}.sp-alpha-inner{border:1px solid #333}.sp-clear{display:none}.sp-clear.sp-clear-display{background-position:50%}.sp-clear-enabled .sp-clear{display:block;position:absolute;top:0;right:0;bottom:0;left:84%;height:28px}.sp-alpha,.sp-alpha-handle,.sp-clear,.sp-container,.sp-container.sp-dragging .sp-input,.sp-container button,.sp-dragger,.sp-preview,.sp-replacer,.sp-slider{-webkit-user-select:none;-moz-user-select:-moz-none;-o-user-select:none;user-select:none}.sp-container.sp-buttons-disabled .sp-button-container,.sp-container.sp-input-disabled .sp-input-container,.sp-container.sp-palette-buttons-disabled .sp-palette-button-container,.sp-initial-disabled .sp-initial,.sp-palette-disabled .sp-palette-container,.sp-palette-only .sp-picker-container{display:none}.sp-sat{background-image:-webkit-gradient(linear,0 0,100% 0,from(#fff),to(hsla(20,42%,65%,0)));background-image:-webkit-linear-gradient(left,#fff,hsla(20,42%,65%,0));background-image:linear-gradient(90deg,#fff,hsla(20,42%,65%,0));-ms-filter:\\"progid:DXImageTransform.Microsoft.gradient(GradientType = 1, startColorstr=#FFFFFFFF, endColorstr=#00CC9A81)\\";filter:progid:DXImageTransform.Microsoft.gradient(GradientType = 1,startColorstr=\\"#FFFFFFFF\\",endColorstr=\\"#00CC9A81\\")}.sp-val{background-image:-webkit-gradient(linear,0 100%,0 0,from(#000),to(hsla(20,42%,65%,0)));background-image:-webkit-linear-gradient(bottom,#000,hsla(20,42%,65%,0));background-image:linear-gradient(0deg,#000,hsla(20,42%,65%,0));-ms-filter:\\"progid:DXImageTransform.Microsoft.gradient(startColorstr=#00CC9A81, endColorstr=#FF000000)\\";filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#00CC9A81\\",endColorstr=\\"#FF000000\\")}.sp-hue{background:-webkit-gradient(linear,left top,left bottom,from(red),color-stop(.17,#ff0),color-stop(.33,#0f0),color-stop(.5,#0ff),color-stop(.67,#00f),color-stop(.83,#f0f),to(red));background:-webkit-linear-gradient(top,red,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red);background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.sp-1{height:17%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#ff0000\\",endColorstr=\\"#ffff00\\")}.sp-2{height:16%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#ffff00\\",endColorstr=\\"#00ff00\\")}.sp-3{height:17%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#00ff00\\",endColorstr=\\"#00ffff\\")}.sp-4{height:17%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#00ffff\\",endColorstr=\\"#0000ff\\")}.sp-5{height:16%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#0000ff\\",endColorstr=\\"#ff00ff\\")}.sp-6{height:17%;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\\"#ff00ff\\",endColorstr=\\"#ff0000\\")}.sp-hidden{display:none!important}.sp-cf:after,.sp-cf:before{content:\\"\\";display:table}.sp-cf:after{clear:both}.sp-cf{*zoom:1}@media (max-device-width:480px){.sp-color{right:40%}.sp-hue{left:63%}.sp-fill{padding-top:60%}}.sp-dragger{border-radius:5px;height:5px;width:5px;border:1px solid #fff;background:#000;left:0}.sp-dragger,.sp-slider{cursor:pointer;position:absolute;top:0}.sp-slider{height:3px;left:-1px;right:-1px;border:1px solid #000;background:#fff;opacity:.8}.sp-container{border-radius:0;background-color:#ececec;border:1px solid #f0c49b;padding:0}.sp-clear,.sp-color,.sp-container,.sp-container button,.sp-container input,.sp-hue{font:normal 12px Lucida Grande,Lucida Sans Unicode,Lucida Sans,Geneva,Verdana,sans-serif;-ms-box-sizing:border-box;box-sizing:border-box}.sp-top{margin-bottom:3px}.sp-clear,.sp-color,.sp-hue{border:1px solid #666}.sp-input-container{float:right;width:100px;margin-bottom:4px}.sp-initial-disabled .sp-input-container,.sp-input{width:100%}.sp-input{font-size:12px!important;border:1px inset;padding:4px 5px;margin:0;background:transparent;border-radius:3px;color:#222}.sp-input:focus{border:1px solid orange}.sp-input.sp-validation-error{border:1px solid red;background:#fdd}.sp-palette-container,.sp-picker-container{float:left;position:relative;padding:10px;padding-bottom:300px;margin-bottom:-290px}.sp-picker-container{width:172px;border-left:1px solid #fff}.sp-palette-container{border-right:1px solid #ccc}.sp-palette-only .sp-palette-container{border:0}.sp-palette .sp-thumb-el{display:block;position:relative;float:left;width:24px;height:15px;margin:3px;cursor:pointer;border:2px solid transparent}.sp-palette .sp-thumb-el.sp-thumb-active,.sp-palette .sp-thumb-el:hover{border-color:orange}.sp-thumb-el{position:relative}.sp-initial{float:left;border:1px solid #333}.sp-initial span{width:30px;height:25px;border:none;display:block;float:left;margin:0}.sp-initial .sp-clear-display{background-position:50%}.sp-button-container,.sp-palette-button-container{float:right}.sp-replacer{margin:0;overflow:hidden;cursor:pointer;padding:4px;display:inline-block;*zoom:1;*display:inline;border:1px solid #91765d;background:#eee;color:#333;vertical-align:middle;height:17px;width:56px;border-radius:10px}.sp-replacer.sp-active,.sp-replacer:hover{border-color:#f0c49b;color:#111}.sp-replacer.sp-disabled{cursor:default;border-color:silver;color:silver}.sp-dd{padding:2px 0;height:16px;line-height:16px;float:left;font-size:10px}.sp-preview{position:relative;width:25px;height:15px;border:1px solid #222;margin-right:5px;float:left;z-index:0;border-radius:8px;width:36px}.sp-palette{*width:220px;max-width:220px}.sp-palette .sp-thumb-el{width:16px;height:16px;margin:2px 1px;border:1px solid #d0d0d0}.sp-container{padding-bottom:0}.sp-container button{background-color:#eee;background-image:-webkit-linear-gradient(top,#eee,#ccc);background-image:linear-gradient(180deg,#eee,#ccc);border:1px solid #ccc;border-bottom:1px solid #bbb;border-radius:3px;color:#333;font-size:14px;line-height:1;padding:5px 4px;text-align:center;text-shadow:0 1px 0 #eee;vertical-align:middle}.sp-container button:hover{background-color:#ddd;background-image:-webkit-linear-gradient(top,#ddd,#bbb);background-image:linear-gradient(180deg,#ddd,#bbb);border:1px solid #bbb;border-bottom:1px solid #999;cursor:pointer;text-shadow:0 1px 0 #ddd}.sp-container button:active{border:1px solid #aaa;border-bottom:1px solid #888;-ms-box-shadow:inset 0 0 5px 2px #aaa,0 1px 0 0 #eee;-o-box-shadow:inset 0 0 5px 2px #aaa,0 1px 0 0 #eee;box-shadow:inset 0 0 5px 2px #aaa,0 1px 0 0 #eee}.sp-cancel{font-size:11px;color:#d93f3f!important;margin:0;padding:2px;margin-right:5px;vertical-align:middle;text-decoration:none}.sp-cancel:hover{color:#d93f3f!important;text-decoration:underline}.sp-palette span.sp-thumb-active,.sp-palette span:hover{border-color:#000}.sp-alpha,.sp-preview,.sp-thumb-el{position:relative;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.sp-alpha-inner,.sp-preview-inner,.sp-thumb-inner{display:block;position:absolute;top:0;left:0;bottom:0;right:0;border-radius:8px}.sp-palette .sp-thumb-inner{background-position:50% 50%;background-repeat:no-repeat}.sp-palette .sp-thumb-light.sp-thumb-active .sp-thumb-inner{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIVJREFUeNpiYBhsgJFMffxAXABlN5JruT4Q3wfi/0DsT64h8UD8HmpIPCWG/KemIfOJCUB+Aoacx6EGBZyHBqI+WsDCwuQ9mhxeg2A210Ntfo8klk9sOMijaURm7yc1UP2RNCMbKE9ODK1HM6iegYLkfx8pligC9lCD7KmRof0ZhjQACDAAceovrtpVBRkAAAAASUVORK5CYII=)}.sp-palette .sp-thumb-dark.sp-thumb-active .sp-thumb-inner{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjEwMPRyoQAAAMdJREFUOE+tkgsNwzAMRMugEAahEAahEAZhEAqlEAZhEAohEAYh81X2dIm8fKpEspLGvudPOsUYpxE2BIJCroJmEW9qJ+MKaBFhEMNabSy9oIcIPwrB+afvAUFoK4H0tMaQ3XtlrggDhOVVMuT4E5MMG0FBbCEYzjYT7OxLEvIHQLY2zWwQ3D+9luyOQTfKDiFD3iUIfPk8VqrKjgAiSfGFPecrg6HN6m/iBcwiDAo7WiBeawa+Kwh7tZoSCGLMqwlSAzVDhoK+6vH4G0P5wdkAAAAASUVORK5CYII=)}.sp-clear-display{background-repeat:no-repeat;background-position:50%;background-image:url(data:image/gif;base64,R0lGODlhFAAUAPcAAAAAAJmZmZ2dnZ6enqKioqOjo6SkpKWlpaampqenp6ioqKmpqaqqqqurq/Hx8fLy8vT09PX19ff39/j4+Pn5+fr6+vv7+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAP8ALAAAAAAUABQAAAihAP9FoPCvoMGDBy08+EdhQAIJCCMybCDAAYUEARBAlFiQQoMABQhKUJBxY0SPICEYHBnggEmDKAuoPMjS5cGYMxHW3IiT478JJA8M/CjTZ0GgLRekNGpwAsYABHIypcAgQMsITDtWJYBR6NSqMico9cqR6tKfY7GeBCuVwlipDNmefAtTrkSzB1RaIAoXodsABiZAEFB06gIBWC1mLVgBa0AAOw==)}", ""]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvc3BlY3RydW0uY3NzPzg4NTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSx3Q0FBd0Msa0JBQWtCLE1BQU0sT0FBTyxxQkFBcUIsZ0JBQWdCLFFBQVEsZ0JBQWdCLGdCQUFnQixzQkFBc0Isa0JBQWtCLDhCQUE4Qix1QkFBdUIsUUFBUSxrQkFBa0IsV0FBVyxxQkFBcUIsY0FBYyxRQUFRLHdCQUF3QixrQkFBa0IsTUFBTSxPQUFPLFNBQVMsVUFBVSxVQUFVLFFBQVEsa0JBQWtCLE1BQU0sUUFBUSxTQUFTLFNBQVMsWUFBWSwwQkFBMEIsU0FBUyxhQUFhLFNBQVMsZ0JBQWdCLGdCQUFnQixrQkFBa0IsTUFBTSxPQUFPLFFBQVEsU0FBUywwQkFBMEIsbUJBQW1CLDRCQUE0QixjQUFjLGlCQUFpQixrQkFBa0IsU0FBUyxZQUFZLFVBQVUsU0FBUyxlQUFlLHNCQUFzQixnQkFBZ0IsV0FBVyxVQUFVLGFBQWEsa0JBQWtCLGFBQWEsUUFBUSxPQUFPLFdBQVcsZ0JBQWdCLHNCQUFzQixVQUFVLGFBQWEsMkJBQTJCLHdCQUF3Qiw0QkFBNEIsY0FBYyxrQkFBa0IsTUFBTSxRQUFRLFNBQVMsU0FBUyxZQUFZLDRKQUE0Six5QkFBeUIsMkJBQTJCLG9CQUFvQixpQkFBaUIsb1NBQW9TLGFBQWEsUUFBUSx1RkFBdUYsdUVBQXVFLGdFQUFnRSw0SEFBNEgsMEhBQTBILFFBQVEsdUZBQXVGLHlFQUF5RSwrREFBK0QsMEdBQTBHLHlHQUF5RyxRQUFRLG1MQUFtTCw2RkFBNkYsMEZBQTBGLE1BQU0sV0FBVyxxR0FBcUcsTUFBTSxXQUFXLHFHQUFxRyxNQUFNLFdBQVcscUdBQXFHLE1BQU0sV0FBVyxxR0FBcUcsTUFBTSxXQUFXLHFHQUFxRyxNQUFNLFdBQVcscUdBQXFHLFdBQVcsdUJBQXVCLDJCQUEyQixhQUFhLGNBQWMsYUFBYSxXQUFXLE9BQU8sUUFBUSxnQ0FBZ0MsVUFBVSxVQUFVLFFBQVEsU0FBUyxTQUFTLGlCQUFpQixZQUFZLGtCQUFrQixXQUFXLFVBQVUsc0JBQXNCLGdCQUFnQixPQUFPLHVCQUF1QixlQUFlLGtCQUFrQixNQUFNLFdBQVcsV0FBVyxVQUFVLFdBQVcsc0JBQXNCLGdCQUFnQixXQUFXLGNBQWMsZ0JBQWdCLHlCQUF5Qix5QkFBeUIsVUFBVSxtRkFBbUYseUZBQXlGLDBCQUEwQixzQkFBc0IsUUFBUSxrQkFBa0IsNEJBQTRCLHNCQUFzQixvQkFBb0IsWUFBWSxZQUFZLGtCQUFrQixtREFBbUQsV0FBVyxVQUFVLHlCQUF5QixpQkFBaUIsZ0JBQWdCLFNBQVMsdUJBQXVCLGtCQUFrQixXQUFXLGdCQUFnQix3QkFBd0IsOEJBQThCLHFCQUFxQixnQkFBZ0IsMkNBQTJDLFdBQVcsa0JBQWtCLGFBQWEscUJBQXFCLHFCQUFxQixxQkFBcUIsWUFBWSwyQkFBMkIsc0JBQXNCLDRCQUE0Qix1Q0FBdUMsU0FBUyx5QkFBeUIsY0FBYyxrQkFBa0IsV0FBVyxXQUFXLFlBQVksV0FBVyxlQUFlLDZCQUE2Qix3RUFBd0Usb0JBQW9CLGFBQWEsa0JBQWtCLFlBQVksV0FBVyxzQkFBc0IsaUJBQWlCLFdBQVcsWUFBWSxZQUFZLGNBQWMsV0FBVyxTQUFTLDhCQUE4Qix3QkFBd0Isa0RBQWtELFlBQVksYUFBYSxTQUFTLGdCQUFnQixlQUFlLFlBQVkscUJBQXFCLFFBQVEsZ0JBQWdCLHlCQUF5QixnQkFBZ0IsV0FBVyxzQkFBc0IsWUFBWSxXQUFXLG1CQUFtQiwwQ0FBMEMscUJBQXFCLFdBQVcseUJBQXlCLGVBQWUsb0JBQW9CLGFBQWEsT0FBTyxjQUFjLFlBQVksaUJBQWlCLFdBQVcsZUFBZSxZQUFZLGtCQUFrQixXQUFXLFlBQVksc0JBQXNCLGlCQUFpQixXQUFXLFVBQVUsa0JBQWtCLFdBQVcsWUFBWSxhQUFhLGdCQUFnQix5QkFBeUIsV0FBVyxZQUFZLGVBQWUseUJBQXlCLGNBQWMsaUJBQWlCLHFCQUFxQixzQkFBc0Isd0RBQXdELG1EQUFtRCxzQkFBc0IsNkJBQTZCLGtCQUFrQixXQUFXLGVBQWUsY0FBYyxnQkFBZ0Isa0JBQWtCLHlCQUF5QixzQkFBc0IsMkJBQTJCLHNCQUFzQix3REFBd0QsbURBQW1ELHNCQUFzQiw2QkFBNkIsZUFBZSx5QkFBeUIsNEJBQTRCLHNCQUFzQiw2QkFBNkIscURBQXFELG9EQUFvRCxpREFBaUQsV0FBVyxlQUFlLHdCQUF3QixTQUFTLFlBQVksaUJBQWlCLHNCQUFzQixxQkFBcUIsaUJBQWlCLHdCQUF3QiwwQkFBMEIsd0RBQXdELGtCQUFrQixtQ0FBbUMsa0JBQWtCLG9DQUFvQyx5SEFBeUgsa0RBQWtELGNBQWMsa0JBQWtCLE1BQU0sT0FBTyxTQUFTLFFBQVEsa0JBQWtCLDRCQUE0Qiw0QkFBNEIsNEJBQTRCLDREQUE0RCxvQ0FBb0MseVRBQXlULDJEQUEyRCxvQ0FBb0MscWRBQXFkLGtCQUFrQiw0QkFBNEIsd0JBQXdCLG9DQUFvQyxpeENBQWl4Qzs7QUFFdG1VIiwiZmlsZSI6IjE5Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5zcC1jb250YWluZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2Rpc3BsYXk6aW5saW5lLWJsb2NrOypkaXNwbGF5OmlubGluZTsqem9vbToxO3otaW5kZXg6OTk5OTk5NDtvdmVyZmxvdzpoaWRkZW59LnNwLWNvbnRhaW5lci5zcC1mbGF0e3Bvc2l0aW9uOnJlbGF0aXZlfS5zcC1jb250YWluZXIsLnNwLWNvbnRhaW5lciAqe2JveC1zaXppbmc6Y29udGVudC1ib3h9LnNwLXRvcHtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDoxMDAlO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5zcC10b3AtaW5uZXJ7cmlnaHQ6MH0uc3AtY29sb3IsLnNwLXRvcC1pbm5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7Ym90dG9tOjB9LnNwLWNvbG9ye3JpZ2h0OjIwJX0uc3AtaHVle3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDo4NCU7aGVpZ2h0OjEwMCV9LnNwLWNsZWFyLWVuYWJsZWQgLnNwLWh1ZXt0b3A6MzNweDtoZWlnaHQ6NzcuNSV9LnNwLWZpbGx7cGFkZGluZy10b3A6ODAlfS5zcC1zYXQsLnNwLXZhbHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MH0uc3AtYWxwaGEtZW5hYmxlZCAuc3AtdG9we21hcmdpbi1ib3R0b206MThweH0uc3AtYWxwaGEtZW5hYmxlZCAuc3AtYWxwaGF7ZGlzcGxheTpibG9ja30uc3AtYWxwaGEtaGFuZGxle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNHB4O2JvdHRvbTotNHB4O3dpZHRoOjZweDtsZWZ0OjUwJTtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MXB4IHNvbGlkICMwMDA7YmFja2dyb3VuZDojZmZmO29wYWNpdHk6Ljh9LnNwLWFscGhhe2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTtib3R0b206LTE0cHg7cmlnaHQ6MDtsZWZ0OjA7aGVpZ2h0OjhweH0uc3AtYWxwaGEtaW5uZXJ7Ym9yZGVyOjFweCBzb2xpZCAjMzMzfS5zcC1jbGVhcntkaXNwbGF5Om5vbmV9LnNwLWNsZWFyLnNwLWNsZWFyLWRpc3BsYXl7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCV9LnNwLWNsZWFyLWVuYWJsZWQgLnNwLWNsZWFye2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0Ojg0JTtoZWlnaHQ6MjhweH0uc3AtYWxwaGEsLnNwLWFscGhhLWhhbmRsZSwuc3AtY2xlYXIsLnNwLWNvbnRhaW5lciwuc3AtY29udGFpbmVyLnNwLWRyYWdnaW5nIC5zcC1pbnB1dCwuc3AtY29udGFpbmVyIGJ1dHRvbiwuc3AtZHJhZ2dlciwuc3AtcHJldmlldywuc3AtcmVwbGFjZXIsLnNwLXNsaWRlcnstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDotbW96LW5vbmU7LW8tdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5zcC1jb250YWluZXIuc3AtYnV0dG9ucy1kaXNhYmxlZCAuc3AtYnV0dG9uLWNvbnRhaW5lciwuc3AtY29udGFpbmVyLnNwLWlucHV0LWRpc2FibGVkIC5zcC1pbnB1dC1jb250YWluZXIsLnNwLWNvbnRhaW5lci5zcC1wYWxldHRlLWJ1dHRvbnMtZGlzYWJsZWQgLnNwLXBhbGV0dGUtYnV0dG9uLWNvbnRhaW5lciwuc3AtaW5pdGlhbC1kaXNhYmxlZCAuc3AtaW5pdGlhbCwuc3AtcGFsZXR0ZS1kaXNhYmxlZCAuc3AtcGFsZXR0ZS1jb250YWluZXIsLnNwLXBhbGV0dGUtb25seSAuc3AtcGlja2VyLWNvbnRhaW5lcntkaXNwbGF5Om5vbmV9LnNwLXNhdHtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLDAgMCwxMDAlIDAsZnJvbSgjZmZmKSx0byhoc2xhKDIwLDQyJSw2NSUsMCkpKTtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQsI2ZmZixoc2xhKDIwLDQyJSw2NSUsMCkpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KDkwZGVnLCNmZmYsaHNsYSgyMCw0MiUsNjUlLDApKTstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoR3JhZGllbnRUeXBlID0gMSwgc3RhcnRDb2xvcnN0cj0jRkZGRkZGRkYsIGVuZENvbG9yc3RyPSMwMENDOUE4MSlcXFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoR3JhZGllbnRUeXBlID0gMSxzdGFydENvbG9yc3RyPVxcXCIjRkZGRkZGRkZcXFwiLGVuZENvbG9yc3RyPVxcXCIjMDBDQzlBODFcXFwiKX0uc3AtdmFse2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1ncmFkaWVudChsaW5lYXIsMCAxMDAlLDAgMCxmcm9tKCMwMDApLHRvKGhzbGEoMjAsNDIlLDY1JSwwKSkpO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQoYm90dG9tLCMwMDAsaHNsYSgyMCw0MiUsNjUlLDApKTtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCgwZGVnLCMwMDAsaHNsYSgyMCw0MiUsNjUlLDApKTstbXMtZmlsdGVyOlxcXCJwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0jMDBDQzlBODEsIGVuZENvbG9yc3RyPSNGRjAwMDAwMClcXFwiO2ZpbHRlcjpwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj1cXFwiIzAwQ0M5QTgxXFxcIixlbmRDb2xvcnN0cj1cXFwiI0ZGMDAwMDAwXFxcIil9LnNwLWh1ZXtiYWNrZ3JvdW5kOi13ZWJraXQtZ3JhZGllbnQobGluZWFyLGxlZnQgdG9wLGxlZnQgYm90dG9tLGZyb20ocmVkKSxjb2xvci1zdG9wKC4xNywjZmYwKSxjb2xvci1zdG9wKC4zMywjMGYwKSxjb2xvci1zdG9wKC41LCMwZmYpLGNvbG9yLXN0b3AoLjY3LCMwMGYpLGNvbG9yLXN0b3AoLjgzLCNmMGYpLHRvKHJlZCkpO2JhY2tncm91bmQ6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLHJlZCwjZmYwIDE3JSwjMGYwIDMzJSwjMGZmIDUwJSwjMDBmIDY3JSwjZjBmIDgzJSxyZWQpO2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDE4MGRlZyxyZWQgMCwjZmYwIDE3JSwjMGYwIDMzJSwjMGZmIDUwJSwjMDBmIDY3JSwjZjBmIDgzJSxyZWQpfS5zcC0xe2hlaWdodDoxNyU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjZmYwMDAwXFxcIixlbmRDb2xvcnN0cj1cXFwiI2ZmZmYwMFxcXCIpfS5zcC0ye2hlaWdodDoxNiU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjZmZmZjAwXFxcIixlbmRDb2xvcnN0cj1cXFwiIzAwZmYwMFxcXCIpfS5zcC0ze2hlaWdodDoxNyU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjMDBmZjAwXFxcIixlbmRDb2xvcnN0cj1cXFwiIzAwZmZmZlxcXCIpfS5zcC00e2hlaWdodDoxNyU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjMDBmZmZmXFxcIixlbmRDb2xvcnN0cj1cXFwiIzAwMDBmZlxcXCIpfS5zcC01e2hlaWdodDoxNiU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjMDAwMGZmXFxcIixlbmRDb2xvcnN0cj1cXFwiI2ZmMDBmZlxcXCIpfS5zcC02e2hlaWdodDoxNyU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPVxcXCIjZmYwMGZmXFxcIixlbmRDb2xvcnN0cj1cXFwiI2ZmMDAwMFxcXCIpfS5zcC1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0uc3AtY2Y6YWZ0ZXIsLnNwLWNmOmJlZm9yZXtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LnNwLWNmOmFmdGVye2NsZWFyOmJvdGh9LnNwLWNmeyp6b29tOjF9QG1lZGlhIChtYXgtZGV2aWNlLXdpZHRoOjQ4MHB4KXsuc3AtY29sb3J7cmlnaHQ6NDAlfS5zcC1odWV7bGVmdDo2MyV9LnNwLWZpbGx7cGFkZGluZy10b3A6NjAlfX0uc3AtZHJhZ2dlcntib3JkZXItcmFkaXVzOjVweDtoZWlnaHQ6NXB4O3dpZHRoOjVweDtib3JkZXI6MXB4IHNvbGlkICNmZmY7YmFja2dyb3VuZDojMDAwO2xlZnQ6MH0uc3AtZHJhZ2dlciwuc3Atc2xpZGVye2N1cnNvcjpwb2ludGVyO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowfS5zcC1zbGlkZXJ7aGVpZ2h0OjNweDtsZWZ0Oi0xcHg7cmlnaHQ6LTFweDtib3JkZXI6MXB4IHNvbGlkICMwMDA7YmFja2dyb3VuZDojZmZmO29wYWNpdHk6Ljh9LnNwLWNvbnRhaW5lcntib3JkZXItcmFkaXVzOjA7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjO2JvcmRlcjoxcHggc29saWQgI2YwYzQ5YjtwYWRkaW5nOjB9LnNwLWNsZWFyLC5zcC1jb2xvciwuc3AtY29udGFpbmVyLC5zcC1jb250YWluZXIgYnV0dG9uLC5zcC1jb250YWluZXIgaW5wdXQsLnNwLWh1ZXtmb250Om5vcm1hbCAxMnB4IEx1Y2lkYSBHcmFuZGUsTHVjaWRhIFNhbnMgVW5pY29kZSxMdWNpZGEgU2FucyxHZW5ldmEsVmVyZGFuYSxzYW5zLXNlcmlmOy1tcy1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5zcC10b3B7bWFyZ2luLWJvdHRvbTozcHh9LnNwLWNsZWFyLC5zcC1jb2xvciwuc3AtaHVle2JvcmRlcjoxcHggc29saWQgIzY2Nn0uc3AtaW5wdXQtY29udGFpbmVye2Zsb2F0OnJpZ2h0O3dpZHRoOjEwMHB4O21hcmdpbi1ib3R0b206NHB4fS5zcC1pbml0aWFsLWRpc2FibGVkIC5zcC1pbnB1dC1jb250YWluZXIsLnNwLWlucHV0e3dpZHRoOjEwMCV9LnNwLWlucHV0e2ZvbnQtc2l6ZToxMnB4IWltcG9ydGFudDtib3JkZXI6MXB4IGluc2V0O3BhZGRpbmc6NHB4IDVweDttYXJnaW46MDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6M3B4O2NvbG9yOiMyMjJ9LnNwLWlucHV0OmZvY3Vze2JvcmRlcjoxcHggc29saWQgb3JhbmdlfS5zcC1pbnB1dC5zcC12YWxpZGF0aW9uLWVycm9ye2JvcmRlcjoxcHggc29saWQgcmVkO2JhY2tncm91bmQ6I2ZkZH0uc3AtcGFsZXR0ZS1jb250YWluZXIsLnNwLXBpY2tlci1jb250YWluZXJ7ZmxvYXQ6bGVmdDtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjEwcHg7cGFkZGluZy1ib3R0b206MzAwcHg7bWFyZ2luLWJvdHRvbTotMjkwcHh9LnNwLXBpY2tlci1jb250YWluZXJ7d2lkdGg6MTcycHg7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNmZmZ9LnNwLXBhbGV0dGUtY29udGFpbmVye2JvcmRlci1yaWdodDoxcHggc29saWQgI2NjY30uc3AtcGFsZXR0ZS1vbmx5IC5zcC1wYWxldHRlLWNvbnRhaW5lcntib3JkZXI6MH0uc3AtcGFsZXR0ZSAuc3AtdGh1bWItZWx7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtmbG9hdDpsZWZ0O3dpZHRoOjI0cHg7aGVpZ2h0OjE1cHg7bWFyZ2luOjNweDtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MnB4IHNvbGlkIHRyYW5zcGFyZW50fS5zcC1wYWxldHRlIC5zcC10aHVtYi1lbC5zcC10aHVtYi1hY3RpdmUsLnNwLXBhbGV0dGUgLnNwLXRodW1iLWVsOmhvdmVye2JvcmRlci1jb2xvcjpvcmFuZ2V9LnNwLXRodW1iLWVse3Bvc2l0aW9uOnJlbGF0aXZlfS5zcC1pbml0aWFse2Zsb2F0OmxlZnQ7Ym9yZGVyOjFweCBzb2xpZCAjMzMzfS5zcC1pbml0aWFsIHNwYW57d2lkdGg6MzBweDtoZWlnaHQ6MjVweDtib3JkZXI6bm9uZTtkaXNwbGF5OmJsb2NrO2Zsb2F0OmxlZnQ7bWFyZ2luOjB9LnNwLWluaXRpYWwgLnNwLWNsZWFyLWRpc3BsYXl7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCV9LnNwLWJ1dHRvbi1jb250YWluZXIsLnNwLXBhbGV0dGUtYnV0dG9uLWNvbnRhaW5lcntmbG9hdDpyaWdodH0uc3AtcmVwbGFjZXJ7bWFyZ2luOjA7b3ZlcmZsb3c6aGlkZGVuO2N1cnNvcjpwb2ludGVyO3BhZGRpbmc6NHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrOyp6b29tOjE7KmRpc3BsYXk6aW5saW5lO2JvcmRlcjoxcHggc29saWQgIzkxNzY1ZDtiYWNrZ3JvdW5kOiNlZWU7Y29sb3I6IzMzMzt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7aGVpZ2h0OjE3cHg7d2lkdGg6NTZweDtib3JkZXItcmFkaXVzOjEwcHh9LnNwLXJlcGxhY2VyLnNwLWFjdGl2ZSwuc3AtcmVwbGFjZXI6aG92ZXJ7Ym9yZGVyLWNvbG9yOiNmMGM0OWI7Y29sb3I6IzExMX0uc3AtcmVwbGFjZXIuc3AtZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHQ7Ym9yZGVyLWNvbG9yOnNpbHZlcjtjb2xvcjpzaWx2ZXJ9LnNwLWRke3BhZGRpbmc6MnB4IDA7aGVpZ2h0OjE2cHg7bGluZS1oZWlnaHQ6MTZweDtmbG9hdDpsZWZ0O2ZvbnQtc2l6ZToxMHB4fS5zcC1wcmV2aWV3e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjI1cHg7aGVpZ2h0OjE1cHg7Ym9yZGVyOjFweCBzb2xpZCAjMjIyO21hcmdpbi1yaWdodDo1cHg7ZmxvYXQ6bGVmdDt6LWluZGV4OjA7Ym9yZGVyLXJhZGl1czo4cHg7d2lkdGg6MzZweH0uc3AtcGFsZXR0ZXsqd2lkdGg6MjIwcHg7bWF4LXdpZHRoOjIyMHB4fS5zcC1wYWxldHRlIC5zcC10aHVtYi1lbHt3aWR0aDoxNnB4O2hlaWdodDoxNnB4O21hcmdpbjoycHggMXB4O2JvcmRlcjoxcHggc29saWQgI2QwZDBkMH0uc3AtY29udGFpbmVye3BhZGRpbmctYm90dG9tOjB9LnNwLWNvbnRhaW5lciBidXR0b257YmFja2dyb3VuZC1jb2xvcjojZWVlO2JhY2tncm91bmQtaW1hZ2U6LXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCNlZWUsI2NjYyk7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCNlZWUsI2NjYyk7Ym9yZGVyOjFweCBzb2xpZCAjY2NjO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNiYmI7Ym9yZGVyLXJhZGl1czozcHg7Y29sb3I6IzMzMztmb250LXNpemU6MTRweDtsaW5lLWhlaWdodDoxO3BhZGRpbmc6NXB4IDRweDt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LXNoYWRvdzowIDFweCAwICNlZWU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5zcC1jb250YWluZXIgYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2RkZDtiYWNrZ3JvdW5kLWltYWdlOi13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwjZGRkLCNiYmIpO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KDE4MGRlZywjZGRkLCNiYmIpO2JvcmRlcjoxcHggc29saWQgI2JiYjtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjOTk5O2N1cnNvcjpwb2ludGVyO3RleHQtc2hhZG93OjAgMXB4IDAgI2RkZH0uc3AtY29udGFpbmVyIGJ1dHRvbjphY3RpdmV7Ym9yZGVyOjFweCBzb2xpZCAjYWFhO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICM4ODg7LW1zLWJveC1zaGFkb3c6aW5zZXQgMCAwIDVweCAycHggI2FhYSwwIDFweCAwIDAgI2VlZTstby1ib3gtc2hhZG93Omluc2V0IDAgMCA1cHggMnB4ICNhYWEsMCAxcHggMCAwICNlZWU7Ym94LXNoYWRvdzppbnNldCAwIDAgNXB4IDJweCAjYWFhLDAgMXB4IDAgMCAjZWVlfS5zcC1jYW5jZWx7Zm9udC1zaXplOjExcHg7Y29sb3I6I2Q5M2YzZiFpbXBvcnRhbnQ7bWFyZ2luOjA7cGFkZGluZzoycHg7bWFyZ2luLXJpZ2h0OjVweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnNwLWNhbmNlbDpob3Zlcntjb2xvcjojZDkzZjNmIWltcG9ydGFudDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5zcC1wYWxldHRlIHNwYW4uc3AtdGh1bWItYWN0aXZlLC5zcC1wYWxldHRlIHNwYW46aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwMDB9LnNwLWFscGhhLC5zcC1wcmV2aWV3LC5zcC10aHVtYi1lbHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUF3QUFBQU1DQUlBQUFEWkY4dXdBQUFBR1VsRVFWUVlWMk00Z3dIK1l3Q0dJYXNJVXdoVDI1QlZCQUR0ellOWXJIdnY0Z0FBQUFCSlJVNUVya0pnZ2c9PSl9LnNwLWFscGhhLWlubmVyLC5zcC1wcmV2aWV3LWlubmVyLC5zcC10aHVtYi1pbm5lcntkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtib3R0b206MDtyaWdodDowO2JvcmRlci1yYWRpdXM6OHB4fS5zcC1wYWxldHRlIC5zcC10aHVtYi1pbm5lcntiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJSA1MCU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0fS5zcC1wYWxldHRlIC5zcC10aHVtYi1saWdodC5zcC10aHVtYi1hY3RpdmUgLnNwLXRodW1iLWlubmVye2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQklBQUFBU0NBWUFBQUJXem81WEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSVZKUkVGVWVOcGlZQmhzZ0pGTWZmeEFYQUJsTjVKcnVUNFEzd2ZpLzBEc1Q2NGg4VUQ4SG1wSVBDV0cvS2VtSWZPSkNVQitBb2FjeDZFR0JaeUhCcUkrV3NEQ3d1UTltaHhlZzJBMjEwTnRmbzhrbGs5c09NaWphVVJtN3ljMVVQMlJOQ01iS0U5T0RLMUhNNmllZ1lMa2Z4OHBsaWdDOWxDRDdLbVJvZjBaaGpRQUNEQUFjZW92cnRwVkJSa0FBQUFBU1VWT1JLNUNZSUk9KX0uc3AtcGFsZXR0ZSAuc3AtdGh1bWItZGFyay5zcC10aHVtYi1hY3RpdmUgLnNwLXRodW1iLWlubmVye2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQklBQUFBU0NBWUFBQUJXem81WEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXdNUFJ5b1FBQUFNZEpSRUZVT0UrdGtnc053ekFNUk11Z0VBYWhFQWFoRUFaaEVBcWxFQVpoRUFvaEVBWWg4MVgyZEltOGZLcEVzcExHdnVkUE9zVVlweEUyQklKQ3JvSm1FVzlxSitNS2FCRmhFTU5hYlN5OW9JY0lQd3JCK2FmdkFVRm9LNEgwdE1hUTNYdGxyZ2dEaE9WVk11VDRFNU1NRzBGQmJDRVl6allUN094TEV2SUhRTFkyeld3UTNEKzlsdXlPUVRmS0RpRkQzaVVJZlBrOFZxcktqZ0FpU2ZHRlBlY3JnNkhONm0vaUJjd2lEQW83V2lCZWF3YStLd2g3dFpvU0NHTE1xd2xTQXpWRGhvSys2dkg0RzBQNXdka0FBQUFBU1VWT1JLNUNZSUk9KX0uc3AtY2xlYXItZGlzcGxheXtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCU7YmFja2dyb3VuZC1pbWFnZTp1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoRkFBVUFQY0FBQUFBQUptWm1aMmRuWjZlbnFLaW9xT2pvNlNrcEtXbHBhYW1wcWVucDZpb3FLbXBxYXFxcXF1cnEvSHg4Zkx5OHZUMDlQWDE5ZmYzOS9qNCtQbjUrZnI2K3Z2Nyt3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNINUJBRUFBUDhBTEFBQUFBQVVBQlFBQUFpaEFQOUZvUEN2b01HREJ5MDgrRWRoUUFJSkNDTXliQ0RBQVlVRUFSQkFsRmlRUW9NQUJRaEtVSkJ4WTBTUElDRVlIQm5nZ0VtREtBdW9QTWpTNWNHWU14SFczSWlUNDc4SkpBOE0vQ2pUWjBHZ0xSZWtOR3B3QXNZQUJISXlwY0FnUU1zSVREdFdKWUJSNk5TcU1pY285Y3FSNnRLZlk3R2VCQ3VWd2xpcERObWVmQXRUcmtTekIxUmFJQW9Yb2RzQUJpWkFFRkIwNmdJQldDMW1MVmdCYTBBQU93PT0pfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vc3JjL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJEL3NwZWN0cnVtLmNzc1xuLy8gbW9kdWxlIGlkID0gMTk3XG4vLyBtb2R1bGUgY2h1bmtzID0gNiJdLCJzb3VyY2VSb290IjoiIn0=');
},292:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(196);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!./Viewing.Extension.Markup2D.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!./Viewing.Extension.Markup2D.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQuY3NzPzQyNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJELmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJELmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9WaWV3aW5nLkV4dGVuc2lvbi5NYXJrdXAyRC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJEL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJELmNzc1xuLy8gbW9kdWxlIGlkID0gMjkyXG4vLyBtb2R1bGUgY2h1bmtzID0gNiJdLCJzb3VyY2VSb290IjoiIn0=")},293:function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(197);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!./spectrum.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!./spectrum.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvVmlld2luZy5FeHRlbnNpb24uTWFya3VwMkQvc3BlY3RydW0uY3NzPzA5NjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NwZWN0cnVtLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NwZWN0cnVtLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zcGVjdHJ1bS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL1ZpZXdpbmcuRXh0ZW5zaW9uLk1hcmt1cDJEL3NwZWN0cnVtLmNzc1xuLy8gbW9kdWxlIGlkID0gMjkzXG4vLyBtb2R1bGUgY2h1bmtzID0gNiJdLCJzb3VyY2VSb290IjoiIn0=")}})});